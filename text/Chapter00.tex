\chapter{Why context-aware programming matters} 
\label{ch:introduction1} 

Many advances in programming language design are driven by some practical motivations. Sometimes, 
the practical motivations are easy to see -- for example, when they come from an external change 
such as the rise of multi-core processors. Sometimes, discovering the practical motivations is a 
difficult task -- perhaps because we are so used to a certain way of doing things that we do not 
even \emph{see} the flaws of our approach. 

% ==================================================================================================

\section{Programming language and innovation}

We briefly consider two practical concerns that led to the development of new programming languages. 
This helps to explain why context-aware programming is of importance, which we cover in the next section. 
The examples are by no means representative, but they illustrate the motivations well.

\paragraph{Parallel programming.} 

The rise of multi-core CPUs is a clear example of an external development influencing
programming language research. As multi-core and multi-processor systems became de-facto standard, 
languages had to provide better abstractions for parallel programming. This led to the industrial 
popularity of \emph{immutable} data structures (and functional programming in general), software 
transactional memory \cite{app-haskell-stm}, data-parallelism and also asynchronous 
computing \cite{app-fsharp-async}. 

In this case, the motivation is easy to see -- writing multi-core programs using earlier 
abstractions, such as threads and locks, is difficult and error-prone. At the same time, 
multi-core CPUs become the standard very quickly and so the lack of good language abstractions
was apparent.

\paragraph{Data access.}

Accessing data is an example of a more subtle challenge. Initiatives like open government data
certainly make more data available. However, to access the data, one has to parse CSV and Excel files, 
issue SQL or SPARQL queries (to query database and the semantic web, respectively).

Technologies like LINQ \cite{app-linq} make querying data significantly easier. But perhaps 
because accessing data became important more gradually, it was not easy to see that inline
SQL is a poor solution.

This is even more the case for \emph{type providers} -- a recent feature in F\# that integrates
external data sources directly into the type system of the language and thus makes data explorable
directly from the source code editor (through features such as auto-completion on object members).
It is not easy to see the limitations of standard techniques (using HTTP requests to query REST 
services or parsing CSV files and using string-based lookup) until one sees how type providers 
change the data-scientist's workflow\footnote{This is difficult to explain in writing and so the 
reader is encouraged to watch a video showing type providers for the WorldBank and CSV data 
sources \cite{app-fsharp-world}.}.

\paragraph{Context-aware programming.}

In this chapter, we argue that the next important practical challenge for programming language 
designers is designing languages that are better at working with (and understanding) the 
\emph{context in which programs are executed}. 

This challenge is of the kind that is not easy to see -- perhaps because we are so used to 
doing things in certain ways that we cannot see their flaws. In this chapter, we aim to
uncover such flaws -- we look at a number of basic programs that rely on contextual 
information, we explain why they are inappropriate and then we briefly outline how this
thesis remedies the situation.

Putting deeper philosophical questions about the nature of scientific prog\-ress aside,
the goal of programming language research is generally to design languages that provide 
more \emph{appropriate abstractions} for capturing common problems, are \emph{simple} and 
more \emph{unified}. 
These are exactly the aims that we follow in this thesis. In this chapter, we explain what
the common problems are. In Chapter~\ref{ch:flat-coeffects} and Chapter~\ref{ch:structural-coeffects},
we develop two simple calculi to understand and capture the structure of the problems and,
finally, Chapter~\ref{ch:unified-coeffects} unifies the two abstractions.

% ==================================================================================================

\section{Why context-aware programming matters}

The phrase \emph{context in which programs are executed} sounds rather abstract and generic.
What notions of \emph{context} can be identified in modern software systems?
Different environments provide different resources (\eg~database
or GPS sensor), environments are increasingly diverse (\eg~multiple versions of different
mobile platforms). Web applications are split between client, server and mobile components; mobile
applications must be aware of the physical environment while the ``internet
of things`` makes the environments even more heterogeneous. At the same time, applications access
rich data sources and need to be aware of security policies and provenance information from the
environment.

Writing such context-aware (or environment-aware) applications is a fundamental problem of modern 
software engineering. The state of the art relies on ad-hoc approaches -- using hand-written conditions 
or pre-processors for conditional compilation. Common problems that developers face include: 

\begin{itemize}
\item \textbf{System capabilities.} When writing code that is cross-compiled to multiple 
  targets (e.g. SQL \cite{app-linq}, OpenCL or JavaScript \cite{app-hop-lang}) a part of the compilation 
  (\eg~SQL generation) often occurs at runtime and developers have no guarantee that it will succeed 
  until the program is executed.  
  
\item \textbf{Platform versions.} When developing cross-platform applications, different platforms
  (and different versions of the same platform) provide different API functions. Writing a 
  cross-platform code usually relies on (fragile) conditional compilation or (equally fragile) 
  dynamic loading.
      
\item \textbf{Security and provenance.} When working with data (be it sensitive database or social 
   network data), we have permissions to access only some of the data and we may want to track 
   \emph{provenance} information. However, this is not checked -- if a program attempts to access 
   unavailable data, the access will be refused at run-time.
  
\item \textbf{Resources \& data availability.} When creating a mobile application, the program may
  (or may not) be granted access to device capabilities such as GPS sensor, social updates or battery
  status. We would like to know which of the capabilities are required and which are optional
  (\ie~enhance the user experience, but there is a fallback strategy). Equally, on the server-side,
  we might have access to different database tables and other information sources.
\end{itemize}

Most developers do not perceive the above as programming language flaws -- they are simply common
programming problems (at most somewhat annoying and tedious) that had to be solved. However, this 
is because we do not realize that a suitable language extension could make the above problems 
significantly easier to solve. As the number of distinct contexts and their diversity increases,
these problems will become even more commonplace.

The following sub-sections explore four examples in more details. The examples are chosen to 
demonstrate two distinct forms of contexts that are studied in this thesis.

% --------------------------------------------------------------------------------------------------

\begin{figure}
\begin{equation*}
\begin{array}{l}
\kvd{for}~\ident{header},\ident{value}~\kvd{in}~\ident{header}~\kvd{do}\\[-0.25em]
\hspace{2em}\kvd{match}~\ident{header}~\kvd{with}\\[-0.25em]
\hspace{2em}|~\str{accept} \rightarrow~ \ident{req.Accept} \leftarrow \ident{value}\\[-0.25em]
%
\prepk{\#if}~\prepi{FX\_NO\_WEBREQUEST\_USERAGENT}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~ \ident{req.UserAgent} \leftarrow \ident{value}\\[-0.25em]
\prepk{\#else}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~
  \ident{req.Headers}.[\,\ident{HttpHeader.UserAgent}\,] \leftarrow \ident{value}\\[-0.25em]
\prepk{\#endif}\\[-0.25em]
%
\prepk{\#if}~\prepi{FX\_NO\_WEBREQUEST\_REFERER}\\[-0.25em]
\hspace{2em}|~\str{referer} \rightarrow~ \ident{req.Referer} \leftarrow \ident{value}\\[-0.25em]
\prepk{\#else}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~
  \ident{req.Headers}.[\,\ident{HttpHeader.Referer}\,] \leftarrow \ident{value}\\[-0.25em]
\prepk{\#endif}\\[-0.25em]
%
\hspace{2em}|~\ident{other} \rightarrow~ \ident{req.Headers}.[\,\ident{other}\,] \leftarrow \ident{value}\\[-0.25em]
\end{array}
\end{equation*}

\vspace{1em}
\noindent\makebox[\linewidth]{\rule{\textwidth}{0.5pt}} 
\vspace{-1.5em}
\caption{Conditional compilation in the HTTP module of the F\# Data library}
\label{fig:introduction-context-http}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#1: Platform versioning}

The diversity across devices means that developers need to target an increasing number of platforms
and possibly also multiple versions of each platform. For Android, there is a number called 
API level \cite{app-android-apilevel} which ``uniquely identifies the framework API revision offered 
by a version of the Android platform''. Most changes in the libraries (but not all) are additive.

Equally, in the .NET ecosystem, there are multiple versions of the .NET runtime, mobile and 
portable versions of the framework etc. The differences may be subtle -- for example, some members
are omitted to make the mobile version of the library smaller, some functionality is not available
at all, but naming can also vary between versions.

For example, the Figure~\ref{fig:introduction-context-http} shows an excerpt from the \ident{Http} module 
in the F\# Data library\footnote{The file version shown here is available at:
\url{https://github.com/fsharp/FSharp.Data/blob/b4c58f4015a63bb9f8bb4449ab93853b90f93790/src/Net/Http.fs}}.
The example uses conditional compilation to target multiple versions of the .NET framework. Such code
is difficult to write -- to see whether a change is correct, it had to be recompiled for all combinations
of pre-processor flags -- and maintaining the code is equally hard. The above example could be refactored
and the .NET API could be cleaner, but the fundamental issue remains. If the language does not understand
the context (here, the different platforms and platform versions), it cannot provide any static
guarantees about the code.

As an alternative to conditional compilation, developers can use dynamic loading. For example, 
on Android, programs can access API from higher level platform dynamically using techniques like 
reflection and writing wrappers. This is even more error prone. As noted in an article introducing
the technique\footnote{Retrieved from: \url{http://android-developers.blogspot.com/2009/04/backward-}\\\url{compatibility-for-android.html}}:
\emph{``Remember the mantra: if you haven't tried it, it doesn't work''}. Again, it would be 
reasonable to expect that statically-typed languages could provide a better solution.

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#2: System capabilities}

Another example related to the previous one is when libraries use meta-programming techniques
(such as LINQ \cite{app-linq} or F\# quotations \cite{app-fsharp-metaprog}) to translate code
written in a subset of a host language to some other target language, such as SQL, OpenCL or 
JavaScript. This is an important technique, because it lets developers targets multiple 
heterogeneous runtimes that have limited execution capabilities.

For example, consider the following LINQ query written in C\# that queries a database and
selects product names where the first upper case letter is "C":
%
\begin{equation*}
\begin{array}{l}
\kvd{var}~\ident{db} = \kvd{new}~\ident{NorthwindDataContext}();\\[0.25em]
\kvd{from}~\ident{p}~\kvd{in}~\ident{db.Products}\\[-0.25em]
\kvd{where}~\ident{p.ProductName.First}(\ident{c} \Rightarrow \ident{Char.IsUpper}(\ident{c})) == \str{C}\\[-0.25em]
\kvd{select}~\ident{p.ProductName};
\end{array}
\end{equation*}
%
This appears as a perfectly valid code ant the C\# compiler accepts it. However, when the program
is executed, it fails with the following error:
%
\begin{quote}
Unhandled Exception: \texttt{System.NotSupportedException}: Sequence operators 
not supported for type \texttt{System.String}.
\end{quote}
%
The problem is that LINQ can only translate a \emph{subset} of normal C\# code. The above snippet
uses \ident{First} method to iterate over characters of a string, which is not supported. This is
not a technical limitation of LINQ, but a fundamental problem of the approach. 

When cross-compiling to a limited environment, we cannot always support the full source language.
The example with LINQ and SQL demonstrates the importance of this problem. As of March 2014,
Google search returns 11800 results for the message above and even more (44100 results) for a
LINQ error message \emph{``Method X has no supported translation to SQL``} caused by a similar 
limitation. 

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#3: Confidentiality and provenance}

The previous two examples were related to the non-existence of some library functions in another
environment. Another common factor was that they were related to the execution context of the whole 
program or a scope. However, contextual properties can be also related to specific variables.

For example, consider the following code sample that accesses database by building a SQL query
using string concatenation:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{query} = \ident{sprintf}~\str{SELECT * FROM Products WHERE Name='\%s'}~\ident{name}\\[-0.25em]
\kvd{let}~\ident{cmd} = \kvd{new}~\ident{SqlCommand}(\ident{query})\\[-0.25em]
\kvd{let}~\ident{reader} = \ident{cmd.ExecuteReader}()
\end{array}
\end{equation*}
%
The code compiles without error, but it contains a major security flaw called \emph{SQL injection}
(an attacker could enter \str{'; DROP TABLE Products -{}-} as their \ident{name} and delete the 
database table with products). For this reason, most libraries discourage building SQL commands by
string concatenation, but there are still many systems that do so. 

The example demonstrates a more general property. Sometimes, it is desirable to track additional 
meta-data about variables that are in some ways special. Such meta-data can determine how the variables
can be used. Here, \ident{name} comes from the user input. This \emph{provenance} information should 
be propagated to \ident{query}. The \ident{SqlCommand} object should then require arguments that can
not directly contain user input (in an unchecked form). Such marking of values (but at run-time)
is also called tainting \cite{app-tainting-sql}.

Similarly, if we had \ident{password} or \ident{creditCard} variables in a client/server web application,
these should be annotated as sensitive and it should not be possible to send their values over an
unsecured network connection. 
 
In another context, when working with data (\eg~in data journalism), it would be desirable to 
track meta-data about the quality and the source of the data. For example, is the source trustworthy?
Is the data up-to-date? Such meta-data could propagate to the result and tell us important 
information about the calculated results.

% --------------------------------------------------------------------------------------------------

\subsection{Context-awareness \#4: Checking array access patterns}

The last example leaves the topic of cross-platform and distributed computing. We focus on 
checking how arrays are accessed. This is a simpler version of the data-flow programming
examples used later in the thesis.

Consider a simple programming language with arrays where $n^{\textnormal{th}}$ element of an
array \ident{arr} is accessed using $\ident{arr}[n]$. Furthermore, we focus on performing local
transformations and we assume that the keyword $\kvd{cursor}$ returns the \emph{current} location
in the array.

The following example implements a simple one-dimensional cellular automata, reading from the
\ident{input} array and writing to \ident{output}:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{sum}=\ident{input}[\kvd{cursor} - 1] ~+~ \ident{input}[\kvd{cursor}] ~+~ \ident{input}[\kvd{cursor} + 1]\\[-0.25em]
\kvd{if}~\ident{sum}=2 ~||~ (\ident{sum}=1 ~\&\&~ \ident{input}[\kvd{cursor} - 1] = 0)\\[-0.25em] 
\kvd{then}~\ident{output}[\kvd{cursor}] \leftarrow 1 ~\kvd{else}~\ident{output}[\kvd{cursor}] \leftarrow 0

\end{array}
\end{equation*}
%
In this example, we use the term \emph{context} to refer to the values in the array around the 
current location provided by \kvd{cursor}. The interesting question is, how much of the context
(\ie~how far in the array) does the program access. 

This is contextual information attached to individual (array) variables. 
In the above example, we want to track that \ident{input} is accessed in the range $\langle-1, 1 \rangle$
while \ident{output} is accessed in the range $\langle 0, 0 \rangle$. When calculating the ranges,
we need to be able to compose ranges $\langle-1,-1$, $\langle 0,0 \rangle$ and $\langle 1,1 \rangle$
(based on the accesses on the first line). 

The information about access patterns can be used to efficiently compile the computation
(as we know which sub-range of the array might be accessed) and it also allows better handling
of boundaries. For example, wrap-around behaviour we could pad the \ident{input} with a known
number of elements from the other side of the array.

% --------------------------------------------------------------------------------------------------

\subsection{Context-awareness \#4: Resource \& data availability}

A vast majority of applications accesses some data sources (like database) or resources
(like GPS sensor on a phone). This is more tricky for client/server applications where a part
of program runs on the server-side and another part runs on the client-side. I believe that 
these two parts should be written as a single program that is cross-compiled to two parts 
(and I tried to make that possible with F\# Web Tools \cite{xx})
a long time ago; more recently [WebSharper](http://websharper.com/) implemented a similar idea).

So, say we have a function \texttt{validateInput}, \texttt{readData} and \texttt{displayMessage} in my prorgam.
I want to look at their types and see what resources (or \emph{context}) they require. For example,
\texttt{readData} requires \emph{database} (or perhaps a database with a specific name), \texttt{displayMessage} 
requires access to \emph{user interface} and \texttt{validateInput} has no special requirements.

This means that I can call \texttt{validateInput} from both server-side and client-side code - it is
safe to share this piece of code, because it has no special requirements. However, when I write
a code that calls all three functions without any remote calls, it will only run on a thick
client that has access to a database as well as user interface.

I'll demonstrate this idea with a sample (pseudo-)code in a later section, so do not worry if
it sounds a bit abstract at first.

% ==================================================================================================

\section{Coeffects: Towards context-aware languages}

The above examples cover a couple of different scenarios, but they share a common theme - 
they all talk about some \emph{context} in which an expression is evaluated. The context has 
essentially two aspects:

\begin{itemize}
\item \textbf{Flat context} represents additional data, resources and meta-data that are 
   available in the execution environment (regardless of where in the program you 
   access them). Examples include resources like GPS sensors or databases, battery status,
   framework version and similar. 

\item \textbf{Structural context} contains additional meta-data related to variables. This can include
   provenance (source of the variable value), usage information (how often is the value
   accessed) or security information (does it contain sensitive data). 
\end{itemize}

As a proponent of statically typed functional languages I believe that a context-aware 
programming language should capture such context information in the type system and make
sure that basic errors (like the ones demonstrated in the four examples above) are ruled
out at compile time.  

This is essentially the idea behind \emph{coeffects}. Let's look at an example showing the
idea in (a very simplified) practice and then I'll say a few words about the theory
(which is the main topic of this thesis).

% --------------------------------------------------------------------------------------------------

\subsection{Case study: Coeffects in action}

So, how should a context-aware language look? Surely, there is a wide range of options, but I hope
I convinced you that it needs to be \emph{context-aware} in some way! I'll write my pseudo-example in a
language that looks like F\#, is fully statically typed and uses type inference.

I think that type inference is particularly important here - we want to check quite a few properties
that should not that difficult to infer (If I call a function that needs GPS, I need to have GPS access!)
Writing all such information by hand would be very cumbersome.

So, let's say that we want to write a client/server news reader where the news are stored in a 
database on a server. When a client (iPhone or Windows phone) runs, we get GPS location from the
phone and query the server that needs to connect to the "News" database using a password defined
somewhere earlier (perhaps loaded from a server-side config file):

\begin{verbatim}
let lookupNews(location) =
  let db = query("News", password)
  selectNews(db, location)  

let readNews() =
  let loc = gpsLocation()       
  remote { 
    lookupNews(loc) 
  } 

let iPhoneMain() =
  createCocoaWidget(readNews)

let windowsMain() =    
  createMetroWidget(readNews)
\end{verbatim}

The idea is that \texttt{lookupNews} is a server-side function that queries the "News" database based on 
the specified \texttt{location}. This is called from the client-side by \texttt{readNews} which get the current GPS
position and uses a \texttt{remote \{ .. \}} block to invoke the \texttt{lookupNews} function remotely (how exactly would
this be written is a separate question - but imagine a simple REST request here).

Then, we have two main functions, \texttt{iPhoneMain} and \texttt{windowsMain} that will serve as two entry points
for iPhone and Windows build of the client-side application. They are both using a corresponding
platform-specific function to build the user interface, which takes a function for reading news as an
argument.

If you wanted to write and compile something like this today, you could use F\# in Xamarin 
Studio to target iPhone and Window phone, but you'd either need two separate end-application projects 
or a large number of unmaintainable \texttt{\#if} constructs. Why not just use a single project, if 
the application is fairly simple?

I imagine that a context-aware statically typed language would let you write the above code and 
if you inspected the types of the functions, you would see something like this:

\begin{verbatim}
password      :   string { sensitive }
lookupNews    :   Location -{ database }-> list<News> 

gpsLocation   :   unit -{ gps }-> Location 
readNews      :   unit -{ rpc, gps }-> Async<list<News>> 

iPhoneMain    :   unit -{ cocoa, gps, rpc }-> unit 
windowsMain   :   unit -{ metro, gps, rpc }-> unit 
\end{verbatim}

The syntax is something that I just made up for the purpose of this article - it could
look different. Some information could even be mapped to other visual representations
(e.g. blueish background for the function body in your editor). The key thing is that
we can learn quite a lot about the context usage:

 - \texttt{password} is available in the context, but is sensitive and so we cannot return it
   as a result from a function that is called via an RPC call.
 - \texttt{lookupNews} requires database access and so it can only run on the server-side
   or on a thick client with local copy of the database.
 - \texttt{gpsLocation} accesses GPS and since we call it in \texttt{readNews}, this function
   also requires GPS (the requirement is propagated automatically).
 - We can compile the program for two client-side platforms - the entry points require
   GPS, the ability to make RPC calls and Cocoa or Metro UI platform, respectively.

When writing the application, I want to be always able to see this information (perhaps
similarly to how you can see type information in the various F\# editors). I want to be
able to reference multiple versions of base libraries - one for iPhone and another for
Windows and see all the API functions at the same time, with appropriate annotations.
When a function is available on both platforms, I want to be able to reuse the code that
calls it. When some function is available on only one platform, I want to solve this by
designing my own abstraction, rather than resorting to ugly \texttt{\#if} pragmas.

Then, I want to take this single program (again, strutured using whatever abstractions
I find appropriate) and compile it. As a result, I want to get a component (containing
\texttt{lookupNews}) that I can deploy to the server-side and two packages for iPhone and 
Windows respectively, that reference only one or the other platform.

% --------------------------------------------------------------------------------------------------

\subsection{Coeffects: Theory of context dependence}

If you're expecting a "Download!" button or (even better) a "Buy now!" button at the end of this article,
then I'll disappoint you. I have no implementation that would let you do all of this.
My work in this area has been (so far) on the theoretical side. This is a great way to 
understand what is \emph{actually} going on and what does the \emph{context} mean. And if you made
it this far, then it probably worked, because I understood the problem well enough to be 
write a readable article about it!

\subsubsection{Brief introduction to type systems}

I won't try to reproduce the entire content of the thesis in this introduction -- but I will
try to give you some background in case you are interested (that should make it easier to
look at the papers above). We'll start from the basics, so readers familiar with theory of 
programming languages can skip to the next section.

Type systems are usually described in the form of \emph{typing judgement} that have the following form:

\begin{equation}
\Gamma \vdash e : \tau
\end{equation}

The judgement means that, given some variables described by $\Gamma$, the expression or program $e$
has a type $\tau$. What does this mean? For example, what is a type of the expression \texttt{x + y}?
Well, this depends - in F\# it could be some numeric type or even a string, depending on the types
of \texttt{x} and \texttt{y}. That's why we need the variable context $\Gamma$ which specifies the types of variables.
So, for example, we can have:

\begin{equation}
x:int, y:int \vdash x+y : int
\end{equation}

Here, we assume that the types of \texttt{x} and \texttt{y} (on the left hand side) are both \texttt{int} and as a result,
we derive that the type of \texttt{x + y} is also an \texttt{int}. This is a valid typing, for the expression, but
not the only one possible - if \texttt{x} and \texttt{y} were of type \texttt{string}, then the result would also be 
 \texttt{string}.

\subsubsection{Checking what program does with effect systems}

Type systems can be extended in various interesting ways. Essentially, they give us an approximation
of the possible values that we can get as a result. For example refinement types \cite{xx}
can estimate numerical values more precisely (e.g. less than 100). However, it is also possible to 
track what a program does - how it \emph{affects} the world. For example, let's look at the following
expression that prints a number:

\begin{equation}
x:int \vdash print~x : unit
\end{equation}

This is a reasonable typing in F\# (and ML languages), but it ingores the important fact that the 
expression has a \emph{side-effect} and prints the number to the console. In Haskell, this would not be
a valid typing, because \texttt{print} would return an \texttt{IO} computation rather than just plain \texttt{unit} (for
more information see IO in Haskell \footnote{\url{http://www.haskell.org/haskellwiki/IO_inside}}.

However, monads are not the only way to be more precise about side-effects. Another option is
to use effect system \cite{xx} which essentially annotates the 
result of the typing judgement with more information about the \emph{effects} that occur as part of
evaluation of the expression:

\begin{equation}
x:int \vdash print~x : unit \& \{ IO \}
\end{equation}

The effect annotation is now part of the type - so, the expression has a type \texttt{unit \& \{ io \}} meaning
that it does not return anything useful, but it performs some I/O operation. Note that we do not track
what \emph{exactly} it does - just some useful over-approximation. How do we infer the information?
The compiler needs to know about certain language primitives (or basic library functions). Here, 
\texttt{print} is a function that performs I/O operation.

The main role of the type system is dealing with composition - so, if we have a function \texttt{read} that
reads from the console (I/O operation) and a function \texttt{send} that sends data over network, the type
system will tell us that the type and effects of \texttt{send (read ())} are \texttt{unit \& {io, network}}.

Effect systems are a fairly established idea - and they are a nice way to add better purity checking
to ML-like languages like F\#. However, they are not that widely adopted (interestingly, checked
exceptions in Java are probably the most major use of effect system). However, effect systems are
also a good example of general approach that we can use for tracking contextual information...

\subsubsection{Checking what program requires with coeffect systems}

How could we use the same idea of \emph{annotating} the types to capture information about the context?
Let's look at a part of the program from the case study that I described earlier:

\begin{equation}
pass : string \vdash query("News", pass) : NewsDb
\end{equation}

The expression queries a database and gets back a value of the \texttt{NewsDb} type (for now, let's say
that \texttt{"News"} is a constant string and \texttt{query} behaves like the SQL type provider in F\# \footnote{\url{http://www.pinksquirrellabs.com/post/2013/12/09/The-Erasing-SQL-type-provider.aspx}}
and generates the \texttt{NewsDb} type automatically).

What information do we want to capture? First of all, we want to add an annotation saying that
the expression requires \emph{database access}. Secondly, we want to mark the \texttt{pass} variable as 
\emph{secure} to guarantee that it will not be sent over an unsecured network connection etc.
The \emph{coeffect typing judgement} representing this information looks like this:

\begin{equation}
pass : string^{\{secure\}} @ \{database\} \vdash query("News", pass) : NewsDb
\end{equation}

Rather than attaching the annotations to the \emph{resulting type}, they are attached to the 
variable \emph{context}. In other words, the equation is saying -- given a variable \texttt{pass} that is
marked as secure and additional environment providing database access, the expression
\texttt{query("News", pass)} is well typed and returns a \texttt{NewsDb} value.

As a side-note, it is well known that \emph{effects} correspond to \emph{monads} (and Haskell uses
monads as a way of implementing limited effect checking). Quite interestingly, \emph{coeffects}
correspond to the dual concept called \emph{comonads} and, with a syntactic extension akin to 
the \texttt{do} notation or \emph{computation expressions} \cite{xx}, you could capture contextual 
propreties by adding comonads to a language.

% ==================================================================================================

\section{Summary}

I started by explaining the
motivation for my work - different problems that arise when we are writing programs that are
aware of the context in which they run. The context includes things such as execution environment
(databases, resources, available devices), platform and framework (different versions, different
platforms) and meta-data about data we access (sensitivity, security, provenance). 

This may not be preceived as a major problem - we are all used to write code that deals with
such things. However, I believe that the area of \emph{context-aware} programming is a source of
many problems and pains - and programming languages can help!

In the second half of the article, I gave a brief introduction to \emph{coeffects} -- a programming
language theory that can simplify dealing with context.
The key idea is that we can use types to track and check additional information about
the \emph{context}. By propagating such information throughout the program (using type system
that is aware of the annotations), we can make sure that none of the errors that I used
as a motivation for this article happen. 

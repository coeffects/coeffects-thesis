\chapter{Structural coeffect language} 
\label{ch:structural-coeffects} 

\newcommand{\ctimes}{ \hat{\times} }
\newcommand{\cdupl}[0]{ \Delta } %{ \Upsilon }

\newcommand{\csprd}[0]{ \times }
\newcommand{\csvop}[0]{ \vee }

% alculus names and rule names
\newcommand{\clflt}{$\lambda_{\textnormal{\sffamily Cf}}$}
\newcommand{\clstr}{$\lambda_{\textnormal{\sffamily Cs}}$}

\newcommand{\ruleft}[1]{\textsf{\clflt\small{-T#1}}}
\newcommand{\rulefs}[1]{\textsf{\clflt\small{-S#1}}}
\newcommand{\rulest}[1]{\textsf{\clstr\small{-T#1}}}
\newcommand{\ruless}[1]{\textsf{\clstr\small{-S#1}}}
\newcommand{\rulessc}[1]{\textsf{\clstr\small{-SC#1}}}

%---------------------------------------------------------------------------------------------------

The \emph{flat coeffect system} presented in the previous sections has a number of uses, but often
we need to track context-dependence in a more fine-grained way. To track neededness or security, 
we need to associate information with individual \emph{variables} of the context. 


%===================================================================================================

\section{Introduction}


% --------------------------------------------------------------------------------------------------

\subsection{Motivation: Tracking array accesses}
\label{sec:structural-motivation}
%\newcommand{\pastval}[2]{\ident{#1}_{[#2]}}
%\newcommand{\dnat}{\ident{D}_\ident{nat}}

Similarly to the flat version, the \emph{structural coeffect calculus} works with contexts and
functions annotated with a coeffectt tags, written $\ctyp{r}{\Gamma}$ and $\ctyp{r}{\tau_1} \rightarrow \tau_2$, 
respectively, but we use richer tag structure.

As an example, consider a language that allows us to get a value of a variable (representing
some changing data-source) \ident{x} versions back using the syntax $\pastval{a}{x}$. 
To track information about individual variables, we use a product-like operation $\csprd$ on tags 
to mirrors the product structure of variables. For example:
%
\begin{equation*}
\begin{array}{l}
\ctyp{5 \csprd 10}{(\ident{a}:\dnat, \ident{b}:\dnat)}
  \vdash
    \pastval{a}{5}+\pastval{b}{10}: \ident{nat}
\end{array}
\end{equation*}
%
The coeffect tag $5 \csprd 10$ corresponds to the free-variable context $\ident{a}, \ident{b}$, denoting
that we need at most 5 and 10 past values of \ident{a} and \ident{b}. If we substitute \ident{c}
for both \ident{a} and \ident{b}, we need another operation to combine multiple tags associated with 
a single variable:
%
\begin{equation*}
\begin{array}{l}
\ctyp{5 \csvop 10}{(\ident{c}:\dnat)}
  \vdash
    \pastval{c}{5}+\pastval{c}{10}: \ident{nat}
\end{array}
\end{equation*}
%
In this example, the operation $\csvop$ would be the \emph{max} function and so $5 \csvop 10 = 10$.
Before looking at the formal definition, consider the typing of let bindings:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{c} = \kvd{if}~\ident{test}()~\kvd{then}~\ident{a}~\kvd{else}~\ident{b}\\
\pastval{a}{15}+\pastval{c}{10}
\end{array}
\end{equation*}
%
The expression has free variables \ident{a} and \ident{b} (we ignore \ident{test}, which
is not a data source). It defines \ident{c}, which may be assigned either \ident{a} or \ident{b}.
The variable \ident{a} may be used directly (second line) or indirectly via \ident{c}.

The expression assigned to \ident{c} uses variables \ident{a} and \ident{b}, so its typing
context is $\ctyp{0 \csprd 0}{(\ident{a}, \ident{b})}$. The value $0$ is the unit
of $\csvop$ and it denotes empty coeffect. The typing context of the
body is $\ctyp{15 \csprd 10}{(\ident{a}, \ident{c})}$.

To combine the tags, we take the coeffect associated with \ident{c} and apply it to the tags
of the context in which \ident{c} was defined using the $\csvop$ operation. This is then combined 
with the remaining tags from the body yielding the overall context:
$\ctyp{15 \csprd (10 \csvop (0 \csprd 0))}{(\ident{a}, (\ident{a}, \ident{b}))}$. Using a simple
normalization mechanism (described later), this can be further reduced to
$\ctyp{(15 \csvop 10) \csprd 10}{(\ident{a}, \ident{b})}$. This gives us the required information --
we need at most $\emph{max}(15,10)$ past values of \ident{a} and at most $10$ past values of 
\ident{b}.

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffect tags}
In the previous section, the $\csvop$ operation behaves similarly to the flat $\vee$ operation.
However, the type system does not require some of the semilattice properties, because some uses
are replaced with the $\csprd$ operation. We do not require any properties about the $\csprd$ operation.
For example, in the previous example cannot be commutative (since a tag $15 \csprd 10$ has different 
meaning than $10 \csprd 15$). However, we relate the operations using distributivity laws to allow 
normalization that was hinted above.

\begin{definition}
A \emph{structural coeffect tag structure} $(S, \csprd, \csvop, 0, 1)$ is a tuple where 
$(S, \csvop)$ is a lattice-like structure with unit $0$. The additional structure is formed
by a binary operation $\csprd$ and element $1\in S$ such that
for all $r,s,t\in S$, the following equalities hold: 
%
\begin{subequations}
\begin{align}
\tag{associativity}
r \csvop (s \csvop t) &= (r \csvop s) \csvop t\\
\tag{commutativity}
r \csvop s &= s \csvop r\\
\tag{lower bound}
r \csvop 0 &= r\\
\tag{distributivity}
r \csvop (s \csprd t) &= (r \csvop s) \csprd (r \csvop t)\\
\tag{upper bound}
1 \csvop r &= 1
\end{align}
\end{subequations}
%
\end{definition}
%
% 'upper bound' (not sure what to call it) says that empty context cannot carry information
% looks like this is the upper bound of the bounded lattice ???
%
% commutativity is not strictly required by any law or type preservation, but
% it simplifies the presentation and looks reasonable
%
The tag $0$ represents that no coeffect is associated with a variable (i.e~when a variable is
always accessed using standard variable access). The tag $1$ is used to annotate empty 
variable context. For example, the context of an expression $\lambda x.x$ is empty and it needs
to carry an annotation. We explain exactly how this works when we introduce the type system.
The fact that $1$ is the upper bound means that combining it with other coeffect annotations
does not affect it and so empty contexts cannot carry any information.

The structure generalizes the \emph{flat coeffect tag structure} introduced in 
Section~\ref{sec:flat-tag-structure}, but it additionally requires a special element $1$ 
representing the upper bound. Given a flat coeffect structure, we can construct a structural
coeffect structure (but not the other way round). For certain structures, the element $1$
may be already present, but in general, it can be added as a new element.
This construction will be important in Section~\ref{sec:generalization},
where we show that \clstr~calculus generalizes~\clflt.

\begin{lemma}
\label{thm:structural-generalizaton}
A flat coeffect tag structure $(S, \vee, 0)$ implies a structural coeffect tag structure.
\end{lemma}
\begin{proof}
Take $1 \notin S$, then $(S \cup \{1\}, \vee, \vee, 0, 1)$ is a structural coeffect tag 
structure. From the properties of flat coeffect tag structure, we get that the $\vee$ operation 
is associative, commutative and $0$ is the unit with respect to $\vee$.

To prove the distributivity, we need to show $r \vee (s \vee t) = (r \vee s) \vee (r \vee t)$.
This easily follows from commutativity, associativity and idempotence of the flat coeffect tag 
structure.
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffect type system}
\label{sec:structural-types}

The simply typed system for \clstr~uses the same syntax of types as the system for \clflt. 
The rules are of a form $\ctyp{r}{\Gamma}\vdash e : \tau$ where $r$ is a tag provided by 
a \emph{structural coeffect tag structure} $(S,\csprd, \csvop, 0)$.

The system differs from \clflt~in a significant aspect. It contains explicit 
structural rules that manipulate with the context. Such rules allow reordering, duplicating
and other manipulations with variable context. Such rules are known from affine or linear
type systems where they are removed to obtain more restrictive system. In our system, the
rules are present, but they manipulate the variable structure $\Gamma$ as well as the 
associated tag structure $r$.

As in linear and affine systems, the variable context $\Gamma$ in our system is not a 
simple set. Instead, we use the following tree-like structure (which is more similar to 
bunched types than to linear or affine systems):
%
\begin{equation*}
\Gamma ::= () \sep (x:\tau) \sep (\Gamma, \Gamma)
\end{equation*}
%
The syntax $()$ represents an empty context, so the structure defines a binary trees where
leaves are either variables or empty. Contexts such as $\ctyp{1\csprd(r \csprd 1)}{((), (x, ()))}$ 
contain unnecessary number of empty contexts $()$. However, we need to construct them
temporarily, because certain rules require splitting a context and, by our 
definition, the context $(x:\tau)$ is not splitable.

The typing rules of the system are shown in Figure~\ref{fig:structural-coeffect-typing}.
Many of the structural rules are expressed in terms of a helper judgement
$\ctxtrans{\ctyp{r}{\Gamma}}{\ctyp{r}{\Gamma}}$.

\paragraph{Standard rules.}
Variable access (\rulest{var}) annotates the corresponding variable with an empty coeffect
$0$. The \rulest{fun} rule assumes that the context of the body can be split into the
variable of the function and other (potentially empty) context and it attaches the coeffect
associated with the function variable to the resulting function type $\ctyp{s}{\tau_1} \rightarrow \tau_2$.

The \rulest{app} rule combines coeffects $s, t, r$ associated with the function-returning
expression, argument and the function type respectively. 
The result of evaluating the argument in the context $t$ is passed to the function that
requires context $r$, so the variables used in the context $\Gamma_2$ are annotated with
the combination of coeffects $r \csvop t$. The variable context required to evaluate the 
function value is independent and so it is annotated just with coeffects $s$.
Finally, the \rulest{let} rule is derived from let binding and application, but we show
it separately to aid the understanding.


\paragraph{Structural rules.}
The remaining rules are not syntax-directed. They are embedded using the \rulest{ctx}
rule and expressed using a helper judgement $\ctxtrans{\ctyp{r_1}{\Gamma_1}}{\ctyp{r_2}{\Gamma_2}}$
that says that the context on the left-hand side can be transformed to the context on the
right-hand side. The transformation can be applied to any part of the context, which 
is captured using the \rulest{nest} rule (it is sufficient to apply the transformation 
on the left part of the context; the right part can be transformed using \rulest{exch}).

The \rulest{empty} rule allows attaching empty context to any existing context. The rule 
is needed to type-check lambda abstractions that do not capture any outer variable.
The \rulest{weak} rule is similar, but it represents \emph{weakening} where an unused variable is 
added. The associated coeffect tag does not associate context information with the variable.
This is needed to type-check lambda abstraction that does not use the argument.

The \rulest{contr} rule is a limited form of contraction. When a variable appears repeatedly,
it can be reduced to a single occurrence. The rule is needed to satisfy the side condition
of \rulest{fun} when the body uses the argument repeatedly. The two associativity rules
together with \rulest{exch} provide ways to rearrange variables. Finally, \rulest{sub} represents
sub-coeffecting -- in \clstr~the rule operates on coeffects of individual variables.

\ExecuteMetaData[rules/rules.tex]{scl-types}


% --------------------------------------------------------------------------------------------------

\subsection{Properties of reductions}
\label{sec:structural-metatheory}
Similarly to the flat version, the \clstr~calculus is defined abstractly. We cannot define its
operational meaning, because that will differ for every concrete application. For example,
when tracking array accesses, variables are interpreted as arrays and $\pastval{a}{n}$ denotes
access to a specified element. 

Just like previously, we can state general properties of the reductions. As the syntax of expressions
is the same for \clstr~as for \clflt, the substitution and reduction $\twoheadrightarrow_\beta$ 
are also the same and can be found in Figure~\ref{fig:flat-substred}.

The structural coeffect calculus \clstr~associates information with individual variables. This means
that when an expression requires certain context, we know from what scope it comes -- the
context must be provided by a scope that defines the associated variable, which is either a
lambda abstraction or global scope. This distinguishes the structural system from the flat system
where context could have been provided by any scope and the lambda rule allowed arbitrary 
splitting of context requirements between the two scopes (or declaration and caller site).

\paragraph{Internalized substitution.}
Before looking at properties of the evaluation, we consider let binding, which can be 
viewed as internalized substitution. The typing rule \rulest{let} can be derived from 
application and abstraction as follows. 

\begin{lemma}[Definition of let binding]
If $\ctyp{r}{\Gamma} \vdash (\lambda x.e_2)~e_1 : \tau_2$
then $\ctyp{r}{\Gamma} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2$.
\end{lemma}
\begin{proof}
The premises and conclusions of a typing derivation of $(\lambda x.e_2)~e_1$
correspond with the typing rule \rulest{let}:
\begin{equation*}
\inference[]
  {\inference
    {\ctyp{r \csprd s}{(\Gamma_1, v:\tau_1)} \vdash e_2 : \tau_2 & v \notin \Gamma_1}
    {\ctyp{r}{\Gamma_1} \vdash \lambda v.e_2 : \ctyp{s}{\tau_1} \rightarrow \tau_2 } &
   \ctyp{t}{\Gamma_2} \vdash e_1 : \tau_1 }
  {\ctyp{r \csprd (s \csvop t)}{(\Gamma_1, \Gamma_2)} \vdash (\lambda v.e_2)~e_1 : \tau_2}\qedhere
\end{equation*}
\end{proof}

The term $e_2$ which is substituted in $e_1$ is checked in a different variable
and coeffect context $\ctyp{t}{\Gamma_2}$. This is common in sub-structural systems where
a variable cannot be freely used repeatedly. The context $\Gamma_2$ is used in place of 
the variable that we are substituting for. The let binding captures substitution for a 
specific variable (the context is of a form $\ctyp{r \csprd s}{\Gamma, v:\tau}$).
For a general substitution, we need to define the notion of context with a hole.

\newcommand{\chole}[4]{\ctyp{#1}{#2}[#3|#4]}
\paragraph{Substitution and holes.}
In \clstr, the structure of the variable context is not a set, but a tree. When substituting
for a variable, we need to replace the variable in the context with the context of the
substituted expression. In general, this can occur anywhere in the tree. To formulate the
statement, we define contexts with holes, written $\Delta[-]$. Note that there is a hole
in the free variable context and in a corresponding part of the coeffect tag:

\begin{equation*}
\begin{array}{rcl}
\Delta[-] &::=& \ctyp{1}{()} \\
       & \sep & \ctyp{r}{(x:\tau)}\\
       & \sep & \ctyp{-}{(-)} \\
       & \sep & \ctyp{r_1 \csprd r_2}{(\Gamma_1, \Gamma_2)}\quad~~(\textnormal{where}~\ctyp{r_i}{\Gamma_i} \in \Delta[-])\\
\end{array}
\end{equation*}
%
Assuming we have a context with hole $\ctyp{r}{\Gamma} \in \Delta[-]$, the hole filling 
operation $\chole{r}{\Gamma}{r'}{\Gamma'}$ fills the hole in the variable context with 
$\Gamma'$ and the corresponding coeffect tag hole with $r'$. The operation is defined in 
Figure~\ref{fig:structural-hole-fill}. Using contexts with holes, we can now formulate the
general substitution lemma for \clstr.

\begin{figure}

\begin{equation*}
\begin{array}{rcl}
                              \chole{1}{()}{r'}{\Gamma'} &=& \ctyp{1}{()}\\
                        \chole{r}{(x:\tau)}{r'}{\Gamma'} &=& \ctyp{r}{(x:\tau)}\\
                             \chole{-}{(-)}{r'}{\Gamma'} &=& \ctyp{r'}{\Gamma'}\\
\chole{r_1 \csprd r_2}{(\Gamma_1, \Gamma_2)}{r'}{\Gamma'} &=& \ctyp{r_1' \csprd r_2'}{(\Gamma_1', \Gamma_2')}\\
&\multicolumn{2}{l} {
  \textnormal{where}~~\ctyp{r_i'}{\Gamma_i'} = \chole{r_i}{\Gamma_i}{r'}{\Gamma'}
}
\end{array}
\end{equation*}
\caption{The definition of hole filling operation for $\Delta[-]$}
\label{fig:structural-hole-fill}
\vspace{-2em}
\end{figure}

\begin{lemma}[Substitution Lemma]
\label{thm:structural-subst}
If $\chole{r}{\Gamma}{R}{v:\tau'} \vdash e : \tau$ and $\ctyp{S}{\Gamma'} \vdash e' : \tau'$
then $\chole{r}{\Gamma}{R \csvop S}{\Gamma'} \vdash \subst{e}{v}{e'} : \tau$.
\end{lemma} 
\begin{proof}
Proceeds by rule induction over $\vdash$ using the properties of structural coeffect tag structure
$(S, \csvop, 0, \csprd, 1)$ (see Appendix~\ref{app:structural-substitution}).
\end{proof}

\begin{theorem}[Subject reduction]
\label{thm:structural-reduction}
If $\ctyp{r}{\Gamma} \vdash e_1 : \tau$ and $e_1 \twoheadrightarrow_\beta e_2$ then 
$\ctyp{r}{\Gamma} \vdash e_2 : \tau$.
\end{theorem}
\begin{proof}
Direct consequence of Lemma~\ref{thm:structural-subst} (see Appendix~\ref{app:structural-reduction}).
\end{proof}

\paragraph{Local soundness and completeness.}
As with the previous calculus, we want to guarantee that the introduction and
elimination rules (\rulest{fun} and \rulest{app}) are appropriately strong. 
This can be done by showing \emph{local soundness} and \emph{local completeness},
which correspond to $\beta$-reduction and $\eta$-expansion. Former is a special
case of subject reduction and the latter is proved by a simple derivation:
%
\begin{theorem}[Local soundness]
If $\ctyp{r}{\Gamma} \vdash (\lambda x.e_2)~e_1 : \tau$ then
$\ctyp{r}{\Gamma} \vdash \subst{e_2}{x}{e_1} : \tau$.
\end{theorem}
\begin{proof}
Special case of subject reduction (Theorem~\ref{thm:structural-reduction}).
\end{proof}
%
\begin{theorem}[Local completeness]
If $\ctyp{r}{\Gamma} \vdash f : \ctyp{s}{\tau_1} \rightarrow \tau_2$ then
$\ctyp{r}{\Gamma} \vdash \lambda x.f x : \ctyp{s}{\tau_1} \rightarrow \tau_2$.
\end{theorem}
\begin{proof} The property is proved by the following typing derivation:
%
\begin{equation*}
\inference
  {\inference
     {\ctyp{r}{\Gamma} \vdash f : \ctyp{s}{\tau_1} \rightarrow \tau_2 &
      \ctyp{0}{(x:\tau_1)} \vdash x : \tau_1 }
     {\ctyp{r \csprd (s \csvop 0)}{(\Gamma, x:\tau_1)} \vdash f~x : \tau_2}}
  {\ctyp{r}{\Gamma} \vdash \lambda x.f x : \ctyp{s}{\tau_1} \rightarrow \tau_2 }
\qedhere
\end{equation*}
\end{proof}
%
In the last step, we use the \emph{lower bound} property of structural coeffect tag, which
guarantees that $s\csvop0 = s$. Recall that in \clflt, the typing derivation for
$\lambda x.f x$ required for local completeness was not the only possible derivation.
In the last step, it was possible to split the coeffect tag arbitrarily between the 
context and the function type. 

In the \clstr~calculus, this is not, in general, the case. The $\csprd$ operator is not required 
to be associative and to have units and so a unique splitting may exist.  For example, if we
define $\csprd$ as the operator of a \emph{free magma}, then it is invertible and for a given
$t$, there are unique $r$ and $s$ such that $t = r \csprd s$. However, if the $\csprd$ operation 
has additional properties, then there may be other possible derivation.

% ==================================================================================================


\begin{figure*}[t]
\newcommand{\uu}[1]{\overline{#1}}
\begin{equation*}
\cosem{\ctyp{r_1 \csprd \ldots \csprd r_n}{(x_1 : \tau_1 \times \ldots \times x_n : \tau_n)} \vdash e : \tau} : 
  \ctyp{r_1 \csprd \ldots \csprd r_n}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau
\end{equation*}
\begin{equation*}
\begin{array}{rcll}
\cosem{\ctyp{0}{\Gamma} \vdash x_i : \tau_i} &=&
    \epsilon_0                                                                   &\quad$\ruless{var}$
\\[0.32em]
\cosem{\ctyp{r}{\Gamma} \vdash \lambda x.e : \ctyp{s}{\tau_1} \rightarrow \tau_2} &=& 
    \Lambda (\cosem{\ctyp{r \csprd s}{(\Gamma, x:\tau_1)} \vdash e : \tau_2} \circ \cmerge_{r, s})    &\quad$\ruless{fun}$
\\[0.32em]
\cosem{\ctyp{s \csprd (r \csvop t)}{(\Gamma_1, \Gamma_2)} \vdash e_1~e_2 : \tau} &=& 
    (\lambda (\gamma_1, \gamma_2) \rightarrow
    \cosem{\ctyp{s}{\Gamma_1} \vdash e_1 : \ctyp{r}{\tau_1} \rightarrow \tau_2}~\gamma_1~
    (\cobind{\cosem{\ctyp{t}{\Gamma_2}\vdash e_2 : \tau_1}}{t,r}~\gamma_2)) \circ \csplit_{s,(r \vee t)}  &\quad$\ruless{app}$
\\[0.32em]
\cosem{\ctyp{r'}{\Gamma'} \vdash e : \tau} &=&
    \cosem{\ctyp{r}{\Gamma} \vdash e : \tau} \circ \cosem{\ctxtrans{\ctyp{r'}{\Gamma'}}{\ctyp{r}{\Gamma}}}       &\quad$\ruless{ctx}$
\end{array}
\end{equation*}

\begin{equation*}
\begin{array}{rclll}
\cosem{\ctxtrans{\ctyp{r'\csprd s}{(\Gamma_1', \Gamma_2)}}{\ctyp{r \csprd s}{(\Gamma_1, \Gamma_2)}}}
&=& \cmerge_{r, s} \circ (\cosem{\ctxtrans{\ctyp{r'}{\Gamma_1'}}{\ctyp{r}{\Gamma_1}}} \times \ident{id})~\circ \csplit_{r', s}\quad&\quad\quad\quad& % spaces to align
\textnormal{\rulessc{nest}}
\\[0.8em]
\cosem{\ctxtrans{\ctyp{r\csprd s}{(\Gamma_1, \Gamma_2)} }{ \ctyp{s\csprd r}{(\Gamma_2, \Gamma_1)}}}
&=& \cmerge_{s, r} \circ \ident{swap} \circ \csplit_{r, s}&&
\textnormal{\rulessc{exch}}
\\[0.8em]
\cosem{\ctxtrans{\ctyp{r \csprd 1}{(\Gamma, ())}}{\ctyp{r}{\Gamma}}}
&=&\ident{fst} \circ \csplit_{r, 1}&&
\textnormal{\rulessc{empty}}
\\[0.8em]
\cosem{\ctxtrans{ \ctyp{r\csprd 0}{(\Gamma, x:\tau)} }{ \ctyp{r}{\Gamma}}}
&=&\ident{fst} \circ \csplit_{r, 0}&&
\textnormal{\rulessc{weak}}
\\[0.8em]
\cosem{\ctxtrans{\ctyp{r \csvop s}{(x:\tau)}}{
    \ctyp{r \csprd s}{(x:\tau, x:\tau)}}}
&=&\cmerge_{r, s} \circ \cdupl_{r, s}&&
\textnormal{\rulessc{contr}}
\\[0.8em]
\cosem{\ctxtrans{\ctyp{r\csprd (s\csprd t)}{(\Gamma_1, (\Gamma_2, \Gamma_3))}}{
    \ctyp{(r\csprd s)\csprd t}{((\Gamma_1, \Gamma_2), \Gamma_3)}}}\;
&=& \cmerge_{r \csprd s, t} \circ (\cmerge_{r, s} \times \ident{id}) \circ \ident{assoc}_1 \circ
        (\ident{id} \times \csplit_{s, t}) \circ \csplit_{r, s \csprd t}&&
\textnormal{\rulessc{assoc}}
\\[0.8em]
\cosem{\ctxtrans{\ctyp{r}{\Gamma}}{\ctyp{s}{\Gamma}}}
&=&
\iota_{r, s}
&&
\textnormal{\rulessc{sub}}
\end{array}
\end{equation*}


\caption{Categorical semantics for~\clstr}
\label{fig:structural-semantics}
\vspace{-0.5em}
\end{figure*}

% --------------------------------------------------------------------------------------------------


\section{Semantics of structural coeffects}
\label{sec:structural-semantics}

The semantics of structural coeffect calculus \clstr~can be defined similarly to the semantics of
\clflt. The most notable difference is that the structure of coeffect tag now mirrors the structure
of the variable context. Thus an expression $\ctyp{r \csprd s}{(\Gamma_1, \Gamma_2)} \vdash e : \tau$ 
is modelled as a function $\ctyp{r \csprd s}{(\Gamma_1 \ctimes \Gamma_2)} \rightarrow \tau$. 

As discussed in \ref{sec:structural-types}, the variable context $\Gamma$ in structural coeffect
system is not a simple finite product, but instead a binary tree. To model this, we do not use
ordinary products in the domain of the semantic function, but instead use a special 
constructor $\ctimes$. This way, we can guarantee that the variable structure corresponds to 
the tag structure. 

\subsection{Structural tagged comonads}
\label{sec:structural-tagged-comonads}

To model composition of functions, we reuse the definition of \emph{tagged comonads} from 
Section~\ref{sec:tagged-comonads} without any change. This means that composing morphisms
$T^r \tau_1 \rightarrow \tau_2$ with $T^s \tau_2 \rightarrow \tau_3$ still gives us a morphism
$T^{r \csvop s} \tau_1 \rightarrow \tau_3$ and we use the $\csvop$ operation to combine the 
context-requirements.

However, functions that do not exist in context have only a single input variable (with a 
single corresponding tag). To model complex variable contexts, we need two additional
operations that allow manipulation with the variable context. Similarly to the model of \clflt,
we also require operations that model duplication and sub-coeffecting:

\begin{definition}[Structural tagged comonad]
Given a structural coeffect tag structure $(S, \csprd, \csvop, 0, 1)$ a \emph{structural tagged comonad} is a 
tagged comonad over $(S, \csvop, 0)$ comprising of $T^r$, $\epsilon_0$ and
$\cobind{(-)}{r, s}$ together with a mapping $- \ctimes -$ from a pair of objects 
$\obj{\ccat} \times \obj{\ccat}$ to an object $\obj{\ccat}$ and families of mappings:
%
\begin{equation*}
\begin{array}{rcl}
\cmerge_{r, s} &:& T^r A \times T^s B \rightarrow T^{(r \csprd s)}(A \ctimes B)\\
\csplit_{r, s} &:& T^{(r \csprd s)}(A \ctimes B) \rightarrow T^r A \times T^s N\\
\end{array}
\end{equation*}
%
% Delta is still defineable
% ?? \cdupl_{r, s}  &:& T^{(r \csvop s)}A \rightarrow T^r A \times T^s A\\
%
And with a family of mappings $\iota_{r, s} : T^r A \rightarrow T^s A$ for all $r, s \in S$ such that $r \vee s = r$.
%
%  TODO: laws?
%
\end{definition}

The family of mappings $\iota_{r, s}$ is the same as for \emph{flat} coeffects
and it can still be used to define a family of mappings that represents \emph{duplicating}
of variables while splitting the additional coeffect tags:
%
\begin{equation*}
\begin{array}{l}
\cdupl_{r, s} : T^{(r \vee s)}A \rightarrow T^r A \times T^s A\\
\cdupl_{r, s}(\gamma) = (\iota_{(r\vee s), r}~\gamma, \iota_{(r\vee s), s}~\gamma)
\end{array}
\end{equation*}
%
The type of the $\cmerge_{r,s}$ operation looks similar to the one used for \emph{flat} coeffects,
but with two differences. Firstly, it combines tags using $\csprd$ instead of $\vee$, 
which corresponds to the fact that the variable context now consists of two parts (a tree node).
Secondly, to model the tree node, the resulting context is modelled as $A \ctimes B$
(instead of $A \times B$ as previously).

To model structural coeffects, we also need $\csplit_{r, s}$, which serves as the dual
of $\cmerge_{r, s}$. It represents \emph{splitting} of context containing multiple 
variables. The operation was not needed for \clflt, because there \emph{splitting} could
be defined in terms of \emph{duplication} provided by $\cdupl_{r, s}$. For \clstr,
the situation is different. The $\csplit_{r, s}$ operation takes a context annotated
with $r \csprd s$ that carries $A \ctimes B$.

Examples of \emph{structural tagged comonads} are shown in Section~\ref{sec:structural-tainting}.
Before looking at them, we finish our discussion of categorical semantics.

\paragraph{Categorical notes.}
The mapping $T^r$ can be extended to an endo-functor $\hat{T}^r$ in the same way as in
Section~\ref{sec:tagged-comonads}. However, we still cannot freely manipulate the 
variables in the context. Given a context modelled as $T^{r \csprd s}(A \ctimes B)$,
we can lift a morphism $f$ to $\hat{T}^{r \csprd s}(f)$, but we cannot manipulate the
variables, because $A \ctimes B$ is not a product and does not have projections $\pi_i$.

This also explains why $\csplit$ cannot be defined in terms of $\cdupl$. Even if we 
could apply $\cdupl_{r, s}$ on the input (if the tag $r \csprd s$ coincided
with tag $r \csvop s$) we would still not be able to obtain $T^r A$ from $T^r (A \ctimes B)$.

This restriction is intentional -- at the semantic level, it prevents manipulations
with the context that would break the correspondence between tag structure and the
product structure.

\subsection{Categorical semantics}
The categorical semantics of \clstr is shown in Figure~\ref{fig:structural-semantics}.
It uses the \emph{structural tagged comonad} structure introduced in the previous section,
together with the helper operation $\cdupl_{r, s}$ and the following simple helper 
operations:
\begin{equation*}
\begin{array}{rcl}
\ident{assoc} &=& \lambda (\delta_r, (\delta_s, \delta_t)) \rightarrow ((\delta_r, \delta_s), \delta_t)\\
\ident{swap}  &=& \lambda (\gamma_1, \gamma_2) \rightarrow (\gamma_2, \gamma_1)\\
f \times g &=& \lambda (x, y) \rightarrow (f~x, g~y)
\end{array}
\end{equation*}

When compared with the semantics of \clflt (Figure~\ref{fig:flat-semantics}), there is a number of 
notable differences. Firstly, the rule \ruless{var} is now interpreted as $\epsilon_0$ without 
the need for projection $\pi_i$. When accessing a variable, the context contains only the accessed
variable. The \ruless{fun} rule has the same structure -- the only difference is that we use the
$\csprd$ operator for combining context tags instead of $\vee$ (which is a result of the change of
type signature in $\cmerge_{r, s}$).

The rule \ruless{app} now uses the operation $\csplit_{s, (r \csvop t)}$ instead of $\cdupl_{s, (r \csvop t)}$,
which means that it splits the context instead of duplicating it. This makes the system more 
structural -- the expressions use disjunctive parts of the context -- and also explains why the
composed coeffect tag is $s \csprd (r \csvop t)$.

The only rule from \clflt~that was not syntax-directed (\rulefs{sub}) is now generalized to a number
of non-syntax-directed rules \rulessc{} that perform various manipulations with the context. The semantics
of $\cosem{ \ctxtrans{\ctyp{r_1}{\Gamma_1}}{\ctyp{r_2}{\Gamma_2}} }$ is a function that, when given a context
$\ctyp{r_1}{\Gamma_1}$ produces a new context $\ctyp{r_2}{\Gamma_2}$. The semantics in \ruless{ctx} then 
takes a context, converts it to a new context which is compatible with the original expression $e$.
The context manipulation rules work as follows:

\begin{itemize}
\item The \rulessc{nest} and \rulessc{exch} rules use $\csplit_{r, s}$ to split the context into a product
  of contexts, then perform some operation with the contexts -- transform one and swap them, respectively.
  Finally, they re-construct a single context using $\cmerge_{r, s}$.

\item The \rulessc{empty} and \rulessc{weak} rules have the same semantics. They both split the context
  and discard one part (containing either an unused variable or an empty context).

\item If we interpreted \rulessc{contr} by applying functor $T^{r\csvop s}$ to a function that duplicates
  a variable, the resulting context would be $\ctyp{r \csvop s}(x:\tau, x:\tau)$, which would break the
  correspondence between coeffect tag and context variable structure. However, that interpretation would be
  incorrect, because we use $\ctimes$ instead of normal product for variable contexts. As a result, the
  rule has to be interpreted as a composition of $\cdupl_{r, s}$ and $\cmerge_{r, s}$, which also turns
  a tag $r \csvop s$ into $r \csprd s$.

\item The \rulessc{assoc} rule is similar to \rulessc{exch} in the sense that it de-constructs the context,
  manipulates it (using \ident{assoc}) and then re-constructs it.

\item Finally, the \rulessc{sub} rule interprets sub-coeffecting on the context associated with a single
  variable using the primitive natural transformation $\iota_{r, s}$.
\end{itemize}

\paragraph{Alternative: Separate variables.} As an alternative, we could model an expression by
attaching the context separately to individual variables. This an expression
$\ctyp{r \csprd s}{(\Gamma_1, \Gamma_2)} \vdash e : \tau$ would be modelled as 
$\ctyp{r}{\Gamma_1} \times \ctyp{s}{\Gamma_2} \rightarrow \tau$. However, this 
approach largely complicates the definition of application (where tag of all 
variables in a context is affected). Moreover, it makes it impossible to express
\clflt~in terms of \clstr~as discussed in Section~\ref{sec:generalization}.

\paragraph{Alternative: Without sub-coeffecting.} The semantics presented above uses the natural
transformation $\iota_{r, s}$, which represents sub-coeffecting, to define the duplication
operation $\cdupl_{r, s}$. However, structural coeffect calculus \clstr does not require 
sub-coeffecting in the same way as flat \clflt (where it is required for subject reduction).

This means that it is possible to define a variant of the system that does not have the \rulest{sub} 
typing rule. Then the semantics does not need the $\iota_{r, s}$ transformation, but instead,
the following natural transformation has to be provided:
%
\begin{equation*}
\cdupl_{r, s} : T^{(r \vee s)}A \rightarrow T^r A \times T^s A
\end{equation*}
%
This variant of the system could be used to define a system that ensures that all provided 
context is used and is not over-approximated. This difference is similar to the difference between
affine type systems (where a variable can be used at most once) and linear type systems 
(where a variable has to be used exactly once).

% --------------------------------------------------------------------------------------------------

\section{Examples of structural coeffects}

\subsection{Example: Liveness analysis}
\label{sec:structural-neededness}

\subsection{Example: Data-flow (revisited) }
\label{sec:structural-tainting}

\todo{Also, consider additional language features that we consider for flat coeffects
  (mainly recursion and possibly conditionals)}
  
\section{Conclusions}

\todo{ (...) }
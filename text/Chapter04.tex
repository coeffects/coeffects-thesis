%\begin{flushright}{\slshape    
%Even the most puritanical rationalist will be forced to stop arguing and \\
%use propaganda [...] because the psychological conditions have disappeared \\
%that allowed effective argument and therefore influence over the others.} \\ \medskip
%--- Paul Feyerabend, \emph{Against Method} \cite{philosophy-feyerabend}
%\end{flushright}
%\vspace{2em}

% ==================================================================================================

\chapter{Flat coeffect calculus} 
\label{ch:flat} 

Successful programming language abstractions need to generalize a wide range of recurring
problems while capturing the key commonalities. These two aims are typically in opposition -- 
more general abstractions are less powerful, while less general abstractions cannot be
used as often.

In the previous chapter, we outlined a number of systems that capture how computations
access the environment in which they are executed. We identified two kinds of systems --
\emph{flat} capturing whole-context properties and \emph{structural} capturing per-variable
properties. As we show in Chapter~\ref{ch:unified}, the systems can be unified using a single 
abstraction. This is useful when implementing and composing the systems, but such abstraction 
is  \emph{less powerful} -- \ie~its generality hides useful properties that we can see 
when we consider the systems separately. For this reason, this and the next chapter discusses 
\emph{flat} and \emph{structural} systems separately.

% ==================================================================================================

\section{Introduction}
\label{sec:flat-intro}

In the previous chapter, we looked at three important examples of systems that track whole-context 
properties. The type systems for whole-context liveness (Section~\ref{sec:applications-flat-live}) 
and whole-context data-flow (Section~\ref{sec:applications-flat-dataflow}) have a very similar 
structure -- their lambda abstraction duplicates the requirements and their application arises
from the combination of \emph{sequential} and \emph{point-wise} composition.

The system for tracking of implicit parameters (Section~\ref{sec:applications-flat-impl}), and
similar systems for rebindable resources, differ in two ways. In lambda abstraction, they split
the context requirements between the declaration-site and the call-site and they use only a single
operator on the indices, typically $\cup$.

%---------------------------------------------------------------------------------------------------

\subsection{Contributions}

All of the examples are practically useful and important and so we want to be able to capture all
of them. Despite the differences, the systems can fit the same framework. The contributions of this
chapter are as follows:

\begin{itemize}
\item We present a \emph{flat coeffect calculus} with a type system that is parameterized by a 
  \emph{flat coeffect algebra} and can be instantiated to obtain all of the three examples
  discussed (Section~\ref{sec:flat-calculus}).
  
\item We give the equational theory of the calculus and discuss type-preservation for call-by-name
  and call-by-value reduction (Section~\ref{sec:flat-syntax}). We also extend the calculus
  with pairs and recursion (Section~\ref{sec:flat-exts}).
  
\item We present the semantics of the calculus in terms of \emph{indexed comonads}, which is a
  generalization of comonads, a category-theoretical dual of monads (Section~\ref{sec:flat-semantics}).
  The semantics provides deeper insight into how (and why) the calculus works.

\item We develop an alternative presentation of the system in terms of a simple structure 
  (semi-lattice) and use it to develop a type inference algorithm for flat coeffect calculus.
\end{itemize}

%---------------------------------------------------------------------------------------------------

\subsection{Related work}

The development in this chapter can be seen as a counterpart to the well-known development of 
\emph{effect systems} \cite{effects-gifford} and the use of \emph{monads} \cite{monad-notions}
in programming languages. The syntax and type system of the flat coeffect calculus follows 
similar style as effect systems \cite{effects-polymorphic,effects-talpin-et-al}, but differs
in the structure, as explained in the previous chapter, most importantly in lambda abstraction.

Wadler and Thiemann famously show a correspondence between effect systems to monads 
\cite{monads-effects-marriage}, relating effectful functions $\tau_1 \xrightarrow{\sigma} \tau_2$ 
to monadic computations $M^\sigma \tau_1 \rightarrow \tau_2$. In this chapter, we show a similar
correspondence between \emph{coeffect systems} and \emph{comonads}. However, due to the asymmetry 
of $\lambda$-calculus, this is not a simple mechanical dualization.

The main purpose of the comonadic semantics presented in this chapter is to provide a semantic
motivation for the flat coeffect calculus. The semantics is inspired by the work of Uustalu and
Vene \cite{comonads-notions} who present the semantics of contextual computations (mainly for
data-flow) in terms of comonadic functions $C \tau_1 \rightarrow \tau_2$. Our \emph{indexed 
comonads} annotate the structure with information about the required context, \ie~$C^\sigma \tau_1 \rightarrow \tau_2$.
This is similar to the recent work on \emph{parameterized monads} by Katsumata \cite{monads-parametric}.

% ==================================================================================================

\section{Flat coeffect calculus}
\label{sec:flat-calculus}

The flat coeffect calculus is defined in terms of \emph{flat coeffect algebra}, which defines
the structure of context annotations, such as $\cclrd{r}, \cclrd{s}, \cclrd{t}$. These can be
sets of implicit parameters, integers or other values. The expressions of the calculus are those
of the $\lambda$-calculus with \emph{let} binding; assuming $T$ ranges over base types, the 
types of the calculus are defined as follows:
%
\begin{equation*}
\begin{array}{rcl}
e &::=& x \sep \lambda x.e \sep e_1~e_2 \sep \kvd{let}~x = e_1~\kvd{in}~e_2\\
\tau &::=& T \sep \tau_1 \xrightarrow{\cclrd{r}} \tau_2
\end{array}
\end{equation*}
%
We discuss pairs and recursion in Section~\ref{sec:flat-exts}. The type $\tau_1 \xrightarrow{\cclrd{r}} \tau_2$
represents a function from $\tau_1$ to $\tau_2$ that requires additional context $\cclrd{r}$.
It can be viewed as a pure function that takes $\tau_1$ \emph{with} or \emph{wrapped in} a 
context $r$. 

In the categorical semantics, the function $\tau_1 \xrightarrow{\cclrd{r}} \tau_2$ is modelled
by a morphism $C^{\cclrd{r}} \tau_1 \rightarrow \tau_2$. However, the object $C^{\cclrd{r}}$
does not exist as a syntactical value. This is because we use comonads to define the 
\emph{semantics} rather than \emph{embedding} them into the language as in the meta-language
approaches (the distinction between the two approaches has been discussed in detail in 
Section~\ref{sec:path-sem-langs}). The annotations $\cclrd{r}$ are formed by an algebraic
structure discussed next.

%---------------------------------------------------------------------------------------------------

\subsection{Reconciling lambda abstraction}
\label{sec:flat-calculus-lambda}

Recall the lambda abstraction rules for the implicit parameters system (annotating the context
with sets of required parameters) and the data-flow system (annotating the context with the
number of past required values):
%
\begin{equation*}
\tyrule{abs-imp}
  {\coctx{\Gamma, x:\tau_1}{\aclrd{r} \cup \aclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\aclrd{s}} \tau_2 }
\;
\tyrule{abs-df}
  {\coctx{\Gamma, x:\tau_1}{\aclrd{n}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{n}} \vdash \lambda x.e : \tau_1 \xrightarrow{\aclrd{n}} \tau_2 }
\end{equation*}

~

In order to capture both systems using a single calculus, we need a way of unifying the two
systems. For the data-flow system, this can be achieved by over-approximating the number of 
required past elements:
%
\begin{equation*}
\tyrule{abs-min}
  {\coctx{\Gamma, x:\tau_1}{\textnormal{min}(\aclrd{n}, \aclrd{m})} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{n}} \vdash \lambda x.e : \tau_1 \xrightarrow{\aclrd{m}} \tau_2 }
\end{equation*}
%
The rule (\emph{abs-df}) is admissible in a system that includes the (\emph{abs-min}) rule. 
If we include sub-typing rule (on annotations of functions) and sub-coeffecting rule (on 
annotations of contexts), then the reverse is also true -- because 
$\textit{min}(\aclrd{n}, \aclrd{m}) \leq \aclrd{m}$ and $\textit{min}(\aclrd{n}, \aclrd{m}) \leq \aclrd{n}$.

%---------------------------------------------------------------------------------------------------

\subsection{Flat coeffect algebra}
To make the flat coeffect system general enough, the algebra consists of three operations.
Two of them, $\cseq$ and $\cpar$, represent the \emph{sequential} and \emph{point-wise} composition, 
respectively and the third one, $\czip$ represents context \emph{merging}. The term merging should be 
understood semantically -- the operation models what happens when the semantics of lambda abstraction 
combines context available at the declaration-site and the call-site.

In addition to the three operations, we also require two special values used to annotate
variable access and constant access and a relation that defines the ordering.

\begin{definition}
A \emph{\cclrd{flat coeffect algebra}} $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$ is a set 
$\C$ together with elements $\cunit, \czero \in \C$, relation $\cleq$ and binary operations 
$\cseq, \cpar, \czip$ such that $(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids,
$(\C, \cleq)$ is a pre-order and $(\C, \czip)$ is a band (idempotent semigroup). That is, 
for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}   
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}   
\\
r \;\czip\; (s \;\czip\; t) = (r \;\czip\; s) \;\czip\; t &
r\; \czip\; r = r &
\textnormal{(band)}   
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}   
\end{array}
\end{equation*}
%
In addition, the following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
\end{definition}

\noindent
In two of the three systems, some of the operators of the flat coeffect algebra coincide,
but the data-flow system requires all three. Similarly, the two special elements also 
coincide in some, but not all systems. The required laws are motivated by the aim to capture
common properties of the three examples, without unnecessarily restricting the system:

\begin{itemize}
\item The monoid $(\C, \cseq, \cunit)$ represents \emph{sequential} composition of (semantic)
functions. The laws of a monoid are required in order to form a category structure in the 
categorical model (Section~\ref{sec:flat-semantics}).

\item The monoid $(\C, \cpar, \czero)$ represents \emph{point-wise} composition, \ie~the case when the
same context is passed to multiple (independent) computations. The monoid laws guarantee 
that usual syntactic transformations on tuples and the unit value (Section~\ref{sec:flat-exts})
preserve the coeffect. 

\item For the $\czip$ operation, we require associativity and idempotence. The idempotence
requirement makes it possible to duplicate the coeffects and place the same requirement on both
call-site and declaration-site, \ie~it makes the (\emph{abs-df}) rule admissible. In some cases, 
the operator forms a monoid with the unit being the greatest element of the set. This alternative is 
discussed when we consider recursion (Section~\ref{sec:flat-exts}).
\end{itemize}

It is worth noting that the operators $\cpar$ and $\czip$ are dual in some of the systems. For 
example, in data-flow computations, they are \emph{max} and \emph{min} respectively. However, this
duality does not hold for implicit parameters. Using the syntactic reading, they represent 
\emph{merging} and \emph{splitting} of context requirements -- in the (\emph{abs}) rule, 
$\czip$ appears in the assumption and the combined context requirements of the body are split 
between two positions in the conclusions; in the (\emph{app}) rule, $\cpar$ appears in the 
conclusion and combines two context requirements from the assumptions.

\paragraph{Ordering.}

The flat coeffect algebra requires a pre-order relation $\cleq$, which is used to define 
sub-coeffecting rule of the type system. When the monoid $(\C, \cpar, \czero)$ is idempotent
and commutative monoid (semi-lattice), the $\cleq$ relation can be defined in terms of $\cpar$ as:
%
\begin{equation*}
r \;\cleq\; s \;\Longleftrightarrow\; r \;\cpar\; s \;=\; s
\end{equation*}
%
This definition is consistent with all three examples that motivate flat coeffect calculus, but
it cannot be used with the structural coeffects (where it fails for the bounded reuse 
calculus) and so we choose not to use it.

Furthermore, the $\cunit$ coeffect is often the top (greatest) or the bottom (smallest) 
element of the semi-lattice, but not in general. When this is the case, we are able
to prove certain properties of the calculus (Section~\ref{sec:syntax}).

%---------------------------------------------------------------------------------------------------

\subsection{Understanding flat coeffects}

Before looking at the type system in Figure~\ref{fig:flat-types}, let us clarify how the rules
should be understood. The coeffect calculus provides both analysis of context dependence (type 
system) and semantics for context (how it is propagated). These two aspects provide different
ways of reading the judgements $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ and the typing rules
used to define it.

\begin{itemize}
\item \textbf{Analysis of context dependence.}
Syntactically, coeffect annotations $\cclrd{r}$ model \emph{context requirements}. This means
we can over-approximate them and require more than is actually needed at runtime. 

Syntactically, the typing rules should be read top-down. In (\emph{app}), the context requirements 
of multiple assumptions are \emph{merged}; in (\emph{abs}), they are split between the declaration-site
and the call-site.

\item \textbf{Semantics of context passing.}
Semantically, coeffect annotations $\cclrd{r}$ mo\-del \emph{contextual capabilities}. This means
that we can throw away capabilities, if a sub-expression requires fewer than we 
currently have.

Semantically, the typing rules should be read bottom-up. In application, the capabilities 
provided to the term $e_1~e_2$ are \emph{split} between the two sub-expressions; in abstraction,
the capabilities provided by the call-site and declaration-site are \emph{merged} and passed
to the body.
\end{itemize}

The reason for this asymmetry follows from the fact that the context appears in a \emph{negative
position} in the semantic model (Section~\ref{sec:flat-semantics}). It means that we need to be
careful about using the words \emph{split} and \emph{merge}, because they can be read as meaning
opposite things. To disambiguate, we always use the term \emph{context requirements} when using
the syntactic view and \emph{context capabilities} or just \emph{available context} when using 
the semantic view.

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\tyrule{var}
  {x : \tau \in \Gamma}
  {\coctx{\Gamma}{\cunit} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {c : \tau \in \Delta}
  {\coctx{\Gamma}{\czero} \vdash c : \tau }
\end{equation*}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau }
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }\quad\quad(\cclrd{r'} \cleq \cclrd{r})
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x:\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma, x:\tau_1}{\cclrd{s}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma}{\cclrd{s} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\caption{Type system for the flat coeffect calculus}
\label{fig:flat-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\subsection{Flat coeffect types}
\label{sec:flat-calculus-types}

The type system for flat coeffect calculus is shown in Figure~\ref{fig:flat-types}. Variables 
(\emph{var}) and constants (\emph{const}) are annotated with special values provided by the 
coeffect algebra. Following the top-down syntactic reading, the (\emph{sub}) rule allows us to 
treat an expression with fewer context requirements as an expression with more context requirements. 

The (\emph{abs}) rule is defined as discussed in Section~\ref{sec:flat-calculus-lambda}. The
body is annotated with context requirements $\cclrd{r} \,\czip\, \cclrd{s}$, which are then split
between the context-requirements on the declaration-site $\cclrd{r}$ and context-requirements on
the call-site $\cclrd{s}$. Examples of the $\czip$ operator are discussed in the next section.

In function application (\emph{app}), context requirements of both expressions and the 
function are combined as discussed in Chapter~\ref{ch:applications}. The pointwise composition
$\cpar$ is used to combine the context requirements of the expression representing a function 
$\cclrd{r}$ and the context requirements of the argument, sequentially composed with the 
context-requirements of the function $\cclrd{s}\, \cseq \,\cclrd{t}$.

The type system also includes a rule for let-binding. The rule is \emph{not} equivalent to the
derivation for $(\lambda x.e_2)~e_1$, but it represents one admissible typing derivation. We
return to let-binding after looking a number of examples. Additional constructs such 
as recursion and tuples are covered in Section~\ref{sec:flat-exts}.

%---------------------------------------------------------------------------------------------------

\subsection{Examples of flat coeffects}

The flat coeffect calculus generalizes the flat systems discussed in 
Section~\ref{sec:applications-flat} of the previous chapter. We can instantiate it to a specific
use just by providing a flat coeffect algebra. The following summary defines the systems for implicit 
parameters, liveness and data-flow. For the latter two, we obtain more general (but compatible) rule 
for lambda abstraction.

\begin{example}[Implicit parameters]
Assuming \ident{Id} is a set of implicit parameter names, the flat coeffect algebra 
is formed by $(\mathcal{P}(\ident{Id}), \cup, \cup, \cup, \emptyset, \emptyset, \subseteq)$.
\end{example}

\noindent
For simplicity, we assume that all parameters have the same type $\rho$ and so the annotations only
track sets of names. The definition uses set union for all three operations. Both variables and
constants are are annotated with $\emptyset$ and the ordering is defined by $\subseteq$. The 
definition satisfies the flat coeffect algebra laws because $(S, \cup, \emptyset)$ is an idempotent, 
commutative monoid. The system has a single additional typing rule for accessing the value of a
parameter:
%
\begin{equation*}
\tyrule{param}
  { \ident{?p} \in \cclrd{c} }
  { \coctx{\Gamma}{\cclrd{c}} \vdash \ident{?p} : \rho }
\end{equation*}
%
The rule specifies that the accessed parameter $\ident{?p}$ needs to be in the set of required
parameters $\cclrd{c}$. As discussed earlier, we use the same type $\rho$ for all parameters, but
it is easy to define an extension tracking set of parameters with type annotations.

\begin{example}[Liveness]
Let $L=\{ \ident{L}, \ident{D} \}$ be a two-point lattice such that $\ident{D} \sqsubseteq \ident{L}$
with a join $\sqcup$ and meet $\sqcap$. The flat coeffect algebra for liveness is then formed by
$(L, \sqcap, \sqcup, \sqcap, \ident{L}, \ident{D}, \sqsubseteq)$.
\end{example}

\noindent
As in Section~\ref{sec:applications-flat-live}, sequential composition $\cseq$ is modelled by 
the meet operation $\sqcap$ and point-wise composition $\cpar$ is modelled by join $\sqcup$. 
Two-point lattice is a commutative, idempotent monoid. The distributivity 
$(r \sqcup s) \sqcap t = (r \sqcap t) \sqcup (s \sqcap t)$ does not hold for \emph{every} 
lattice, but it trivially holds for a two-point lattice used here.

The definition uses join $\sqcup$ for the $\czip$ operator that is used by lambda abstraction.
This means that, when the body is live $\ident{L}$, both declaration-site and call-site are 
marked as live $\ident{L}$. When the body is dead $\ident{D}$, the declaration-site and call-site
can be marked as dead $\ident{D}$, or as live $\ident{L}$, which is less precise, but permissible
over-approximation, which could otherwise be achieved via sub-typing.

\begin{example}[Data-flow]
In data-flow, context is annotated with natural numbers and the flat coeffect algebra is formed 
by $(\mathbb{N}, +, \mathit{max}, \mathit{min}, 0, 0, \leq)$.
\end{example}

\noindent
As discussed earlier, sequential composition $\cseq$ is represented by $+$ and point-wise 
composition $\cpar$ uses $\emph{max}$. For data-flow, we need a third separate operator for
lambda abstraction. Annotating the body with $\emph{min}(\cclrd{r}, \cclrd{s})$ ensures that
both call-site and declaration-site annotations are equal or greater than the annotation 
of the body. As with liveness, this allows over-approximation. 

As required by the laws, $(\mathbb{N}, +, 0)$ and $(\mathbb{N}, \mathit{max}, 0)$ form monoids
and $(\mathbb{N}, \mathit{min})$ forms a band. Note that data-flow is our first example where 
$+$ is not idempotent. The distributivity laws require the following to be the case:
$\mathit{max}(r,s) + t = \mathit{max}(r+t, s+t)$, which is easy to see. Finally, a simple 
data-flow language includes an additional rule for $\kvd{prev}$:
%
\begin{equation*}
\tyrule{prev}
  { \coctx{\Gamma}{\cclrd{c}} \vdash e : \tau }
  { \coctx{\Gamma}{\cclrd{c}+1} \vdash \kvd{prev}~e : \tau }
\end{equation*}
%
As a further example that was not covered earlier, it is also possible to combine liveness analysis
and data-flow. In the above calculus, $0$ denotes that we require current value, but no previous
values. However, for constants, we do not even need the current value.

\begin{example}[Optimized data-flow]
In optimized data-flow, context is annotated with natural numbers extended with the $\bot$ element,
that is $\mathbb{N}_{\bot} = \mathbb{N} \cup \{\bot \}$ such that $\forall n \in \mathbb{N}. \bot \leq n$.
The flat coeffect algebra is $(\mathbb{N}_{\bot}, +, \mathit{max}, \mathit{min}, 0, \bot, \leq)$
where $m + n$ is $\bot$ whenever $m=\bot$ or $n=\bot$ and \emph{min}, \emph{max} treat $\bot$ as the
least element.
\end{example}

\noindent
Note that $(\mathbb{N}_{\bot}, +, 0)$ is a monoid for the extended definition of $+$,
$(\mathbb{N}, \emph{max}, \bot)$ is also a monoid and $(\mathbb{N}, \emph{min})$ is a band.
The required distributivity laws also holds for this algebra.

%---------------------------------------------------------------------------------------------------

\subsection{Typing of let binding}

Recall the (\emph{let}) rule in Figure~\ref{fig:flat-types}. It annotates the expression 
$\kvd{let}~x=e_1~\kvd{in}~e_2$ with context requirements $\cclrd{s}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{r})$.
This is a special case of typing of an expression $(\lambda x.e_2)~e_1$, using the idempotence
of $\czip$ as follows:
%
\begin{equation*}
\tyrule{app}
  {\begin{array}{l}
   \vspace{-1.5em}
   \coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1
   \end{array} &
   \tyruler{abs}
       { \coctx{\Gamma, x:\tau_1}{\cclrd{s}} \vdash e_2 : \tau_2 }
       { \coctx{\Gamma}{\cclrd{s}} \vdash \lambda x.e_2 : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 } }
  { \coctx{\Gamma}{\cclrd{s}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{r})} \vdash (\lambda x.e_2)~e_1 : \tau_2 }    
\end{equation*}
%
This design decision is similar to ML value restriction, but it works the other way round. Our
\emph{let} binding is more restrictive rather than more general. The choice is motivated by the 
fact that the typing obtained using the special rule for let-binding is more precise (with respect 
to sub-coeffecting) for all the examples considered in this chapter. Table~\ref{tab:flat-simplelet}
shows how the coeffect annotations are simplified for our examples.

\begin{table}[!h]
\begin{center}
\begin{tabular}{ | l | c | c |}
\hline
& \textbf{\footnotesize Definition\hspace{1em}} & \textbf{\footnotesize Simplified\hspace{1em}} \\ \hline
\hspace{-1em}{\footnotesize Implicit parameters} & $\cclrd{s} \cup (\cclrd{s} \cup \cclrd{r})$ & $\cclrd{s} \cup \cclrd{r}$ \\ \hline
\hspace{-1em}{\footnotesize Liveness} & $\cclrd{s} \sqcap (\cclrd{s} \sqcup \cclrd{r})$ & $\cclrd{s}$ \\ \hline
\hspace{-1em}{\footnotesize Data-flow} & $\mathit{max}(\cclrd{s}, \cclrd{s} + \cclrd{r})$ & $\cclrd{s} + \cclrd{r}$ \\ \hline
\end{tabular}
\end{center}

\vspace{-0.5em}
\caption{Simplified annotation for let binding in sample flat calculi}
\label{tab:flat-simplelet}
\end{table}

\noindent
The simplified annotations directly follow from the definitions of particular flat coeffect 
algebras. It is perhaps somewhat unexpected that the annotation can be simplified in different
ways for different examples. 

To see that the simplified annotations are \emph{better}, assume that we used arbitrary 
splitting $\cclrd{s} = \cclrd{s_1}\,\czip\,\cclrd{s_2}$ rather than idempotence. The
``Definition'' column would use $\cclrd{s_1}$ and $\cclrd{s_2}$ for the first and second 
$\cclrd{s}$, respectively. The corresponding simplified annotation (using idempotence) would
have $\cclrd{s_1}\,\czip\,\cclrd{s_2}$ instead of $\cclrd{s}$. For all our systems, the 
simplified annotation (on the right) is more precise than the original (on the left):
%
\begin{equation*}
\begin{array}{rclll}
\cclrd{s_1} \cup (\cclrd{s_2} \cup \cclrd{r}) &\supseteq& (\cclrd{s_1} \cup \cclrd{s_2}) \cup \cclrd{r} 
  && \textnormal{(implicit parameters)}\\
\cclrd{s_1} \sqcap (\cclrd{s_2} \sqcup \cclrd{r}) &\sqsupseteq&  (\cclrd{s_1} \sqcap \cclrd{s_2}) 
  && \textnormal{(liveness)} \\
\mathit{max}(\cclrd{s_1}, \cclrd{s_2} + \cclrd{r}) &\geq& \mathit{min}(\cclrd{s_1}, \cclrd{s_2}) + \cclrd{r} 
  &\quad& \textnormal{(data-flow)} \\
\end{array}
\end{equation*}
%
The inequality cannot be proved from other properties of the flat coeffect algebra. To make
the flat coeffect system as general as possible, we do not \emph{in general} require it as
an additional axiom, although the above examples provide reasonable basis for requiring 
that the specialized annotation for let binding is the least possible annotation for the 
expression $(\lambda x.e_2)~e_1$.

% ==================================================================================================

\section{Categorical motivation}
\label{sec:flat-semantics}

The type system of flat coeffect calculus arises as a generalization of the examples discussed in 
Chapter~\ref{ch:applications}, but we can also obtain it by looking at the categorical semantics
of context-dependent computations. This is a direction that we explore in this section. Although
the development presented here is interesting in its own, our main focus is \emph{using} categorical
semantics to motivate and explain the design of flat coeffect calculus.

% --------------------------------------------------------------------------------------------------

\subsection{Categorical semantics}

As discussed in Section~\ref{sec:path-sem}, categorical semantics interprets terms as morphisms
in some category. For typed calculi, the semantics defined by $\sem{-}$ usually interprets typing 
judgements $x_1 \!:\! \tau_1 \ldots x_n \!:\! \tau_n \vdash e: \tau$ as morphisms 
$\sem{\tau_1 \times \ldots \times \tau_n} \rightarrow \sem{\tau}$.

As a best known example, Moggi \cite{monad-notions} showed that the semantics of various effectful 
computations can be captured uniformly using the (\emph{strong}) \emph{monad} structure. In that 
approach, computations are interpreted as $\tau_1 \times \ldots \times \tau_n \rightarrow \mtyp{}{\tau}$
for some monad $\mtyp{}{}$. For example, $\mtyp{}{\alpha} = \alpha \cup \{ \bot \}$ models 
partiality (maybe monad), $\mtyp{}{\alpha} = \mathcal{P}(\alpha)$ models non-determinism (list 
monad) and $\mtyp{}{\alpha} = (\alpha \times S)^S$ models side-effects (state monad). Here, the 
structure of a strong monad provides necessary ``plumbing'' for composing monadic computations.

Following similar approach to Moggi, Uustalu and Vene \cite{comonads-notions} showed that 
(\emph{monoidal}) \emph{comonads} uniformly capture the semantics of various kinds of context-dependent 
computations~\cite{comonads-notions}. For example, data-flow computations over non-empty lists
$\ident{NEList}\,\alpha = \alpha + (\alpha \times \ident{NEList}\,\alpha)$ are modelled using
the non-empty list comonad.

The monadic and comonadic model outlined here represents at most a binary analysis of effects or 
context-dependence. A function $\tau_1 \rightarrow \tau_2$ performs \emph{no} effects (requires no 
context) whereas $\tau_1 \rightarrow \mtyp{}{\tau_2}$ performs \emph{some} effects and
$\ctyp{}{\tau_1} \rightarrow \tau_2$ requires \emph{some} context. In the next section, we introduce
\emph{indexed comonads}, which provide a more precise analysis and let us model computations with
context requirements $\cclrd{r}$ as functions $\ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2$ using
an \emph{indexed comonad} $\ctyp{\cclrd{r}}{}$.

% --------------------------------------------------------------------------------------------------

\subsection{Introducing comonads}

In category theory, \emph{comonad} is a dual of \emph{monad}. Informally, we get a comonad by 
taking a monad and ``reversing the arrows''. More formally, one of the equivalent definitions of
comonad looks as follows:

\begin{definition}
A \emph{comonad} over a category $\catc$ is a triple $(C, \ident{counit}, \ident{cobind})$ where:
\begin{compactitem}
\item $C$ is a mapping on objects (types) $C : \catc \rightarrow \catc$
\item $\ident{counit}$ is a mapping $\ctyp{}{\alpha} \rightarrow \alpha$ 
\item $\ident{cobind}$ is a mapping $(\ctyp{}{\alpha} \rightarrow \beta) 
  \rightarrow (\ctyp{}{\alpha} \rightarrow \ctyp{}{\beta})$
\end{compactitem}
such that, for all $f:\ctyp{}{\alpha} \rightarrow \beta$ and $g:\ctyp{}{\beta} \rightarrow \gamma$:
\begin{align}
\tag{\emph{left identity}}
  \ident{cobind}~\ident{counit} &= \idf{}
  \\
\tag{\emph{right identity}}
  \ident{counit} \circ \ident{cobind}~f &= f
  \\
\tag{\emph{associativity}}
  \ident{cobind}~(g \circ \ident{cobind}~f) &= (\ident{cobind}~g) \circ (\ident{cobind}~f)
\end{align}
\end{definition}

\noindent
From the functional programming perspective, we can see $\ctyp{}{}$ as a parametric data type such as
\ident{NEList}. The $\ident{counit}$ operations extracts a value $\alpha$ from a value that carries 
additional context $\ctyp{}{\alpha}$. The $\ident{cobind}$ operation turns a context-dependent function 
$\ctyp{}{\alpha} \rightarrow \beta$ into a function that takes a value with context, applies
the context-dependent function to value(s) in the context and then propagates the context.

As mentioned earlier, Uustalu and Vene \cite{comonads-notions} use comonads to model data-flow
computations. They describe infinite (coinductive) streams and non-empty lists as example comonads.

\begin{example}[Non-empty list]
A non-empty list is a recursive data-type defined as $\ident{NEList}\,\alpha = \alpha + (\alpha \times \ident{NEList}\,\alpha)$.
We write \kvd{inl} and \kvd{inr} for constructors of the left and right cases, respectively. The 
type \ident{NEList} forms a comonad together with the following \ident{counit} and \ident{cobind} mappings:
%
\begin{equation*}
\begin{array}{rclll}
\ident{counit}~l &\narrow{=}& h &\quad&\textnormal{when}~l=\kvd{inl}~h\\[-0.25em]
\ident{counit}~l &\narrow{=}& h &&\textnormal{when}~l=\kvd{inr}~(h, t)\\[0.5em]
\ident{cobind}\,f~l &\narrow{=}& \kvd{inl}~(f\,l) &&\textnormal{when}~l=\kvd{inl}~h\\[-0.25em]
\ident{cobind}\,f~l &\narrow{=}& \kvd{inr}~(f\,l,\;\ident{cobind}~f~t) &&\textnormal{when}~l=\kvd{inr}~(h, t)
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{counit} operation returns the head of the non-empty list. Note that it is crucial that
the list is \emph{non-empty}, because we always need to be able to obtain a value. The \ident{cobind}
defined here returns a list of the same length as the original where, for each element, the 
function $f$ is applied on a \emph{suffix} list starting from the element. Using a simplified
notation for list, the result of applying \ident{cobind} to a function that sums elements of a
list gives the following behaviour:
%
\begin{equation*}
\ident{cobind}~\ident{sum}~(7,6,5,4,3,2,1,0) = (28,21,15,10,6,3,1,0)
\end{equation*}
%
The fact that the function $f$ is applied to a \emph{suffix} is important in order to satisfy the
\emph{left identity} law, which requires that $\ident{cobind}~\ident{counit}~l = l$.

It is also interesting to examine some data types that do \emph{not} form a comonad. As already
mentioned, list $\ident{List}~\alpha = 1 + (\alpha \times \ident{List}~\alpha)$ is not a comonad,
because the \ident{counit} operation is not defined for the value $\kvd{inl}~()$. Similarly,
the \ident{Maybe} data type defined as $1 + \alpha$ is not a comonad for the same reason.
However, if we consider flat coeffect calculus for liveness, it appears natural to model computations
as function $\ident{Maybe}~\tau_1 \rightarrow \tau_2$. To use such model, we first need to 
generalise comonads to \emph{indexed comonads}.

% --------------------------------------------------------------------------------------------------

\subsection{Generalising to indexed comonads}
\label{sec:flat-semantics-idx}

The flat coeffect algebra includes a monoid $(\C, \cseq, \cunit)$, which defines the behaviour of
sequential composition, where the annotation $\cunit$ represents a variable access. An indexed 
comonad is formed by a data type (object mapping) $\ctyp{\cclrd{r}}{\alpha}$ where the annotation 
$\cclrd{r}$ determines what context is required. 

\begin{definition}
Given a monoid $(\C, \cseq, \cunit)$ with binary operator $\cseq$ and unit $\cunit$, an 
\emph{indexed comonad} over a category $\catc$ is a triple 
$(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, \ident{cobind}_{\cclrd{r}, \cclrd{s}})$ where:

\begin{compactitem}
\item $\ctyp{\cclrd{r}}{}$ for all $\cclrd{r} \in \C$ is a family of object mappings 
\item $\ident{counit}_{\cunit}$ is a mapping $\ctyp{\cunit}{\alpha} \rightarrow \alpha$ 
\item $\ident{cobind}_{\cclrd{r}, \cclrd{s}}$ is a mapping $(\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) 
  \rightarrow (\ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta})$
\end{compactitem}
such that, for all $f:\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta$ and $g:\ctyp{\cclrd{s}}{\beta} \rightarrow \gamma$
and the identity $\idf{\cclrd{s}} : \ctyp{\cclrd{s}}\alpha \rightarrow \ctyp{\cclrd{s}}\alpha$:
\begin{align}
\tag{\emph{left identity}}
  \ident{cobind}_{\cunit, \cclrd{s}}~\ident{counit}_{\cunit} &= \idf{}
  \\
\tag{\emph{right identity}}
  \ident{counit}_{\cunit} \circ \ident{cobind}_{\cclrd{r}, \cunit}~f &= f
  \\
\tag{\emph{associativity}}
\hspace{-10em}
  \ident{cobind}_{\cclrd{r}\cseq\cclrd{s},\cclrd{t}}~(g \circ \ident{cobind}_{\cclrd{r}, \cclrd{s}}~f) &= 
    (\ident{cobind}_{\cclrd{s}, \cclrd{t}}~g) \circ (\ident{cobind}_{\cclrd{r}, \cclrd{s}\cseq\cclrd{t}}~f)
\end{align}
\end{definition}

\noindent
Rather than defining a single mapping $\ctyp{}{}$, we are now defining a family of mappings 
$\ctyp{\cclrd{r}}{}$ indexed by a monoid structure. Similarly, the operation $\ident{cobind}_{\cclrd{r}, \cclrd{s}}$ 
operation is now also formed by a \emph{family} of mappings for different pairs of indices 
$\cclrd{r}, \cclrd{s}$. To be fully precise, $\ident{cobind}$ is a family of natural transformations 
and we should include $\alpha, \beta$ as indices, writing $\ident{cobind}_{\cclrd{r},\cclrd{s}}^{\alpha, \beta}$.
For the purpose of this thesis, it is sufficient to treat $\ident{cobind}$ as a family of
mappings or, when it does not  introduce ambiguity, view it as a single mapping.

The $\ident{counit}$ operation is not defined for all $\cclrd{r} \in \C$, but only for 
the unit $\cunit$. We still include the unit as an index writing $\ident{counit}_{\cunit}$, 
but this is merely for symmetry. Crucially, this means that the operation is defined only
for some special contexts.

If we look at the indices in the laws, we can see that the left and right identity 
require $\cunit$ to be the unit of $\cseq$. Similarly, the associativity law implies the 
associativity of the $\cseq$ operator. 

The category that models sequential composition is formed by the unit arrow $\ident{counit}$ 
together with the (associative) composition operation that composes computations with 
contextual requirements as follows:
%
\begin{equation*}
\begin{array}{ccl}
\textnormal{--}\, \hat{\circ} \,\textnormal{--}&\narrow{:}& (\ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2) 
  \rightarrow (\ctyp{\cclrd{s}}{\tau_2} \rightarrow \tau_3) 
  \rightarrow (\ctyp{\cclrd{r} \cseq \cclrd{s}}{\tau_1} \rightarrow \tau_3) \\
g \, \hat{\circ} \, f &\narrow{=}& g \circ (\ident{cobind}_{\cclrd{r}, \cclrd{s}} f)
\end{array}
\end{equation*}
%
The composition $\hat{\circ}$ best expresses the intention of indexed comonads. Given two functions
with contextual requirements $\cclrd{r}$ and $\cclrd{s}$, their composition is a function that 
requires $\cclrd{r}\,\cseq,\cclrd{s}$. The contextual requirements propagate \emph{backwards} and
are attached to the input of the composed function.

% --------------------------------------------------------------------------------------------------

\paragraph{Examples.}

Any comonad can be turned into an indexed comonad using a trivial monoid. However, indexed comonads
are more general and can be used with other data types, including indexed \ident{Maybe}. 

\begin{example}[Comonads]
Any comonad $\ctyp{}{}$ is an indexed comonad with an index provided by a trivial monoid $(\{1\},\ast,1)$
where $1\ast 1 = 1$ and $\ctyp{1}{}$ is the underlying mapping $\ctyp{}{}$ of the original comonad. The
operations $\ident{counit}_1$ and $\ident{cobind}_{1,1}$ are defined by the operations $\ident{counit}$
and $\ident{cobind}$ of the comonad.
\end{example}

\begin{example}[Indexed option]
The indexed option comonad is defined over a monoid $(\{ \ident{L},\ident{D} \}, \sqcup,\ident{L})$ 
where $\sqcup$ is defined as earlier, \ie~$\ident{L} = \cclrd{r} \sqcup \cclrd{s} \Longleftrightarrow \cclrd{r}=\cclrd{s}=\ident{L}$.
Assuming $1$ is the unit type inhabited by $()$, the mappings are defined as follows:
%
\begin{equation*}
\begin{array}{l}
\ctyp{\ident{L}}{\alpha} = \alpha\\
\ctyp{\ident{D}}{\alpha} = 1\\
\\
\ident{counit}_{\ident{L}} : \ctyp{\ident{L}}{\alpha} \rightarrow \alpha \\
\ident{counit}_{\ident{L}}~v = v\\
\end{array}
\qquad
\begin{array}{lcl}
\multicolumn{3}{l}{
  \ident{cobind}_{\cclrd{r},\cclrd{s}} ~:~ (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) 
    \rightarrow (\ctyp{\cclrd{r}\sqcup\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}) }\\
\ident{cobind}_{\ident{L},\ident{L}}~f~x &\narrow{=}& f~x\\
\ident{cobind}_{\ident{L},\ident{D}}~f~() &\narrow{=}& ()\\
\ident{cobind}_{\ident{D},\ident{L}}~f~() &\narrow{=}& f~()\\
\ident{cobind}_{\ident{D},\ident{D}}~f~() &\narrow{=}& ()\\
\end{array}
\end{equation*}
\end{example}

\noindent
The indexed option comonad models the semantics of the liveness coeffect system discussed in 
\ref{sec:applications-flat-live}, where $\ctyp{\ident{L}}{\alpha} = \alpha$ models a live context 
and $\ctyp{\ident{D}}{\alpha}=1$ models a dead context which does not contain a value. The \ident{counit}
operation extracts a value from a live context; \ident{cobind} can be seen as an implementation of 
dead code elimination. The definition only evaluates $f$ when the result is marked as live and is thus
required, and it only accesses $x$ if the function $f$ requires its input.

The indexed family $\ctyp{\cclrd{r}}{}$ in the above example is analogous to the \ident{Maybe}
(or option) data type $\ident{Maybe}\,\alpha = 1 + \alpha$. As mentioned earlier, this type does not 
permit (non-indexed) comonad structure, because $\ident{counit}~()$ is not defined. This is not a 
problem with indexed comonads, because \ident{counit} only needs to be defined on live context.

\begin{example}[Indexed product]
The semantics of implicit parameters is modelled by an indexed product comonad. We use a monoid
$(\mathcal{P}(\ident{Id}), \cup, \emptyset)$ where \ident{Id} is the set of (implicit parameter) names.
As previously, all parameters have the type $\rho$. The data type $\ctyp{\cclrd{r}}{\alpha}
= \alpha \times (\cclrd{r} \rightarrow R)$ represents a value $\alpha$ together with a function that
associates a parameter value $\rho$ with every implicit parameter name in $\cclrd{r} \subseteq \ident{Id}$.
The cobind and counit operations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{\emptyset} : \ctyp{\emptyset}{\alpha} \rightarrow \alpha \\[-0.25em]
\ident{counit}_{\emptyset}~(a, g) = a\\[0.5em]
\end{array}
\quad
\begin{array}{l}
\ident{cobind}_{\cclrd{r},\cclrd{s}} ~:~ (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) 
    \rightarrow (\ctyp{\cclrd{r}\cup\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta})\\[-0.25em]
\ident{cobind}_{\cclrd{r},\cclrd{s}}~f~(a,g) = (f(a,\restr{g}{\cclrd{r}}), \restr{g}{\cclrd{s}})\\[0.5em]
\end{array}
\end{equation*}
\end{example}

\noindent
The definition of \ident{counit} simply ignores the function and returns the value in the context.
The \ident{cobind} operation uses the restriction operation $\restr{f}{\cclrd{r}}$, which we 
already defined when discussing semantics of implicit parameters in Section~\ref{sec:applications-flat-impl}
(indeed, \ident{cobind} here captures an essential part of the semantics).

The function $g$ in \ident{cobind} is defined on the union of the implicit parameters, 
\ie~$\cclrd{r}\cup\cclrd{s}\rightarrow\rho$. When passing it to $f$, we restrict it to
just $\cclrd{r}$ and when returning it as a result, we restrict it to $\cclrd{s}$.

% --------------------------------------------------------------------------------------------------

\subsection{Properties and related notions}

We discuss additional examples in Section~\ref{sec:flat-semantics-monoidal}, after we look at the
remaining structure that is needed to define the semantics of flat coeffect calculus. Before doing 
so, we discuss additional properties and categorical structures that have been proposed mainly in 
the context of monads and effects and are related to indexed comonads.

\paragraph{Shape preservation.}
Ordinary comonads have the \emph{shape preservation} property \cite{comonads-codo}. Intuitively, 
this means that the shape of the additional context does not change during the computation. For
example, in the \ident{NEList} comonad, the length of the list stays the same after applying 
\ident{cobind}.

Indexed comonads are not restricted by this property of comonads. For example, given the indexed
product monad, in the computation $\ident{cobind}_{\cclrd{r}, \cclrd{s}} f$ above, the shape of
the context changes from containing implicit parameters $\cclrd{r} \cup \cclrd{s}$  to containing
just implicit parameters $\cclrd{s}$.

\paragraph{Families of monads.}
When linking effect systems and monads, Wadler and Thiemann \cite{monad-notions} propose a
\emph{family of monads} as the categorical structure. The dual structure, \emph{family of
comonads}, is defined as follows.

\begin{definition}
\label{def:flat-family}
A \emph{family of comonads} is formed by triples $(\ctyp{\cclrd{r}}{}, \ident{cobind}_{\cclrd{r}}, 
  \ident{counit}_{\cclrd{r}})$ for all $\cclrd{r}$ such that each triple forms a comonad. Given 
$\cclrd{r}, \cclrd{r'}$ such that $\cclrd{r} \leq \cclrd{r'}$, there is also a mapping 
$\iota_{\cclrd{r'}, \cclrd{r}} : \ctyp{\cclrd{r'}}{} \rightarrow \ctyp{\cclrd{r}}{}$ satisfying
certain coherence conditions.
\end{definition}

Family of comonads is more restrictive than indexed comonad, because each of the data types needs
to form a comonad separately. For example, our indexed option does not form a family of comonads
(again, because \ident{counit} is not defined on $\ctyp{\ident{D}}{\alpha}=1$). However, given a 
family of comonads and indices such that $\cclrd{r} \leq \cclrd{r}\cseq\cclrd{s}$, we can define 
an indexed comonad. Briefly, to define $\ident{cobind}_{\cclrd{r},\cclrd{s}}$ of an indexed comonad, 
we use $\ident{cobind}_{\cclrd{r}\cseq\cclrd{s}}$ from the family, together with two lifting operations:
$\iota_{\cclrd{r}\cseq\cclrd{s}, \cclrd{r}}$ and $\iota_{\cclrd{r}\cseq\cclrd{s}, \cclrd{s}}$.

\paragraph{Parameteric effect monads.}
Parametric effect monads introduced by Katsumata \cite{monads-parametric} (independently to our 
indexed comonads) are closely related to our definition.  Although presented in a more general 
categorical framework (and using monads), the model defines \ident{unit} operation only on the 
unit of a monoid and \ident{bind} operation composes effect annotations using the provided monoidal 
structure.


% --------------------------------------------------------------------------------------------------

\subsection{Flat indexed comonads}
\label{sec:flat-semantics-monoidal}

Indexed comonads model the semantics of sequential composition, but additional structure is needed
to model the semantics of the flat coeffect calculus. This is where the duality between monads and 
comonads can no longer help us, because context is propagated differently than effects in lambda 
abstraction and application.

Whereas Moggi~\cite{monad-notions} requires \emph{strong} monad to model effectful $\lambda$-calculus, 
Uustalu and Vene~\cite{comonads-notions} require \emph{lax semi-monoidal} comonad to model 
$\lambda$-calculus with contextual properties. The structure requires a monoidal operation:
%
\begin{equation*}
\ident{m} : \ctyp{}{\alpha} \times \ctyp{}{\beta} \rightarrow \ctyp{}{(\alpha \times \beta)}
\end{equation*}
%
The \ident{m} operation is needed in the semantics of lambda abstraction. It represents merging of 
contexts and is used to merge the context of the declaration-site (containing free variables)
and the call-site (containing bound variable). For example, for implicit parameters, this combines
the additional parameters defined in the two contexts.

The semantics of flat coeffect calculus requires operations for \emph{merging}, but also for
\emph{splitting} of contexts. These are provided by \emph{lax} and \emph{oplax} monoidal 
structures. In addition, we also need a lifting operation (similar to $\iota$ from 
Definition~\ref{def:flat-family}) to model sub-coeffecting.

\begin{definition}
Given a flat coeffect algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$,
an \emph{flat indexed comonad} is an indexed comonad over the monoid $(\C, \cseq, \cunit)$
equipped with families of operations $\ident{merge}_{\cclrd{r},\cclrd{s}}$, $\ident{split}_{\cclrd{r},\cclrd{s}}$ 
and $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ where:
%
\begin{compactitem}
\item $\ident{merge}_{\cclrd{r},\cclrd{s}}$ is a family of mappings
  $\ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta} \rightarrow \ctyp{\cclrd{r}\czip\cclrd{s}}{(\alpha \times \beta)}$
\item $\ident{split}_{\cclrd{r},\cclrd{s}}$ is a family of mappings
  $\ctyp{\cclrd{r}\cpar\cclrd{s}}{(\alpha \times \beta)} \rightarrow \ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta}$
\item $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ is a family of mappings
  $\ctyp{\cclrd{r'}}{\alpha} \rightarrow \ctyp{\cclrd{r}}{\alpha}$~ for all $\cclrd{r'}, \cclrd{r}$ such that $\cclrd{r}\,\cleq\,\cclrd{r'}$
\end{compactitem}
%
% We should require lift to be comonad morphism
%
% \tag{\emph{comonad morphism}}
%   \ident{cobind}_{\cclrd{r}, \cclrd{s}}~f \circ \ident{lift}_{\cclrd{r'}\cseq\cclrd{s'}, \cclrd{r}\cseq\cclrd{s}} &=
%   \ident{lift}_{\cclrd{s'}, \cclrd{s}} \circ \ident{cobind}_{\cclrd{r'}, \cclrd{s'}}~(f \circ \ident{lift}_{\cclrd{r'}, \cclrd{r}} )
%
% ... but adapting the coherence conditions for counit/cobind is ugly!
%
\end{definition}

\noindent
The $\ident{merge}_{\cclrd{r},\cclrd{s}}$ operation is the most interesting one. Given two comonadic
values with additional contexts specified by $\cclrd{r}$ and $\cclrd{s}$, it combineds them into a 
single value with additional context $\cclrd{r}\czip\cclrd{s}$. The $\czip$ operation often represents
\emph{greatest lower bound}\footnote{The $\czip$ and $\cpar$ operations are the greatest and least upper 
bounds for the liveness and data-flow examples, but not for implicit parameters. However, they are useful 
as an informal analogy.}, elucidating the fact that merging may result in the loss of some parts of 
the contexts $\cclrd{r}$ and $\cclrd{s}$. We look at examples of this operation in the next section.

The $\ident{split}_{\cclrd{r},\cclrd{s}}$ operation splits a single comonadic value (containing a tuple)
into two separate values. Note that this does not simply duplicate the value, because the additional
context is also split. To obtain coeffects $\cclrd{r}$ and $\cclrd{s}$, the input needs to provide 
\emph{at least} $\cclrd{r}$ and $\cclrd{s}$, so the tags are combined using the $\cpar$, which is often 
the \emph{least upper-bound}\footnotemark[1].

Finally, $\ident{lift}_{\cclrd{r'}, \cclrd{r}}$ is a family of operations that ``forget'' some part of
a context. This models the sub-coeffecting operation and lets us, for example, forget some of the
available implicit parameters, or turn a live context (containing a value) into a dead context (empty).

\paragraph{Alternative definition.}
Although we do not require this as a general law, in all our systems, it is the case that
$\cclrd{r} \;\cleq\; \cclrd{r}\,\cpar\,\cclrd{s}$ and $\cclrd{s} \;\cleq\; \cclrd{r}\,\cpar\,\cclrd{s}$.
This allows a simpler definition of \emph{indexed flat comonad} by expressing the \ident{split} operation
in terms of the lifting (sub-coeffecting) as follows:
%
\begin{equation*}
\begin{array}{rcl}
\ident{map}_{\cclrd{r}}~f &\narrow{=}& \ident{cobind}_{\cclrd{r}, \cclrd{r}}~(f\circ\ident{counit}_{\cunit}) \\
\ident{split}_{\cclrd{r}, \cclrd{s}}~c &\narrow{=}&
  ( \ident{map}_{\cclrd{r}}~\ident{fst}~(\ident{lift}_{\cclrd{r}\cpar\cclrd{s}, \cclrd{r}}~c), 
    \ident{map}_{\cclrd{s}}~\ident{snd}~(\ident{lift}_{\cclrd{r}\cpar\cclrd{s}, \cclrd{s}}~c) )
\end{array}
\end{equation*}
%
The $\ident{map}_{\cclrd{r}}$ operation is the mapping on functions that corresponds to the object 
mapping $\ctyp{\cclrd{r}}{}$. The definition is dual to the standard definition of \ident{map} 
for monads in terms of \ident{bind} and \ident{unit}. The functions \ident{fst} and \ident{snd}
are first and second projections from a two-element pair. To define the 
$\ident{split}_{\cclrd{r}, \cclrd{s}}$ operation, we duplicate the argument $c$, then use 
lifting to throw away additional parts of the context and then transform the values in the 
context.

This alternative is valid for our examples, but we do not use it for two reasons. Firstly, it 
requires duplication of the value $c$, which is not required elsewhere in our model. So, using 
explicit \ident{split}, our model could be embedded in a linear or affine model. Secondly, it
is similar to the definition that is needed for structural coeffects in Chapter~\ref{ch:structural}
and so it makes the connection between the two system easier to see.

\paragraph{Examples.}
All examples of \emph{indexed comonads} discussed in Section~\ref{sec:flat-semantics-idx} can
be extended into \emph{flat indexed comonads}. 

\begin{example}[Monoidal comonads]
Just like indexed comonads generalise co\-monads, the additional structure of
flat indexed comonads generalises symmetric semimonoidal comonads of Uustalu 
and Vene \cite{comonads-notions}. The flat coeffect algebra is defined as $(\{1\}, \ast, \ast, \ast, 1, 1, =)$
where $1\ast1=1$ and $1=1$. The additional operation $\ident{merge}_{1,1}$ is provided by the 
monoidal operation called \ident{m} by Uustalu and Vene. The $\ident{split}_{1,1}$ operation 
is defined by duplication and $\ident{lift}_{1,1}$ is the identity function.
\end{example}

\begin{example}[Indexed option]
Flat coeffect algebra for liveness defines $\cpar$ and $\czip$ as $\sqcup$ and $\sqcap$, respectively 
and specifies that $\ident{D} \sqsubseteq \ident{L}$. Recall also that the object mapping is defined 
as $\ctyp{\ident{L}}{\alpha} = \alpha$ and $\ctyp{\ident{D}}{\alpha} = 1$. The additional operations 
of a flat indexed comonad are defined as follows:
%
\begin{equation*}
\begin{array}{rcl}
\ident{merge}_{\ident{L}, \ident{L}}~(a, b) &\narrow{=}& (a, b)\\
\ident{merge}_{\ident{L}, \ident{D}}~(a, ()) &\narrow{=}& ()\\
\ident{merge}_{\ident{D}, \ident{L}}~((), b) &\narrow{=}& ()\\
\ident{merge}_{\ident{D}, \ident{D}}~((), ()) &\narrow{=}& ()\\
\end{array}
\quad
\begin{array}{rcl}
\ident{split}_{\ident{L}, \ident{L}}~(a, b) &\narrow{=}& (a, b)\\
\ident{split}_{\ident{L}, \ident{D}}~(a, b) &\narrow{=}& (a, ())\\
\ident{split}_{\ident{D}, \ident{L}}~(a, b) &\narrow{=}& ((), b)\\
\ident{split}_{\ident{D}, \ident{D}}~() &\narrow{=}& (a, b)\\
\end{array}
\quad
\begin{array}{rcl}
\ident{lift}_{\ident{L}, \ident{D}}~v &\narrow{=}& ()\\
\ident{lift}_{\ident{L}, \ident{L}}~v &\narrow{=}& v\\
\ident{lift}_{\ident{D}, \ident{D}}~() &\narrow{=}& ()\\
\end{array}
\end{equation*}
\end{example}

\noindent
Without the indexing, the \ident{merge} operations implements \emph{zip} on option values,
returning an option only when both values are present. The behaviour of the \ident{split} 
operation is partly determined by the indices. When the input is \emph{dead}, both values have 
to be dead (this is also the only solution of $\ident{D}=\cclrd{r}\sqcap\cclrd{D}$), but when
the input is \emph{live}, the operation can perform implicit sub-coeffecting and drop one of
the values.

Explicit sub-coeffecting using the (\emph{sub}) rule is modelled by the \ident{lift} operation.
This can turn a \emph{live} value $v$ into a dead value $()$, or it can behave as identity.
The behaviour is, again, determined by the index.

\begin{example}[Indexed product]
For implicit parameters, both $\czip$ and $\cpar$ are the $\cup$ operation and the relation
$\cleq$ is formed by the subset relation $\subseteq$. Recall that the data type $\ctyp{\cclrd{r}}{\alpha}$
is $\alpha \times (\cclrd{r} \rightarrow R)$ where $R$ is some representation of a parameter value.
The additional operations are defined as:
%
\begin{equation*}
\begin{array}{rcl}
\ident{split}_{\cclrd{r}, \cclrd{s}}~((a,b), g) &\narrow{=}& ((a, \restr{g}{\cclrd{r}}), (b, \restr{g}{\cclrd{s}}))\\
\ident{merge}_{\cclrd{r}, \cclrd{s}}~((a, f), (b, g)) &\narrow{=}& ((a, b), f \uplus g)\\
\ident{lift}_{\cclrd{r'}, \cclrd{r}}~(a, g) &\narrow{=}& (a, \restr{g}{\cclrd{r}})\\
\end{array}
\quad
\begin{array}{l}
\textnormal{where}~f \uplus g = \\[-0.25em]
\quad\restr{f}{\, \textit{dom}(f) \setminus \textit{dom}(g)} \cup g 
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{split} operation splits the tuple and restricts the function (representing available
implicit parameters) to the required sub-sets. This corresponds to the definition in terms
of \ident{lift}, which performs just the restriction. The \ident{merge} operation is more 
interesting. It uses $\uplus$ operation that we defined when introducing implicit parameters
in Section~\ref{sec:applications-flat-impl}. It merges the values, preferring the definitions from
the right-hand side (call-site) over left-hand side (declaration-site). Thus the operation is not
symmetric.

\begin{example}[Indexed list]
Our last example provides the semantics of data-flow computations. The flat coeffect algebra 
is formed by $(\mathbb{N}, +, \mathit{max}, \mathit{min}, 0, 0, \leq)$. In a 
non-indexed version, the semantics is provided by a non-empty list. In the indexed semantics,
the index represents the length of the storing past values. The data type is then a pair of 
the current value, followed by $n$ past values. The mappings that form the flat indexed comonad 
are defined as follows:

\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}\langle a_0 \rangle = a_0
\\[0.45em]
\ident{cobind}_{m, n}~f \langle a_0, \ldots a_{m+n} \rangle = \\[-0.25em]
\quad \langle f \langle a_0, \ldots, a_m \rangle, \ldots \langle a_{n}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{merge}_{m, n} (\langle a_0, \ldots, a_m \rangle, \langle b_0, \ldots, b_n\rangle) = \\[-0.25em]
\quad \langle (a_0, b_0), \ldots, (a_{\mathit{min}(m,n)}, b_{\mathit{min}(m,n)}) \rangle
\\[0.45em]
\ident{split}_{m, n} \langle (a_0, b_0), \ldots, (a_{\mathit{max}(m,n)}, b_{\mathit{max}(m,n)}) \rangle = \\[-0.25em]
\quad (\langle a_0, \ldots, a_m \rangle, \langle b_0, \ldots, b_n\rangle)
\\[0.45em]
\ident{lift}_{n', n} \langle a_0, \ldots, a_n' \rangle = \qquad(\hspace{-0.95em}\textnormal{\footnotesize when}~n\leq n') \\[-0.25em]
\quad \langle a_0, \ldots, a_n \rangle
\end{array}
\begin{array}{l}
\hspace{-2em}\ctyp{n}{\alpha} = \underbrace{\alpha \times \ldots \times \alpha}_{(n+1)-\textnormal{times}}\\[11em]
~\\
\end{array}
\end{equation*}
\end{example}

\noindent
The reader is invited to check that the number of required past elements in each of the mappings
matches the number specified by the indices. The index specifies the number of \emph{past} elements
and so the list always contains at least one value. Thus \ident{counit} returns the element of a
singleton list.

The $\ident{cobind}_{m,n}$ operation requires $m + n$ elements in order to generate $n$ past results 
of the $f$ function, which itself requires $m$ past values. When combining two lists, 
$\ident{merge}_{m,n}$ behaves as \emph{zip} and produces a list that has the length of the shorter 
argument. When splitting a list, $\ident{split}_{m, n}$ needs the maximum of the required lengths. 
Finally, the lifting operation just drops some number of elements from a list.

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of flat calculus}

In Section~\ref{sec:applications-flat}, we defined the semantics of concrete (flat) context-dependent
computations including implicit parameters, liveness and data-flow. Using the \emph{flat indexed 
comonad} structure, we can now define a single uniform semantics that is capable capturing of all 
our examples, as well as other computations that can be modelled by the structure.

\paragraph{Contexts and functions.}
The modelling of contexts and functions generalizes the earlier concrete examples. We use the 
family of mappings $\ctyp{\cclrd{r}}{}$ as an (indexed) data-type that wraps the product of 
free variables of the context and the arguments of functions:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{ \cclrd{r} } \vdash e : \tau} 
  &:& \ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau\\
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} &=& \ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2
\end{array}
\end{equation*}

% --------------------------------------------------------------------------------------------------

\newcommand{\ctx}{\textit{ctx}}
\begin{figure*}[t]

\begin{equation*}
\begin{array}{ll}
\sem{\coctx{\Gamma}{\cunit} \vdash x_i : \tau_i }~\ctx =
  \pi_i~(\ident{counit}_{\cunit}~\ctx) & (\emph{var})
\\[0.5em]
\sem{\coctx{\Gamma}{\czero} \vdash c_i : \tau }~\ctx =
  \delta~(c_i) & (\emph{const})
\\[0.5em]
\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }~\ctx = & (\emph{sub})\\[-0.25em]
  \hspace{3em}\sem{\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau }~(\ident{lift}_{\cclrd{r}, \cclrd{r'}}~\ctx)~
    \hspace{7.5em}(\hspace{-0.7em}\textnormal{\footnotesize when}~\cclrd{r'} \leq \cclrd{r})
\\[0.5em]
\sem{\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }~\ctx = \lambda v.& (\emph{abs})\\[-0.25em]
  \hspace{3em}\sem{\coctx{\Gamma, x:\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}~(\ident{merge}_{\cclrd{r}, \cclrd{s}}~(\ctx, v))
\\[0.5em]
\sem{\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2}~\ctx = & (\emph{app})\\[-0.25em]
  \hspace{2.5em}
  \begin{array}{l}  
  \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\cclrd{r}, \cclrd{s} \,\cseq\, \cclrd{t}}~
    (\ident{map}_{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})}~(\lambda x.(x,x))~\ctx) \\[-0.25em]
  \kvd{in}~\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}~\ctx_1~
      (\ident{cobind}_{\cclrd{s}, \cclrd{t}}~\sem{\coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }~\ctx_2)
  \end{array}    
\end{array}
\end{equation*}

\caption{Categorical semantics of the flat coeffect calculus}
\label{fig:flat-semantics}
\end{figure*}

% --------------------------------------------------------------------------------------------------


\paragraph{Expressions.}
The definition of the semantics is shown in Figure~\ref{fig:flat-semantics}. For readability, we 
write the definitions in a simple programming language notation as opposed to the point-free 
categorical style. However, it can be equally written using just the operations of flat indexed 
comonad together with $i^{th}$ projection from a tuple represented by $\pi_i$, \emph{curry} and 
\emph{uncurry}, function composition, value duplication ($\Delta : A \rightarrow A \times A$) and 
function pairing (given $f:A\rightarrow B$ and $g:C\rightarrow D$ then $f\times g : A\times C \rightarrow B \times D$). 
These operations can be provided by \eg~a Cartesian Closed Category.

The semantics of variable access and abstraction are the same as in the semantics of Uustalu and 
Vene \cite{comonads-notions}, modulo the indexing. The semantics of variable access (\emph{var}) uses 
$\ident{counit}_{\cunit}$ to extract product of free-variables from the context and then projection
$\pi_i$ to obtain the variable value. Abstraction (\emph{abs}) takes the context $\ctx$ and function argument 
$v$ and merges their additional contexts using $\ident{merge}_{\cclrd{r}, \cclrd{s}}$. Assuming
the context $\Gamma$ contains variables of types $\sigma_1, \ldots, \sigma_n$, this gives us a 
value $\ctyp{\cclrd{r}\czip\cclrd{s}}((\sigma_1 \times \ldots \times \sigma_n) \times \tau_1)$.
Assuming that $n$-element tuples are associated to the left, the wrapped context is equivalent to
$\sigma_1 \times \ldots \times \sigma_n \times \tau_1$, which can then be passed to the body of the
function.

The semantics of application is more complex. It first duplicates the free-variable product inside the 
context (using $\ident{map}_{\cclrd{r}}$ and duplication). Then it splits this context using 
$\ident{split}_{\cclrd{r}, \cclrd{s} \cpar \cclrd{t}}$. The two contexts contain the same variables
(as required by sub-expressions $e_1$ and $e_2$), but different coeffect annotations. The first
context (with index $\cclrd{r}$) is used to evaluate $e_1$, resulting in a function 
$\ctyp{\cclrd{t}}{\tau_1} \rightarrow \tau_2$. To obtain the result, we compose this with a function
created by applying $\ident{cobind}_{\cclrd{s}, \cclrd{t}}$ on the semantics of sub-expression
$e_2$, which is of type $\ctyp{\cclrd{s}\cseq\cclrd{t}}{\sigma_1 \times \ldots \times \sigma_n}
\rightarrow \ctyp{\cclrd{t}}{\tau_1}$.

Finally, constants (\emph{const}) are modelled by a global dictionary $\delta$ and sub-coeffecting
is interpreted by dropping additional context from the provided context $\ctx$ using 
$\ident{lift}_{\cclrd{r}, \cclrd{r'}}$ and providing it to the semantics of the assumption.

\paragraph{Properties.}

The categorical semantics can be used to embed context-dependent computations in functional 
programming languages, similarly to how monads provide a way of embedding effectful computations.
More importantly, it also provides validation for the design of the type system developed in 
Section~\ref{sec:flat-calculus-types}. As stated in the following theorem, the annotations in 
the type system match those of the semantic functions.

\vspace{2em}

\begin{remark}[Correspondence]
In all of the typing rules of the flat coeffect system, the context annotations $\cclrd{r}$ of typing 
judgements $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ and function types $\tau_1 \xrightarrow{\cclrd{r}} \tau_2$ 
correspond to the indices of mappings $\ctyp{\cclrd{r}}{}$ in the corresponding semantic function defined 
by $\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau}$.
\end{remark}
\begin{proof}
By analysis of the semantic rules in Figure~\ref{fig:flat-semantics}.
\end{proof}

\noindent
Thanks to the indexing, the statement of the remark is significantly stronger than for a 
non-indexed system, because it provides the justification for our choice of indices in the typing
rules. In particular, we can see that the annotations follow from the annotations on primitive 
functions that define the semantics. Also, each function defining the semantics uses a distinct 
operation of the coeffect algebra and so the type system is the most general possible definition
(within the comonadic framework we use).

% ==================================================================================================


\newcommand{\ccat}[0]{\mathcal{C}}
\newcommand{\cobind}[2]{#1^\dagger_{#2}}
\newcommand{\cmerge}[0]{ \ident{m} }
\newcommand{\csplit}[0]{ \ident{n} }
\newcommand{\counit}[0]{ \varepsilon }
\newcommand{\llangle}{\langle\hspace{-0.25em}\langle}
\newcommand{\rrangle}{\rangle\hspace{-0.25em}\rangle}

\section{Equational theory}
\label{sec:flat-syntax}

\subsection{Call-by-value evaluation}
\subsection{Call-by-name evaluation}

% ==================================================================================================

\section{Syntactic extensions}
\label{sec:flat-exts}

\subsection{Lambda abstraction}
\subsection{Constants and pairs}
\subsection{Recursion}

% ==================================================================================================

\section{Type inference}
\label{sec:flat-inference}

\subsection{Semi-lattice formulation}
\subsection{Type inference algorithm}

% ==================================================================================================

\section{Related work}

\subsection{What can be monad}
\label{sec:flat-related-monads}

% ==================================================================================================

\section{Summary}

\section{----------------JUNK!}




% ==================================================================================================

~
\newpage
~

% ==================================================================================================

\section{Syntax-based equational theory}
\label{sec:syntactic}

Operational semantics of every context-dependent language differs as the notion of context 
is always different. However, for coeffect calculi satisfying certain conditions we can 
define a universal equational theory. This suggests a pathway to an operational semantics for 
two out of our three examples (the notion of context for data-flow is more complex).

In a pure $\lambda$-calculus, $\beta$ and $\eta$ equality for
functions (also called \emph{local soundness} and \emph{completeness}
respectively~\cite{logic-modal-reconstruction})
describe how pairs of abstraction and application can be eliminated:
$(\lambda x . e_2) e_1 \equiv_\beta \subst{e_1}{x}{e_2}$ and $(\lambda x . e \, x) 
\equiv_\eta e$. The $\beta$ equality rule, using the usual Barendregt convention of 
syntactic substitution, implies a \emph{reduction},
giving part of an operational semantics for the calculus.

The call-by-name evaluation strategy modelled by $\beta$-reduction is
not suitable for impure calculi therefore a restricted $\beta$ rule,
corresponding to call-by-value, is used, \ie~$(\lambda x . e_2) v
\equiv \subst{e_2}{x}{v}$. Such reduction can be encoded by a
\emph{let}-binding term, $\kvd{let}~x=e_1~\kvd{in}~e_2$, which
corresponds to sequential composition of two computations, where the
resulting pure value of $e_1$ is substituted into
$e_2$~\cite{monads-inaction,monad-notions}.

%
% We consider here both a notion of \emph{let}-binding for the coeffect
% calculus, useful for a CBV evaluation, and a notion of substitution 
% for a CBV evaluation.
% 

For an equational theory of coeffects, consider first a notion 
of \emph{let}-binding equivalent to $(\lambda x . e_2)~e_1$, which
has the following type and coeffect rule:
%
\begin{equation}
\inference
  {\ctyp{s}{\Gamma} \vdash e_1 : \tau_1 &
   \ctyp{r_1 \wedge r_2}{(\Gamma, x : \tau_1)} \vdash e_2 : \tau_2}
  {\ctyp{r_1 \vee (r_2 \cseq s)}{\Gamma} \vdash \kvd{let}~x = e_1~\kvd{in}~e_2
: \tau_2 }
\label{eq:let1}
\end{equation}

\noindent
For our examples, $\wedge$ is idempotent (\ie{}, $r \wedge r = r$)
implying a simpler rule:

% For the three examples we consider, a simpler rule gives a more
% precise coeffect. Because $r \wedge r = r$ for all our examples, we
% can also a coeffect $r \vee (r \cseq s)$. Moreover,
%for our examples (but not necessarily for \emph{all} coeffect
%systems), $r \vee (r \cseq s) \leq r_1 \vee (r_2 \cseq s)$ meaning
%that the following gives more precise coeffects:
%
\begin{equation}
\inference
  {\ctyp{s}{\Gamma} \vdash e_1 : \tau_1 &
   \ctyp{r}{(\Gamma, x : \tau_1)} \vdash e_2 : \tau_2}
  {\ctyp{r \vee (r \cseq s)}{\Gamma} \vdash \kvd{let}~x = e_1~\kvd{in}~e_2 : \tau_2 }
\label{eq:let2}
\end{equation}
%%
For our examples (but not necessarily \emph{all} coeffect
systems), this defines a more ``precise'' coeffect with respect to $\leq$
where $r \vee (r \cseq s) \leq r_1 \vee (r_2 \cseq s)$.

This rule removes the non-principality of the first rule
(\ie~multiple possible typings).  However, using idempotency 
to split coeffects in abstraction would remove additional
flexibility needed by the implicit parameters example.

The coeffect $r \vee (r \cseq s)$ can
also be simplified for all our examples, leading to more intuitive
rules -- for implicit parameters $r \cup (r \cup s) = r \cup s$; for
liveness we get that $r \sqcup (r \sqcap s) = r$ and for dataflow we
obtain $\textit{max}(r, r+s) = r + s$.

Our calculus can be extended with \emph{let}-binding and \eqref{eq:let2}.
However, we also consider the cases when a
syntactic substitution $e_2[x \leftarrow e_1]$ has the coeffects
specified by the above rule \eqref{eq:let2} 
and prove \emph{subject reduction} theorem
for certain coeffect calculi.  We consider two common special cases
when the coeffect of variables $\cunit$ is the greatest ($\top$) or
least ($\bot$) element of the semi-lattice $(S, \vee)$ and derive
additional conditions that have to hold about the coeffect algebra:

\begin{lemma}[Substitution]
\label{thm:subst}
Given $C^r (\Gamma, x : \tau_2) \vdash e_1 : \tau_1$ and $C^s \Gamma \vdash e_2 : \tau_2$
then $C^{r \vee (r \oplus s)} \Gamma \vdash \subst{e_2}{x}{e_1} : \tau_1$ if 
the coeffect algebra satisfies the conditions that 
$\cunit$ is either the greatest or least element of the semi-lattice,
$\oplus = \wedge$, and $\oplus$ distributes over $\vee$,
\ie{}, $X \oplus (Y \vee Z) = (X \oplus Y) \vee (X \oplus Z)$.
\end{lemma}

\begin{proof}
By induction over $\vdash$, using the laws (\S\ref{sec:calculus}) and additional assumptions.
\end{proof}

Assuming $\rightarrow_\beta$ is the usual call-by-name reduction, the
following theorem models the evaluation of coeffect calculi with
coeffect algebra that satisfies the above requirements. We do not
consider \emph{call-by-value}, because our calculus does not have a
notion of \emph{value}, unless explicitly provided by
\emph{let}-binding (even a function ``value'' $\lambda x.e$ may have
immediate contextual requirements).

\begin{theorem}[Subject reduction]
\label{thm:reduction}
For a coeffect calculus, satisfying the conditions of Lemma~\ref{thm:subst}, if
$\ctyp{r}{\Gamma} \vdash e : \tau$ and $e \rightarrow_\beta e'$ then 
$\ctyp{r}{\Gamma} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
A direct consequence of Lemma~\ref{thm:subst}. 
\end{proof}

The above theorem holds for both the liveness and resources examples,
but not for dataflow.  In the case of liveness, $\cunit$ is the
greatest element ($r \vee \cunit = \cunit$); in the case of
resources, $\cunit$ is the \emph{least} element ($r \vee \cunit =
r$) and the proof relies on the fact that additional
context-requirements can be placed at the context $\ctyp{r}{\Gamma}$
(without affecting the type of function when substituted under
$\lambda$ abstraction).

However, the coeffect calculus also captures context-dependence in
languages with more complex evaluation strategies than
\emph{call-by-name} reduction based on syntactic substitution.  In
particular, syntactic substitution does not provide a suitable evaluation
for dataflow (because a substituted expression needs to capture the
context of the original scope).

Nevertheless, the above results show that -- unlike effects --
context-dependent properties can be integrated with
\emph{call-by-name} languages. Our work also provides a model of
existing work, namely Haskell implicit parameters
\cite{app-implicit-parameters}.

% ==================================================================================================

\section{Related and further work}
\label{sec:related}

This paper follows the approaches of effect systems \cite{effects-gifford,effects-talpin-et-al,monads-effects-marriage}
and categorical semantics based on monads and comonads \cite{monad-notions,comonads-notions}. Syntactically,
\emph{coeffects} differ from \emph{effects} in that they model systems where $\lambda$-abstraction 
may split contextual requirements between the declaration-site and call-site.

Our \emph{indexed (monoidal) comonads} (\S\ref{sec:comonads}) fill the gap between (non-indexed)
\emph{(monoidal) comonads} of Uustalu and Vene \cite{comonads-notions}
and indexed monads of Atkey~\cite{monads-parameterised-notions}, Wadler and Thiemann
\cite{monads-effects-marriage}. Interestingly, \emph{indexed} comonads are \emph{more
general} than comonads, capturing more notions of context-dependence (\S\ref{sec:motivation}).

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\paragraph{Comonads and modal logics.}

Bierman and de Paiva \cite{logic-intuitionistic-modal} model the
$\square$ modality of an intuitionistic S4 modal logic using monoidal
comonads, which links our calculus to modal logics.  This link can be
materialized in two ways.

Pfenning et al. and Nanevski et al.  derive term languages using the Curry-Howard
correspondence~\cite{logic-modal-reconstruction,logic-intuitionistic-modal,logic-cmtt},
building a \emph{metalanguage} (akin to Moggi's monadic metalanguage
\cite{monad-notions}) that includes $\square$ as a type
constructor. For example, in \cite{logic-modal-reconstruction}, the
modal type $\Box \tau$ represents closed terms.
In contrast, the \emph{semantic} approach uses monads or comonads
\emph{only} as a semantics.  This has been employed by Uustalu and
Vene and (again) Moggi \cite{monad-notions,comonads-notions}.  We
follow the semantic approach.

Nanevski et al. extend an S4 term language to a \emph{contextual}
modal type theory (CMTT)~\cite{logic-cmtt}.
The \emph{context} is a set of variables required by a computation, which
makes CMTT useful for meta-programming and staged computations. Our contextual types are
indexed by a coeffect algebra, which is more general and can capture
variable contexts, but also integers, two-point lattices, \emph{etc.}.

The work on CMTT suggests two extensions to coeffects. The first is
developing the logical foundations. We briefly considered special cases
of our system that permits local soundness in \S\ref{sec:syntactic} and
local completeness can be treated similarly. The second problem is 
developing the coeffects \emph{metalanguage}. The use of coeffect algebras
would provide an additional flexibility over CMTT, allowing a wider range 
of applications.

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\paragraph{Relating effects and coeffects.} 
The difference between effects and coeffects is mainly in the (\emph{abs}) rule. While the 
semantic model (monads vs. comonads) is very different, we can consider extending the two to 
obtain equivalent syntactic rules. To allow splitting of implicit parameters in lambda abstraction, 
the reader monad needs an operation that eagerly performs some effects of a function: 
$(\tau_1 \rightarrow \mtyp{r \oplus s}{\tau_2}) \rightarrow \mtyp{r}{(\tau_1 \rightarrow \mtyp{s}{\tau_2})}$.
To obtain a pure lambda abstraction
for coeffects, we need to restrict the $\cmerge_{r, s}$ 
operation of indexed comonads, so that the first parameter is annotated with $\cunit$ (meaning
no effects): $\ccat^{\cunit} A \times \ccat^r B \rightarrow \ccat^{r}(A \times B)$.

\newcommand{\cprd}{\times}
\newcommand{\cvop}{\oplus}

\vspace{-1em}
\paragraph{Structural coeffects.} To make the liveness analysis practical, we need to associate
information with individual variables (rather than the entire context). We can generalize the 
calculus from this paper by adding a product operation $\times$ to the coeffect algebra.
A variable context $x:\tau_1, y:\tau_2, z:\tau_3$ is then annotated with
$r\times s \times t$ where each component of the tag corresponds to a single variable. The system
then needs to be extended with structural rules such as:
%
\begin{equation*}
\inference[(\emph{abs})]
  {\ctyp{r \cprd s}{(\Gamma, x:\tau_1)} \vdash e : \tau_2}
  {\ctyp{r}{\Gamma} \vdash \lambda x.e : \ctyp{s}{\tau_1} \rightarrow \tau_2 }
\quad
\inference[(\emph{contr})]
  {\ctyp{r \cprd s}{(x:\tau_1, y:\tau_1)} \vdash e : \tau_2}
  {\ctyp{r \cvop s }{(z:\tau_1)} \vdash \subst{\subst{e}{x}{z}}{y}{z} : \tau_2 }
\end{equation*}
%
The context-requirements associated with function are exactly those linked to the specific
variable of the lambda abstraction. Rules such as contraction manipulate variables and perform
a corresponding operation on the indices.

The structural coeffect system is related to bunched typing \cite{types-bunched} (but generalizes
it by adding indices). We are currently investigating how to use structural coeffects to capture 
fine-grained context-dependence properties such as secure information flow \cite{app-secure-flow}
or, more generally, those captured by dependency core calculus \cite{types-dcc}.

% ==================================================================================================

\section{Conclusions}

We examined three simple calculi with associated
static analyses (liveness analysis, implicit parameters, and dataflow
analysis). These were unified in the \emph{coeffect calculus},
providing a general coeffect system parameterised by an
algebraic structure describing the propagation of context
requirements throughout a program.

We model the semantics of coeffect calculus using \emph{indexed comonad} -- a novel structure, which
is more powerful than (monoidal) comonads. Indices of the indexed comonad operations manifest the 
semantic propagation of context such that the propagation of information in the general coeffect
type system corresponds exactly to the semantic propagation of context in our categorical model.

We consider the analysis of context to be essential, not least for the examples here but 
also given increasingly rich and diverse distributed systems.

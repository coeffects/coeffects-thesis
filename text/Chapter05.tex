%!TEX root = ../main.tex

\chapter{Structural coeffect language} 
\label{ch:structural}

As already discussed, the aim of this thesis is to identify abstractions for context-aware
programming languages. We attempt to find abstractions that are general enough to capture a wide
range of useful programming language features, but specific enough to let us identify
interesting properties of the languages.

In Chapter~\ref{ch:applications}, we identified two notions of context. We generalized the 
class of flat calculi that capture whole-context properties in Chapter~\ref{ch:flat}. 
In this chapter, we turn our attention to \emph{structural} coeffect calculi that capture
per-variable properties.

The flat coeffect system captures interesting use-cases (implicit parameters, liveness and
data-flow), but provides relatively weak properties. We can define its categorical semantics,
but the equational theory proofs had numerous additional requirements. For this reason, it
is worthwhile to consider structural systems in a separate chapter. We will see that 
structural coeffects have a number of desirable properties that hold for all instances of the
calculus.



% ==================================================================================================
%                                                                                      
%     ###           #                       #                 #       #                 
%      #            #                       #                 #                         
%      #    # ##   ####   # ##    ###    ## #  #   #   ###   ####    ##     ###   # ##  
%      #    ##  #   #     ##  #  #   #  #  ##  #   #  #   #   #       #    #   #  ##  # 
%      #    #   #   #     #      #   #  #   #  #   #  #       #       #    #   #  #   # 
%      #    #   #   #  #  #      #   #  #  ##  #  ##  #   #   #  #    #    #   #  #   # 
%     ###   #   #    ##   #       ###    ## #   ## #   ###     ##    ###    ###   #   # 
%                                                                                     
% ==================================================================================================

\section{Introduction}
\label{sec:flat-intro}

Two examples of flat systems from the previous chapter were liveness and data-flow. As discussed
in \ref{sec:applications-structural}, these are interesting for theoretical reasons. However, tracking
liveness of the whole context is not practically useful. Structural versions of liveness and 
data-flow let us track more fine-grained properties. Moreover, the equational theory of flat 
coeffect calculus did not reveal many useful properties for flat liveness and data-flow. 
As we show in this chapter, this is not the case with structural versions.

In this chapter, we focus on three example applications. We look at structural liveness and
data-flow and we also consider calculus for bounded reuse, which checks how many times a variable
is accessed and generalizes linear logics (that restrict variables to be used exactly once).

%---------------------------------------------------------------------------------------------------

\subsection{Contributions}

Compared to the previous chapter, the structural coeffect calculi we consider are more 
homogeneous and so finding the common pattern is in some ways easier. However, the systems
are somewhat more complicated as they need to keep annotations attached to individual variables. 
The contributions of this chapter are as follows:

\begin{itemize}
\item We present a \emph{structural coeffect calculus} with a type system that is parameterized by a 
  \emph{structural coeffect algebra} and can be instantiated to obtain all of the three examples
  discussed (Section~\ref{sec:struct-calculus}).
  
\item We give the equational theory of the calculus. We prove the type-preservation property 
  for all structural calculi for both call-by-name and call-by-value (Section~\ref{sec:struct-syntax}). 
  
\item We show how to extend indexed comonads introduced in the previous section to 
  \emph{structural indexed comonads} and use them to give the semantics of structural 
  coeffect calculus (Section~\ref{sec:struct-semantics}). As with the flat version, the
  categorical semantics provides a motivation for the design of the calculus.
\end{itemize}

%---------------------------------------------------------------------------------------------------

\subsection{Related work}

In the previous chapter, we discussed the correspondence between coeffects and effects (and 
between comonads and monads). As noted earlier, the $\lambda$-calculus is assymetric in that
an expression has multiple inputs (variables in the context), but just a single result 
(the resulting value) and so monads and effects have no notion directly corresponding to 
structural coeffect systems.

The work in this chapter is more closely related to sub-structural type systems \cite{substruct-attpl-intro}.
While sub-structural systems remove some or all of \emph{weakening}, \emph{contraction} and
\emph{exchange} rules, our systems keep them, but use them to manipulate both the context
and its annotations.

Our work follows the language semantics style in that we provide a structural semantics to
the terms of ordinary $\lambda$-calculus. The most closely related work has been done in the
meta-langauge style, which extends the terms and types with constructs working with the context
explicitly. This includes Contextual Modal Type Theory (CMTT) \cite{logic-cmtt}, where variables
may be of a type $A[\Psi]$ denoting a value of type $A$ that requires context $\Psi$. In CMTT, 
$A[\Psi]$ is a first-class type, while structural coeffect systems do not expose coeffect 
annotations as stand-alone types.

Structural coeffect systems annotate the whole variable context with a \emph{vector} of annotations.
For example, a context with variables $x$ and $y$ annotated with $\cclrd{s}$ and $\cclrd{t}$, 
respectively is written as $\coctx{x\!:\!\tau_1,y\!:\!\tau_2}{\alift{\cclrd{s},\cclrd{t}}}$.
This means that the typing judgements have the same structure as those of the flat coeffect
calculus. As discussed in Chapter~\ref{ch:unified}, this makes it possible to unify the two 
systems and compose tracking of flat and structural properties.



% =================================================================================================
%                                                            
%       ###           ##                   ##                 
%      #   #           #                    #                 
%      #       ###     #     ###   #   #    #    #   #   ###  
%      #          #    #    #   #  #   #    #    #   #  #     
%      #       ####    #    #      #   #    #    #   #   ###  
%      #   #  #   #    #    #   #  #  ##    #    #  ##      # 
%       ###    ####   ###    ###    ## #   ###    ## #  ####  
%                                                           
% =================================================================================================

\section{Structural coeffect calculus}
\label{sec:struct-calculus}

In the structural coeffect calculus, a vector of variables in the free-variable context is 
annotated with a vector of primitive (scalar) coeffect annotations. These annotations differ
for different coeffect calculi and their properties are captured by the \emph{structural 
coeffect scalar} definition below. The scalar annotations can be integers (how many past values we 
need) or annotations specifying whether a variable is live or not.

Scalar annotations are written as $\cclrd{r}, \cclrd{s}, \cclrd{t}$ (following the style used in 
the previous chapter). Functions always have exactly one input variable and so they are annotated
with a coeffect scalar. Thus the expressions and types of structural coeffect calculi are the same
as in the previous chapter (except that annotation on function type is now a structural coeffect 
scalar):
%
\begin{equation*}
\begin{array}{rcl}
e &::=& x \sep \lambda x.e \sep e_1~e_2 \sep \kvd{let}~x = e_1~\kvd{in}~e_2\\
\tau &::=& T \sep \tau_1 \xrightarrow{\cclrd{r}} \tau_2
\end{array}
\end{equation*}
%
In the previous chapter, the free variable context $\Gamma$ has been treated as a set. In the 
structural coeffect calculus, the order of variables matters. Thus we treat free variable context
as a vector with a uniqueness condition. We also write $\xlift{-}$ for the length
of the vector:
%
\begin{equation*}
\begin{array}{rcl}
 \Gamma &\narrow{=}& \langle x_1\!:\tau_1, \ldots, x_n\!:\!\tau_n \rangle \qquad \textnormal{such that}~~\forall i, j ~.~ i \neq j \implies x_i \neq x_j\\
 \xlift{\Gamma} &\narrow{=}& n
\end{array}
\end{equation*}
%
For readability, we use the usual notation $x_1\!:\!\tau_1, \ldots, x_1\!:\!\tau_1 \vdash e : \tau$ for
typing judgements, but the free variable context should be understood as a vector.
Furthermore, the usual notation $\Gamma_1, \Gamma_2$ stands for the tensor product.
Given $\Gamma_1 = \langle x_1\!:\tau_1, \ldots, x_n\!:\!\tau_n \rangle $ and
$\Gamma_2 = \langle x_{n+1}\!:\tau_{n+1}, \ldots, x_m\!:\!\tau_m \rangle $ then
$\Gamma_1, \Gamma_2 = \Gamma_1 \times \Gamma_2 = \langle x_1\!:\tau_1, \ldots, x_m\!:\!\tau_m \rangle$.

The free variable contexts are annotated with vectors of structural coeffect scalars. In what follows,
we write the vectors of coeffects as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}$. Meta-variables ranging 
over vectors are written as $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$ (using bold face 
and colour to distinguish them from scalar meta-variables) and the length of a coeffect vector
is written as $\slift{\aclrd{\textbf{r}}}$. The structure for working with vectors
of coeffects is provided by the \emph{structural coeffect algebra} definition below. 

% -------------------------------------------------------------------------------------------------

\subsection{Structural coeffect algebra}

The structural coeffect scalar structure is similar to \emph{flat coeffect algebra} with the 
exception that it drops the $\czip$ operation. It only provides a monoid $(\C, \cseq, \cunit)$
modelling sequential composition of computations and a monoid $(\C, \cpar, \czero)$ representing
point-wise composition, as well as a relation $\cleq$ that defines sub-coeffecting.

\begin{definition}
A \emph{\cclrd{structural coeffect scalar}} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ is a set 
$\C$ together with elements $\cunit, \czero \in \C$, relation $\cleq$ and binary operations 
$\cseq, \cpar$ such that $(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids and
$(\C, \cleq)$ is a pre-order. That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}   
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}   
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}   
\end{array}
\end{equation*}
%
In addition, the following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
\end{definition}

\noindent
In the flat coeffect calculus, we used the $\czip$ operation to merge the annotations of contexts
available from the declaration-site and the call-site or, in the syntactic reading, to split the 
context requirements.

In the structural coeffect calculus, we use a vector instead -- combining and splitting of 
coeffects becomes just vector a concatenation or splitting, respectively, which is provided
by the tensor product. The operations on vectors are indexed by integers representing the lengths
of the vectors. The additional structure required by the type system for structural coeffect 
calculi is given by the following definition.

\begin{definition}
A \emph{\aclrd{structural coeffect algebra}} is formed by a structural coeffect scalar 
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ equipped with the following additional structures:

\begin{itemize}
\item Coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$, ranging over
  structural coeffect scalars indexed by vector lengths $\sclrd{m}, \sclrd{n} \in \sclrd{\mathbb{N}}$.

\item An operation that constructs a vector from scalars indexed by the vector length
  $\alift{-}_{\sclrd{n}} : \C \times \ldots \times \C \rightarrow \C^{\sclrd{n}}$
  and an operation that returns the vector length such that 
  $\slift{\aclrd{\textbf{r}}} = \sclrd{n}$ for $\aclrd{\textbf{r}} : \C^{\sclrd{n}}$

\item A point-wise extension of the $\cseq$ operator written as $\cclrd{t} \,\aseq\, \aclrd{\textbf{s}}$
  such that\\ $\cclrd{t} \,\aseq\, \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} = 
    \alift{\cclrd{t} \,\cseq\,\cclrd{r_1}, \ldots, \cclrd{t} \,\cseq\,\cclrd{r_n}}$.

\item An indexed tensor product $\atimes_{\sclrd{n},\sclrd{m}} : \C^{\sclrd{n}} \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{n}+\sclrd{m}}$
  that is used in both directions -- for vector concatenation and for splitting -- 
  which is defined as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} 
     \atimes_{\sclrd{n}, \sclrd{m}} \alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}
   = \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}, \cclrd{s_1}, \ldots, \cclrd{s_m}}$
\end{itemize}
\end{definition}

\noindent
The fact that the tensor product $\atimes_{\sclrd{n},\sclrd{m}}$ is indexed by the lengths
of the two vectors means that we can use it unambiguously for both concatenation of vectors
and for splitting of vectors, provided that the lengths of the resulting vectors are known.
In the following text, we usually omit the indices and write just 
$\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s}}$, because the lengths of the coeffect vectors 
can be determined from the lengths of the matching free variable context vectors.

More generally, we could see the the coeffect annotations as a \emph{container} 
\cite{types-containers} that supports certain operations. This approach is used in 
Chapter~\ref{ch:unified} as a way of unifying the flat and structural systems. 

% -------------------------------------------------------------------------------------------------

\subsection{Structural coeffect types}
\label{sec:struct-calculus-types}

The type system for structural coeffect calculus is similar to sub-structural type systems
in how it handles free variable contexts. The \emph{syntax-driven} rules do not implicitly allow
weakening, exchange or contraction -- this is done by checking the types of sub-expressions
in disjoint parts of the free variable context. Unlike in sub-structural logics, our system
allows weakening, exchange and contraction, but using explicit \emph{structural} rules that
perform corresponding transformation on the coeffect annoation.

\paragraph{Syntax-driven rules.}
The variable access rule (\emph{var}) annotates the corresponding variable as being used
using $\cunit$. Note that, as in sub-structural systems, the free variable context contains 
\emph{only} the accessed variable. Other variables can be introduced using explicit weakening.
Constants (\emph{const}) are type checked in an empty variable context, which is annotated with
an empty vector of coeffect annotations.

The (\emph{abs}) rule assumes that the free variable context of the body can be split into
a potentially empty \emph{declaration site} and a singleton context containing the bound
variable. The corresponding splitting is performed on the coeffect vector, uniquely associating
the annotation $\cclrd{s}$ with the bound variable $x$. This means that the typing rule removes
non-determinism present in flat coeffect systems.

In (\emph{app}), the sub-expressions $e_1$ and $e_2$ use free variable contexts $\Gamma_1, \Gamma_2$
with coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}$, respectively. The function
value is annotated with a coeffect scalar $\cclrd{t}$.
The coeffect annotation of the composed expression is obtained by combining the annotations
associated with variables in $\Gamma_1$ and $\Gamma_2$. Variables in $\Gamma_1$ are only
used to obtain the function value, resulting in coeffects $\aclrd{\textbf{r}}$. The 
variables in $\Gamma_2$ are used to obtain the argument value, which is then sequentially
composed with the function, resulting in $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$.

\paragraph{Structural rules.}
The remaining rules, shown in Figure~\ref{fig:struct-types} (b), are not syntax-directed.
They allow different transformation of the free variable context. We include sub-coeffecting
(\emph{sub}) as one of the rules, allowing sub-coeffecting on coeffect scalars belonging
to individual variables. The remaining rules capture \emph{weakening}, \emph{exchange} and
\emph{contraction} known from sub-structural systems.

The (\emph{weak}) allows adding a variable to the context, extending the coeffect
vector with $\czero$ to mark it as unused, (\emph{exch}) provides a way to rearrange variables
in the context, performing the same reordering on the coeffect vector. Finally recall that 
variables in the free variable context are required to be \emph{unique}. The (\emph{contr}) rule 
allows re-using a variable as we can type check sub-expressions using two separate varaibles and 
then unify them using substitution. The resulting variable is annotated with $\cpar$ and it
is the only place in the structural coeffect system where context requiremens are combined,
or semantically, where the same context is shared.

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
{\small a.) Syntax-driven typing rules:}
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {c \!:\! \tau \in \Delta}
  {\coctx{()}{\alift{}} \vdash c : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\atimes\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\; \aclrd{\textbf{s}}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Structural rules for context manipulation:}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s'}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
(\cclrd{s'} \cleq \cclrd{s})
\end{equation*}
\begin{equation*}
\tyrule{weak}
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \cons \alift{ \czero }} \vdash e : \tau} 
\end{equation*}
\begin{equation*}
\tyrule{exch}
  {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
\begin{array}{l}
 \xlift{\Gamma_1} = \slift{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlift{\Gamma_2} = \slift{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}
\begin{equation*}
\hspace{2.5em} 
\tyrule{contr}
  {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}
~
\begin{array}{l}
 \xlift{\Gamma_1} = \slift{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlift{\Gamma_2} = \slift{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}

\caption{Type system for the structural coeffect calculus}
\label{fig:struct-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\subsection{Understanding structural coeffects}

The type system for structural coeffects appears more complicated when compared to the flat
version, but it is in many ways simpler -- it removes the ambiguity arising from the use
of $\czip$ in lambda abstraction and, as discussed in Section~\ref{sec:struct-syntax}, has
a cleaner equational theory.

\paragraph{Flat and structural context.} In flat systems, lambda abstraction splits context
requirements using $\czip$ and application combines them using $\cpar$. In the structural
version, both of these are replaced with $\atimes$. The $\czip$ operation is not needed, but
$\cpar$ is still used in the (\emph{contr}) rule.

This suggests that $\czip$ and $\cpar$ serve two roles in flat coeffects. First, they are used
as over- and under-approximations of $\atimes$. This is demonstrated by the (\emph{approximation})
requirement introduced in Section~\ref{sec:flat-syntax-cbv}, which requires that
$\cclrd{r}\,\czip\,\cclrd{t}\;\cleq\;\cclrd{r}\,\cpar\,\cclrd{t}$. Semantically, flat abstraction
combines available context, potentially discarding parts of it (under-approximation), while flat
application splits available context, potentially duplicating parts of it (over-approxi\-mation)\footnote{
Because of this duality, earlier version of coeffects in \cite{coeffects-icalp13}
used $\wedge$ and $\vee$.}.

Second, the operator $\cpar$ is used when the semantics passes the same context to multiple
sub-expressions. In flat systems, this happens in (\emph{app}) and (\emph{pair}), because the 
sub-expressions may share variables. In structural systems, this is separated into an 
explicit contraction rule.

\paragraph{Let binding.}
The other aspect that makes structural systems simpler is that they remove the need for 
separate let binding. As discussed in Section~\ref{sec:flat-calculus-let}, flat calculi include
let binding that gives a \emph{more precise} typing than combination of abstraction and 
application. This is not the case for structural coeffects.

\begin{remark}[Let binding]
In a structural coeffect calculus, the typing of $(\lambda x.e_2)~e_1$ is equivalent
to the typing of $\kvd{let}~x=e_1~\kvd{in}~e_2$.
\end{remark}
\begin{proof}
Consider the following typing derivation for $(\lambda x.e_2)~e_1$. Note that 
in the last step, we apply (\emph{exch}) repeatedly to swap $\Gamma_1$ and $\Gamma_2$. 
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1\vspace{-1.6em}\end{array} &
    \inference
      { \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2 }
      { \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash \lambda x.e_2 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2} \vspace{0.2em} }
  { \inference
      { \coctx{\Gamma_2, \Gamma_1}{\aclrd{\textbf{s}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{r}})} \vdash (\lambda x.e_2)~e_1 : \tau_2 }
      { \coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\;  \aclrd{\textbf{s}} } \vdash (\lambda x.e_2)~e_1 : \tau_2 } }
\end{equation*}

\noindent
The assumptions and conclusions match those of the (\emph{let}) rule. 
\end{proof}


%---------------------------------------------------------------------------------------------------

\subsection{Examples of structural coeffects}

The structural coeffect calculus can be instantiated to obtain the structural coeffect calculi
presented in Section~\ref{sec:applications-structural}. Two of them -- structural data-flow and
structural liveness provide a more precise tracking of properties that can be tracked using 
flat systems. Formally, a flat coeffect algebra can be turned into a structural coeffect algebra
(by dropping the $\czip$ operator), but this does not always give us a meaningful system -- for
example, it is not clear why one would associate implicit parameters with individual variables.

On the other hand, some of the structural systems do not have a flat equivalent, typically 
because there is no appropriate $\czip$ operator that could be added to form the flat coeffect
algebra. This is the case, for example, for the bounded variable use.

\begin{example}[Structural liveness]
The structural coeffect algebra for liveness is formed by
$(\mathcal{L}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$, where $\mathcal{L}=\{ \ident{L}, \ident{D} \}$ is 
the same two-point lattice as in the flat version, that is $\ident{D} \sqsubseteq \ident{L}$
with a join $\sqcup$ and meet $\sqcap$. 
\end{example}

\begin{example}[Structural data-flow]
In data-flow, context is annotated with natural numbers and the flat coeffect algebra is formed 
by $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$.
\end{example}

\noindent
For the two examples that have both flat and structural version, obtaining the strucutral coeffect
algebra is easy. As shown by the examples above, we simply omit the $\czip$ operation. The laws
required by a structural coeffect algebra are the same as those required by the flat version
and so the above definitions are both valid. Similar construction can be used for the
\emph{optimized data-flow} example from Section~\ref{sec:flat-calculus-examples}.

It is important to note that this gives us a systems with \emph{different} properties. The 
information are now tracked per-variable rather than for the enitre context. For data-flow,
we also need to adapt the typing rule for the \kvd{prev} construct. Here, we write $\aclrd{+}$ 
for a point-wise extension of the $+$ operator, such that
$\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} + k = \alift{\cclrd{r_1} + k, \ldots, \cclrd{r_n} + k}$.
%
\begin{equation*}
\tyrule{prev}
  { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau }
  { \coctx{\Gamma}{\aclrd{\textbf{r}} \,\aclrd{+}\, 1} \vdash \kvd{prev}~e : \tau }
\end{equation*}
%
The rule appears similar to the flat one, but there is an important difference. Because of the
structural nature of the type system, it only increments the required number of values for 
variables that are used in the expression $e$. Annotations of other variables can be left 
unchanged. 

Before looking at the semantics and equational properties of structural coeffect systems, 
we consider bounded variable use, which is an example of structural system that does not
have a flat counterpart.

\begin{example}[Bounded variable reuse]
The structural coeffect algebra for tracking bounded variable use is given by
$(\mathbb{N}, \ast, +, 1, 0, \leq)$
\end{example}

\noindent
Similarly to the structural calculus for data-flow, the calculus for bounded variable reuse
annotates each variable with an integer. However, the integer denotes how many times is the variable 
\emph{accessed} rather than how many \emph{past values} are needed. The resulting type system is 
the one shown in Figure~\ref{fig:applications-struct-live} in Chapter~\ref{ch:applications}.

% ==================================================================================================
%                                              
%      #####  #                                 
%        #    #                                 
%        #    # ##    ###    ###   # ##   #   # 
%        #    ##  #  #   #  #   #  ##  #  #   # 
%        #    #   #  #####  #   #  #      #  ## 
%        #    #   #  #      #   #  #       ## # 
%        #    #   #   ###    ###   #          # 
%                                         #   # 
%                                          ###                                                                         
% ==================================================================================================

\section{Categorical motivation}
\label{sec:struct-semantics}

When introducing structural coeffect systems in Section~\ref{sec:applications-structural}, we 
included a concrete semantics of structural liveness and bounded variable reuse. In this section,
we generalize the examples using the notion of \emph{structural indexed comonad}, which is an 
extension of \emph{indexed comonad} structure. As in the previous chapter, the main aim of this 
section is to motivate and explain the design of the structural coeffect calculus shown in 
Section~\ref{sec:struct-calculus}. The semantics highlights the similarities and differences 
between the two systems.

Most of the differences between flat and structural systems arise from the fact that contexts
in structural coeffect systems are treated as \emph{vectors} rather than sets modelled using 
categorical products, so we start by discussing our treatment of vectors.

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of vectors}

In the flat coeffect calculus, the context is interpreted as a product and so a typing judgement
$\coctx{x_1\!:\tau_1, \ldots, x_n:\tau_n}{\cclrd{r}} \vdash e : \tau$ is interpreted as a morphism 
$\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau$. In this model, we can 
freely transform the value contained in the context modelled using an indexed comonad
$\ctyp{\cclrd{r}}$. For example, the function $\ident{map}_{\cclrd{r}}~\pi_i$ transforms
a context $\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)}$ into a value 
$\ctyp{\cclrd{r}}{\tau_i}$. This changes the carried value without affecting the coeffect $\cclrd{r}$.

The ability to freely transform the variable structure is not desirable in the model of 
structural coeffect systems. Our aim is to guarantee (by construction) that the structure of
the coeffect annotations matches the structure of variables. To achieve this, we model vectors
using a structure distinct from ordinary products which we denote $-\xtimes-$. 
For example, the judgement $\coctx{x_1\!:\tau_1, \ldots, x_n:\tau_n}{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}} \vdash e : \tau$
is modelled as a morphism $\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$.

The operator is a bifunctor, but it is \emph{not} a product in the categorical sense. In particular, 
there is no way to turn $\tau_1 \xtimes \ldots \xtimes \tau_n$ into $\tau_i$ (the structure does 
not have projections) and so there is also no way of turning
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$ into
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{\tau_i}$, which would break the correspondence 
between coeffect annotations and variable structure.

The structure created using $-\xtimes-$ can be manipulated only using operations provided by
the \emph{strucutral indexed comonad}, which operate over variable contexts contained in an 
indexed comonad $\ctyp{\aclrd{\textbf{r}}}$.

In what follows, we model (finite) vectors of length $n$ as $\tau_1 \xtimes \ldots \xtimes \tau_n$.
We assume that the use of the operator can be freely re-associated. If an operation requires an 
input in the form $(\tau_1 \xtimes \ldots \xtimes \tau_i) \xtimes (\tau_{i+1} \xtimes \ldots \xtimes \tau_n)$,
we call it with $(\tau_1 \xtimes \ldots \xtimes \tau_n)$ as an argument and assume that the 
appropriate transformation is inserted.

% --------------------------------------------------------------------------------------------------

\subsection{Indexed comonads, revisited}

The semantics of structural coeffect calculus reuses the definition of \emph{indexed comonad} almost
without a change. The additional structure that is required for context manipulation (merging and 
splitting) is different and is provided by the \emph{structural indexed comonad} structure that we
introduce in this section.

Recall the definition from Section~\ref{sec:flat-semantics-idx}, which defines an indexed comonad 
over a monoid $(\C, \cseq, \cunit)$ as a triple $(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, 
\ident{cobind}_{\cclrd{r}, \cclrd{s}})$. The triple consists of a family of object mappings $\ctyp{\cclrd{r}{}}$,
and two mappings that involve context-dependent morphisms of the form $\ctyp{\cclrd{r}} \tau \rightarrow \tau'$.

In the structural coeffect calculus, we work with morphisms of the form $\ctyp{\cclrd{r}} \tau \rightarrow \tau'$
representing function values (appearing in the language), but also of the form
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$, 
modelling expressions in a context. To capture this, we need to generalize some of the indices from
\emph{coeffect scalars} $\cclrd{r}, \cclrd{s}, \cclrd{t}$ to \emph{coeffect vectors} $\aclrd{r}, \aclrd{s}, \aclrd{t}$.

\begin{definition}
Given a monoid $(\C, \cseq, \cunit)$ with a point-wise extension of the $\cseq$ operator to a vector 
(written as $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$) and an operation lifting scalars to vectors 
$\alift{-}$, an \emph{indexed comonad} over a category $\catc$ is a triple 
$(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, \ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}})$:

\begin{compactitem}
\item $\ctyp{\aclrd{\textbf{r}}}{}$ for all $\aclrd{\textbf{r}} \in \bigcup_{\sclrd{m}\in \sclrd{\mathbb{N}}} \C^{\sclrd{m}}$ is a family of object mappings 
\item $\ident{counit}_{\cunit}$ is a mapping $\ctyp{\alift{\cunit}}{\alpha} \rightarrow \alpha$ 
\item $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$ is a mapping $(\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta) 
  \rightarrow (\ctyp{\cclrd{s}\aseq\aclrd{\textbf{r}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{s}}}{\beta})$
\end{compactitem}
\end{definition}

\noindent
The object mapping $\ctyp{\aclrd{\textbf{r}}}$ is now indexed by a vector rather than by a scalar 
$\ctyp{\cclrd{r}}$ as in the previous chapter. This new definition supersedes the old one, because a 
flat coeffect annotation can be seen as singleton vectors.

The operation $\ident{counit}_{\cunit}$ operates on a singleton-vector. This means that it will always
return a single variable value rather than a vector created using $-\xtimes-$. The $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$
operation is, perhaps surprisingly, indexed by a coeffect vector and a coeffect scalar. This assymmetry
is explained by the fact that the input function ($\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta$)
takes a vector of variables, but always produces just a single value. Thus the resulting function 
also takes a vector of variables, but always returns a context with singleton variable vector.
In other words, $\alpha$ may contain $\xtimes$, but $\beta$ may not, because the coeffect calculus has
no way of constructing values containing $\xtimes$.

% --------------------------------------------------------------------------------------------------

\subsection{Structural indexed comonads}

The flat indexed comonad structure extends indexed comonads with operations 
$\ident{merge}_{\cclrd{r},\cclrd{s}}$ and $\ident{split}_{\cclrd{r},\cclrd{s}}$ 
that combine or split the additional (flat) context and are annotated with the flat 
coeffect operations $\czip$ and $\cpar$, respectively. In the structural version, we use
corresponding operations that operate on variable vectors represented using $\xtimes$ and
are annotated with a tensor $\atimes$ which mirrors the variable structure.

The following definition also includes $\ident{lift}_{\cclrd{r'},\cclrd{r}}$, which is similar as
before and models sub-coeffecting and also $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ which models
duplication of a variable in a context needed for the semantics of contraction:

\begin{definition}
Given a structural coeffect algebra formed by $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$
with operations $\alift{-}$ and $\aseq$, a \emph{structural indexed comonad} is an indexed comonad over 
the monoid $(\C, \cseq, \cunit)$ equipped with families of operations $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$, 
$\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$,
$\ident{dup}_{\cclrd{r}, \cclrd{s}}$ and $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ where:
%
\begin{compactitem}
\item $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta} \rightarrow \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)}$
\item $\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)} \rightarrow \ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta}$
\item $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ is a family of mappings
  $\ctyp{\alift{\cclrd{r} \cpar \cclrd{s}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{r}, \cclrd{s}}}{(\alpha \xtimes \alpha)}$
\item $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ is a family of mappings
  $\ctyp{\alift{\cclrd{r'}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{r}}}{\alpha}$~ for all $\cclrd{r'}, \cclrd{r}$ such that $\cclrd{r}\,\cleq\,\cclrd{r'}$
\end{compactitem}
%
Such that the following equalities hold:
\begin{equation*}
\begin{array}{l}
  \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \equiv \ident{id} \\
  \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \equiv \ident{id} 
\end{array}
\end{equation*}

\end{definition}

\noindent
The operations differ from those of the flat indexed comonad in that the \ident{merge} and 
\ident{split} operations are required to be inverse functions and to preserve the additional 
information about the context. This was not required for the flat system where the operations
could under- or over-approximate. Note that the operations use $\xtimes$ to combine or
split the contained values. This means that they operate on free-variable vectors rather than 
on ordinary products.

The \ident{dup} mapping is a new operation that was not required for a flat calculus. It 
takes a variable context with a single variable annotated with $\cclrd{r}\cpar\cclrd{s}$,
duplicates the value of the variable $\alpha$ and splits the additional context between the two
new variables. In flat calculus, this operation has been expressed using ordinary tuple 
construction, which is not possible here -- the returned context needs to contain a 
two-element vector $\alpha \xtimes \alpha$.

Finally, the \ident{lift} mapping is almost the same as in the flat version. It
operates on a singleton vector, which is equivalent to operating on a scalar as before.
The operation could easily be extended to a vector in a point-wise way, but we keep it simple
and perform sub-coeffecting separately on individual variables.

% --------------------------------------------------------------------------------------------------

\begin{figure*}[!t]
\begin{equation*}
\begin{array}{ll}
 \sem{\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }~\ctx =
   \ident{counit}_{\cunit}~\ctx & (\emph{var})
\\[0.5em]
\sem{\coctx{\Gamma}{\czero} \vdash c_i : \tau }~\ctx =
  \delta~(c_i) & (\emph{const})
\\[0.5em]
\sem{\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\atimes\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}~\ctx = & (\emph{app})\\[-0.25em]
  \hspace{2.5em}
  \begin{array}{l}  
  \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\aclrd{\textbf{r}}, \cclrd{t} \,\aseq\, \aclrd{\textbf{s}}}~\ctx\\[-0.25em]
  \kvd{in}~\sem{\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}~\ctx_1~
      (\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}~\sem{\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }~\ctx_2)
  \end{array}
\\[1.5em]
\sem{\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }~\ctx = \lambda v.& (\emph{abs})\\[-0.25em]
\hspace{2em}\sem{\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  ~(\ident{merge}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}}~(\ctx, v))
\\[0.5em]
\sem{\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \cons \alift{ \czero }} \vdash e : \tau}~\ctx = & (\emph{weak}) \\
  \hspace{2em}
  \kvd{let}~(\ctx_1, \_) = \ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}~\ctx~~\kvd{in}~~
  \sem{\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}~\ctx_1
\\[0.5em]
\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}~\ctx = & (\emph{sub})\\
  \hspace{2em}
  \sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s'}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}~
  (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}, \alift{\cclrd{s'}}, \aclrd{\textbf{q}}}~\ident{lift}_{\cclrd{s}, \cclrd{s'}}~\ctx)
\\[0.5em]
\sem{\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} 
        \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}~\ctx = & (\emph{exch})\\[-0.25em]
  \hspace{2em}  \sem{\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}
     {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\\[-0.25em]
  \hspace{4em}  (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{t},\cclrd{s}}, 
     \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~\ident{swap}_{\cclrd{t},\cclrd{s}}~\ctx)
\\[0.5em]
\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} 
        \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}~\ctx = & (\emph{contr})\\[-0.25em]
  \hspace{2em}  \sem{\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}
      {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\\[-0.25em]
  \hspace{4em}  (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}\,\cpar\,\cclrd{t}}, 
      \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~\ident{dup}_{\cclrd{s}, \cclrd{t}}~\ctx)
\end{array}
\end{equation*}
\\[0.5em]
{\small Assuming the following auxiliary definitions:}
\begin{equation*}
\hspace{-2em}
\begin{array}{l}
 \ident{swap}_{\cclrd{t},\cclrd{s}} ~:~ 
  \ctyp{\alift{\cclrd{t}, \cclrd{s}}}{(\alpha \xtimes \beta)} \rightarrow \ctyp{\alift{\cclrd{s}, \cclrd{t}}}{(\beta \xtimes \alpha)} \\[-0.25em]
\ident{swap}_{\cclrd{t},\cclrd{s}}~\ctx = \\
  \hspace{2em} \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\alift{\cclrd{t}}, \alift{\cclrd{s}}}~\ctx \\[-0.25em]
  \hspace{2em} \kvd{in}~\ident{merge}_{\alift{\cclrd{s}}, \alift{\cclrd{t}}}~(\ctx_2, \ctx_1)
 \\[0.5em]
\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}} ~:~
  (\ctyp{\aclrd{\textbf{s}}}{\beta} \rightarrow \ctyp{\aclrd{\textbf{s'}}}{\beta'}) \rightarrow
    \ctyp{\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s}} \atimes \aclrd{\textbf{t}}}{(\alpha \xtimes \beta \xtimes \gamma)} \rightarrow
    \ctyp{\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s'}} \atimes \aclrd{\textbf{t}}}{(\alpha \xtimes \beta' \xtimes \gamma)}\\[-0.25em]
\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~f~\ctx =\\
  \hspace{2em} \kvd{let}~(\ctx_1, \ctx') = \ident{split}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}\atimes\aclrd{\textbf{t}}}~\ctx \\[-0.25em]
  \hspace{2em} \kvd{let}~(\ctx_2, \ctx_3) = \ident{split}_{\aclrd{\textbf{s}}, \aclrd{\textbf{t}}}~\ctx' \\[-0.25em] 
  \hspace{2em} \kvd{in}~\ident{merge}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s'}}\atimes\aclrd{\textbf{t}}}~
        (\ctx_1, \ident{merge}_{\aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~(f~\ctx_2, \ctx_3))
\end{array}
\end{equation*}
\caption{Categorical semantics of the structural coeffect calculus}
\label{fig:struct-semantics}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of structural caluculus}

The concrete semantics for liveness and bounded variable use shown in 
Sections~\ref{sec:applications-struct-live} and \ref{sec:applications-struct-bll}
suggests that semantics of structural coeffect calculi tend to be more complex 
than semantics of flat coeffect calculi. The complexity comes from the fact
that we need a more expressive representation of the variable context -- \eg~a vector
of optional values -- and that the structural system needs to pass separate variable contexts
to the sub-expressions.

The latter aspect is fully captured by the semantics shown in this section. The
earlier point is left to the concrete notion of structural coeffect. Our model still gives
us the flexibility of defining the concrete representation of variable vectors. We explore
a number of examples in Section~\ref{sec:struct-semantics-examples} and start by looking
at the unified categorical semantics defined in terms of \emph{structural indexed comonads}.

\paragraph{Contexts and functions.}
In the structural coeffect calculus, expressions in context are interpreted as functions taking
a vector (represented using $-\xtimes-$) wrapped in a structure indexed with a vector of annotations
such as $\ctyp{\aclrd{\textbf{r}}}$. Functions take only a single variable as an input and so the
structure is annotated with a scalar, such as $\ctyp{\cclrd{r}}$, which we treat as being equivalent
to a singleton vector annotation $\ctyp{\alift{\cclrd{r}}}$:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} } \vdash e : \tau} 
  &:& \ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau\\
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} &=& \ctyp{\alift{\cclrd{r}}}{\tau_1} \rightarrow \tau_2
\end{array}
\end{equation*}
%
Note that the instances of flat indexed comonad ignored the fact that the variable 
context wrapped in the data structure is a product. This is not generally the case for the 
structural indexed comonads -- the definitions shown in Section~\ref{sec:struct-semantics-examples}
are given specifically for $\ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$
rather than more generally for $\ctyp{\aclrd{\textbf{r}}}{\alpha}$. The need for examining the structure
of the variable context is another reason for using $-\xtimes-$ when interpreting expressions in contexts.

\paragraph{Expressions.}
The semantics of strucutural coeffect calculi is shown in Figure~\ref{fig:struct-semantics}. As in
the previous chapter, the semantics is written in a programming language style using constructs
such as let-binding rather than using a categorical (point-free) notation. As before, the semantics
can be written using standard primitives (currying, uncurrying, function pairing etc.).

The following summarizes how the standard syntax-driven rules work, highlighting the differences
from the flat version:

\begin{itemize}
\item When accessing a variable (\emph{var}), the context now contains \emph{only} the accessed
  variable and so the semantics is just $\ident{counit}_{\cunit}$ without a projection.
  Constants (\emph{const}) are interpreted using a global dictionary $\delta$ as earlier.

\item The semantics of flat function application first duplicated the context so that the same 
  variables can be passed to both sub-expressions. This is no longer needed -- the 
  (\emph{app}) rule splits the variables \emph{including} the additional context into two parts.
  Passing the first context to the semantics of $e_1$ gives us a function
  $\ctyp{\alift{\cclrd{t}}}{\tau_1} \rightarrow \tau_2$. 

  The argument for the function is obtained by applying $\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}$ 
  to the semantics of $e_2$. The resulting function 
  $\ctyp{\cclrd{t}\aseq\aclrd{\textbf{s}}}{(\ldots \xtimes \ldots \xtimes \ldots)} \rightarrow \ctyp{\alift{\cclrd{t}}}{\tau_1}$
  is then called with the latter part of the context to obtain argument for the first function.

\item The semantic of function abstraction (\emph{abs}) is syntactically the same as in the 
  flat version -- the only difference is that we now merge a free-variable context with a 
  singleton vector, both at the level of variable assignments and at the level of coeffect 
  annotations.
\end{itemize}

The semantics for the non-syntax-driven rules performs transformations on the 
free-variable context. Weakening (\emph{weak}) splits the context and ignores the part corresponding
to the removed variable. If we were modelling the semantics in a language with a linear 
type system, this would require an additional operation for ignoring a context annotated with 
$\aclrd{\czero}$.

The remaining rules perform a transformation anywhere inside the free-variable vector. 
To simplify writing the semantics, we define a helper operation 
$\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}$
that splits the variable vector into three parts, transforms the middle part and then 
merges them, using the newly transformed middle part.

The transformations on the middle part are quite simple. The (\emph{sub}) rule 
uses $\ident{lift}_{\cclrd{s}, \cclrd{s'}}$ to discard some of the available additional context;
the (\emph{exch}) rule swaps two single-variable contexts and the (\emph{contr}) rule
uses the $\ident{dup}_{\cclrd{s}, \cclrd{t}}$ operation to duplicate a varaible while 
splitting its additional context.

\paragraph{Properties.}

As in the flat calculus, the main reason for defining the categorical semantics in this chapter
is to provide validation for the design of the calculus. As we show in the next section, the 
discussed examples (liveness, data-flow, bounded variable reuse) form \emph{structural indexed
comonads} and so the calculus captures them correctly if the coeffect annotations in the typing
rules match the indices in the semantics. More formally:

\begin{remark}[Correspondence]
In all of the typing rules of the structural coeffect system, the context annotations $\aclrd{\textbf{r}}$ 
and $\cclrd{s}$ of typing judgements $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ and function types 
$\tau_1 \xrightarrow{\cclrd{s}} \tau_2$  correspond to the indices of mappings $\ctyp{\aclrd{\textbf{r}}}{}$ 
and $\ctyp{\alift{\cclrd{s}}}{}$ in the corresponding semantic function defined 
by $\sem{\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau}$.
\end{remark}
\begin{proof}
By analysis of the semantic rules in Figure~\ref{fig:struct-semantics}.
\end{proof}

\noindent
As in the flat calculus, the primitive operations of the structural indexed comonad are all 
annotated with different operations provided by the coeffect annotations. This means that the
semantics uniquely determines the structure of the typing rules of the strucutral coeffect
calculus. Thanks to the correspondence between the product structure $\atimes$ of the annotations
and the variable context $\xtimes$, the correspondence property also guarantees that variable
values are split correctly, as required by the structural nature of the type system.

% --------------------------------------------------------------------------------------------------

\subsection{Examples of structural indexed comonads}
\label{sec:struct-semantics-examples}

The categorical semantics for structural coeffect calculus can be easily instantiated to give
a semantics of a concrete calculus. In this section, we look at the three examples discussed
throughout this chapter -- structural liveness and data-flow and bounded variable reuse. 
Some aspects of the earlier two examples will be similar to flat versions discussed in
Section~\ref{sec:flat-semantics} -- they are based on the same data structures (option and a 
list, respectively), but the data structures are composed differently. Generally speaking -- 
rather than having a data structure over a product of variables, we now have 
a vector of variables over a specific data structure.

The abstract semantics does not specify how vectors of variables should be represented, so this can
vary in concrete instantiations. In all our examples, we represent a vector of variables as a 
product written using $\times$. To distinguish between products representing vectors and ordinary
products (\eg~a product of contexts returned by \ident{split}), we write vectors using 
$\langle a, \ldots, b \rangle$ rather than using parentheses.

\paragraph{Data-flow.}
It is interesting to note that the semantics of data-flow and bounded variable both keep
a product of multiple values for each variable, so they are both built around an \emph{indexed list}
data structure. However, their \ident{cobind} and \ident{dup} operations work differently. We start
by looking at the structure modelling data-flow computations (variables written in bold face such
as $\mathbf{a}_1$ range over vectors while $a_1$ ranges over individual values).

\begin{example}[Indexed list for data-flow]
The indexed list model of data-flow computations is defined over a structural coeffect
algebra $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$
is indexed by required number of past variables for each individual variable. It is defined
over a vector of variables $\alpha_1 \xtimes \ldots \xtimes \alpha_k$ and it keeps a product
containing a current value followed by $n_i$ past values:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} = 
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{(n_1+1)-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{(n_k+1)-\textnormal{times}}
\end{equation*}
%
The mappings that define the structural indexed comonad include the \ident{split} and \ident{merge}
operations that are shared by the other two examples (discussed below):
%
\begin{equation*}
\begin{array}{l}
\ident{merge}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle} 
  (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle) = \\[-0.25em]
\quad \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle
\\[0.45em]
\ident{split}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle} 
   \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle = \\[-0.25em]
\quad (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle)
\end{array}
\end{equation*}
%
The remaining mappings that are required by structural indexed comonad and capture the
essence of data-flow computations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~~\; f \langle \langle a_{1,m}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,m}, \ldots a_{k,m+{n_k}} \rangle \rangle~\; \rangle\rangle
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{\mathit{max}(m,n)} \rangle \rangle =
   \langle \langle a_1, \ldots, a_m \rangle, \langle a_1, \ldots, a_n \rangle \rangle
\\[0.45em]
\ident{lift}_{k', k} \langle\langle a_0, \ldots, a_{k'} \rangle\rangle = 
  \langle\langle a_0, \ldots, a_k \rangle\rangle \qquad\qquad(\hspace{-0.95em}\textnormal{\footnotesize when}~k\leq k')
\end{array}
\end{equation*}
\end{example}

The definition of the indexed list data structure relies on the fact that the number of annotations
corresponds to the number of variables combined using $-\xtimes-$. It then creates a vector of lists
containing $n_i+1$ values for $i$-\textit{th} variable (the annotation represents the number of 
required \emph{past} values so one more value is required).

The \ident{split} and \ident{merge} operations are defined separately, because they are not specific
to the example. They operate on the top-level vectors of variables (without looking at the 
representation of the variable). This means that we can re-use the same definitions for the following
two examples (with the only difference that $\mathbf{a_i}, \mathbf{b_i}$ will represent options
rather than lists).

The mappings that explain how data-flow computations work are \ident{cobind} (representing sequential
composition) and \ident{dup} (representing context sharing or parallel composition). In \ident{cobind},
we get $k$ vectors corresponding to $k$ variables, each with $m+n_i$ values. The operation calls 
$f$ $m$-times to obtain $m$ past values required as the result of type $\ctyp{\langle m \rangle} \beta$.

The \ident{dup} operation needs to produce a two-varaible context containing $m$ and $n$ values,
respectively, of the input variable. The input provides $\mathit{max}(m, n)$ values, so the definition
is simply a matter of restriction. Finally, \ident{counit} extracts the (only) value of the (only) variable
and \ident{lift} drops additional past values that are not required.

\paragraph{Bounded reuse.}
As mentioned earlier, the semantics of calculus for bounded reuse is also based on the indexed list 
structure. Rather than representing possibly different past values that can be shared (\emph{c.f.}~\ident{dup}), 
the list now represents multiple copies of the same value that cannot be shared.

\begin{example}[Indexed list for bounded reuse]
The indexed list model of bounded variable reuse is defined over a structural coeffect
algebra $(\mathbb{N}, \ast, +, 1, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$ 
is a vector containing $n_i$ values of $i$-\textit{th} variable:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} = 
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{n_1-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{n_k-\textnormal{times}}
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as in \emph{indexed list for data-flow}.
The operations that capture the behaviour of bounded reuse are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{1}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{lift}_{k', k} \langle\langle a_0, \ldots, a_{k'} \rangle\rangle = 
  \langle\langle a_0, \ldots, a_k \rangle\rangle \qquad\qquad(\hspace{-0.95em}\textnormal{\footnotesize when}~k\leq k')
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{m+n} \rangle \rangle = 
\quad \langle \langle a_1, \ldots, a_m \rangle, \langle a_{m+1}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m\ast{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m\ast{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1 - 1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k - 1}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~ f \langle \langle a_{1,(m-1)\ast n_1}, \ldots a_{1,(m-1) \ast n_1} \rangle, \ldots, 
                   \langle a_{k,m\ast n_k - 1}, \ldots a_{k,m\ast n_k - 1} \rangle \rangle~\; \rangle
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{counit} and \ident{lift} operations are defined as previously -- variable access 
extracts the only value of the only variable and sub-coeffecting allows discarding multiple
copies of a value that are not needed.

In the bounded variable reuse system, variable sharing is annotated with $+$ (in contrast with
\textit{max} used in data-flow). The \indent{dup} operation thus splits the $m+n$ available
values between two vectors of length $m$ and $n$, without \emph{sharing} a value. The 
\ident{cobind} operation works similarly -- it splits $m\ast n_i$ available values of each
variable into $m$ vectors containing $n_i$ copies and then calls the $f$ function $m$-times to 
obtain $m$ resulting values without sharing any input value.

\paragraph{Liveness.}
In both data-flow and bounded reuse, the data type is defined as a vector of values obtained
by applying some parameterized data type (indexed list) to types of individual variables. We can
generalize this pattern and define $\ctyp{\langle l_1, \ldots, l_n \rangle}$ in terms of 
$D^{l}$ where $D^{l}$ is a simpler indexed data type. For liveness, the definition lets us 
reuse the mapping used when defining the semantics of flat liveness. However, we cannot fully
define the semantics of the structural version in terms of the flat version -- the 
\ident{cobind} operation is different and we need to provide the \ident{dup} operation.

\begin{example}[Structural indexed option]
Given a structural coeffect algebra formed by $(\{ \ident{L}, \ident{D} \}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$
and the indexed option data type $D^l$, such that $D^{\ident{D}}\alpha = 1$ and $D^{\ident{L}}\alpha=\alpha$,
the data type for structural indexed option comonad is:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} = 
  D^{n_1} \alpha_1 \times \ldots \times D^{n_k} \alpha_k
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as earlier. The remaining operations
model variable liveness as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{cobind}_{\ident{L}, \langle l_1, \ldots, l_n \rangle}~f~\langle a_1, \ldots, a_n \rangle = \langle f~\langle a_1, \ldots, a_n \rangle \rangle \\[-0.25em]
\ident{cobind}_{\ident{D}, \langle \ident{D}, \ldots, \ident{D} \rangle}~f~\langle (), \ldots, () \rangle = \langle \ident{D} \rangle
\\[0.5em]
\hspace{-0.5em}
\begin{array}{lll}
~\\[-0.85em]
\ident{dup}_{\ident{D}, \ident{D}} \langle () \rangle &\narrow{=}& \langle (), () \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{D}} \langle a \rangle &\narrow{=}& \langle a, () \rangle \\[-0.25em]
\ident{dup}_{\ident{D}, \ident{L}} \langle a \rangle &\narrow{=}& \langle (), a \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{L}} \langle a \rangle &\narrow{=}& \langle a, a \rangle 
\end{array}
\qquad\quad
\begin{array}{lll}
\ident{counit}_{\ident{L}}~\langle a \rangle &\narrow{=}& a
\\[0.45em]
\ident{lift}_{\ident{L}, \ident{L}} \langle a \rangle &\narrow{=}& \langle a \rangle \\[-0.25em]
\ident{lift}_{\ident{L}, \ident{D}} \langle a \rangle &\narrow{=}& \langle () \rangle \\[-0.25em]
\ident{lift}_{\ident{D}, \ident{D}} \langle () \rangle &\narrow{=}& \langle () \rangle \\[-0.25em]
\end{array}
\end{array}
\end{equation*}
\end{example}

\noindent
When the expected result of the \ident{cobind} operation is dead (second case), the operation can
ignore all inputs and directly return the unit value $()$. Otherwise, it passes the vector of 
input variables to $f$ as-is -- no matter whether the individual values are live or dead. The
\ident{L} annotation is a unit with respect to $\cap$ and so the annotations expected by $f$ are
the same as those required by the result of \ident{cobind}.

The \ident{dup} operation resembles with the flat version of \ident{split} -- this is expected as
duplication in the flat calculus is performed by first duplicating the variable context (using 
\ident{map}) and then applying \ident{split}. Here, the duplication returns a pair which may or
may not contain value, depending on the annotations.

Finally, \ident{counit} extracts a value which is always present as guaranteed by the type
$\ctyp{\langle \ident{L} \rangle}{\alpha} \rightarrow \alpha$. The lifting operation models 
sub-coeffecting which may drop an available value (second case) or behaves as identity.


% ==================================================================================================
%                                                                   
%       ###                  #                    #       #          
%      #   #                 #                    #                  
%      #      #   #  # ##   ####    ###    ###   ####    ##     ###  
%       ###   #   #  ##  #   #         #  #   #   #       #    #   # 
%          #  #  ##  #   #   #      ####  #       #       #    #     
%      #   #   ## #  #   #   #  #  #   #  #   #   #  #    #    #   # 
%       ###       #  #   #    ##    ####   ###     ##    ###    ###  
%             #   #                                                  
%              ###                                                   
%
% ==================================================================================================

\section{Equational theory}
\label{sec:struct-syntax}

??

\newpage



% ==================================================================================================
%
%                               ##      
%      ####                     ##      
%        ##                     ##      
%        ##   ##   ##  ## ###   ##  ##  
%        ##   ##   ##  ###  ##  ## ##   
%    ##  ##   ##   ##  ##   ##  ####    
%    ##  ##   ##  ###  ##   ##  ## ##   
%     ####     ### ##  ##   ##  ##  ##  
%                                      
% ==================================================================================================

\newcommand{\ctimes}{ \hat{\times} }
\newcommand{\cdupl}[0]{ \Delta } %{ \Upsilon }

\newcommand{\csprd}[0]{ \times }
\newcommand{\csvop}[0]{ \vee }
\newcommand{\cmerge}[0]{ \cpar }
\newcommand{\csplit}[0]{ \czip }

\newcommand{\clflt}{$\lambda_{\textnormal{\sffamily Cf}}$}
\newcommand{\clstr}{$\lambda_{\textnormal{\sffamily Cs}}$}
\newcommand{\rulest}[1]{\textsf{\clstr\small{-T#1}}}


\subsection{Properties of reductions}
\label{sec:structural-metatheory}
Similarly to the flat version, the \clstr~calculus is defined abstractly. We cannot define its
operational meaning, because that will differ for every concrete application. For example,
when tracking array accesses, variables are interpreted as arrays and $\pastval{a}{n}$ denotes
access to a specified element. 

Just like previously, we can state general properties of the reductions. As the syntax of expressions
is the same for \clstr~as for \clflt, the substitution and reduction $\twoheadrightarrow_\beta$ 
are also the same and can be found in Figure~\ref{fig:flat-substred}.

The structural coeffect calculus \clstr~associates information with individual variables. This means
that when an expression requires certain context, we know from what scope it comes -- the
context must be provided by a scope that defines the associated variable, which is either a
lambda abstraction or global scope. This distinguishes the structural system from the flat system
where context could have been provided by any scope and the lambda rule allowed arbitrary 
splitting of context requirements between the two scopes (or declaration and caller site).

\paragraph{Internalized substitution.}
Before looking at properties of the evaluation, we consider let binding, which can be 
viewed as internalized substitution. The typing rule \rulest{let} can be derived from 
application and abstraction as follows. 

\begin{lemma}[Definition of let binding]
If $\ctyp{r}{\Gamma} \vdash (\lambda x.e_2)~e_1 : \tau_2$
then $\ctyp{r}{\Gamma} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2$.
\end{lemma}
\begin{proof}
The premises and conclusions of a typing derivation of $(\lambda x.e_2)~e_1$
correspond with the typing rule \rulest{let}:
\begin{equation*}
\inference[]
  {\inference
    {\ctyp{r \csprd s}{(\Gamma_1, v:\tau_1)} \vdash e_2 : \tau_2 & v \notin \Gamma_1}
    {\ctyp{r}{\Gamma_1} \vdash \lambda v.e_2 : \ctyp{s}{\tau_1} \rightarrow \tau_2 } &
   \ctyp{t}{\Gamma_2} \vdash e_1 : \tau_1 }
  {\ctyp{r \csprd (s \csvop t)}{(\Gamma_1, \Gamma_2)} \vdash (\lambda v.e_2)~e_1 : \tau_2}\qedhere
\end{equation*}
\end{proof}

The term $e_2$ which is substituted in $e_1$ is checked in a different variable
and coeffect context $\ctyp{t}{\Gamma_2}$. This is common in sub-structural systems where
a variable cannot be freely used repeatedly. The context $\Gamma_2$ is used in place of 
the variable that we are substituting for. The let binding captures substitution for a 
specific variable (the context is of a form $\ctyp{r \csprd s}{\Gamma, v:\tau}$).
For a general substitution, we need to define the notion of context with a hole.

\newcommand{\chole}[4]{\ctyp{#1}{#2}[#3|#4]}
\paragraph{Substitution and holes.}
In \clstr, the structure of the variable context is not a set, but a tree. When substituting
for a variable, we need to replace the variable in the context with the context of the
substituted expression. In general, this can occur anywhere in the tree. To formulate the
statement, we define contexts with holes, written $\Delta[-]$. Note that there is a hole
in the free variable context and in a corresponding part of the coeffect tag:

\begin{equation*}
\begin{array}{rcl}
\Delta[-] &::=& \ctyp{1}{()} \\
       & \sep & \ctyp{r}{(x:\tau)}\\
       & \sep & \ctyp{-}{(-)} \\
       & \sep & \ctyp{r_1 \csprd r_2}{(\Gamma_1, \Gamma_2)}\quad~~(\textnormal{where}~\ctyp{r_i}{\Gamma_i} \in \Delta[-])\\
\end{array}
\end{equation*}
%
Assuming we have a context with hole $\ctyp{r}{\Gamma} \in \Delta[-]$, the hole filling 
operation $\chole{r}{\Gamma}{r'}{\Gamma'}$ fills the hole in the variable context with 
$\Gamma'$ and the corresponding coeffect tag hole with $r'$. The operation is defined in 
Figure~\ref{fig:structural-hole-fill}. Using contexts with holes, we can now formulate the
general substitution lemma for \clstr.

\begin{figure}

\begin{equation*}
\begin{array}{rcl}
                              \chole{1}{()}{r'}{\Gamma'} &=& \ctyp{1}{()}\\
                        \chole{r}{(x:\tau)}{r'}{\Gamma'} &=& \ctyp{r}{(x:\tau)}\\
                             \chole{-}{(-)}{r'}{\Gamma'} &=& \ctyp{r'}{\Gamma'}\\
\chole{r_1 \csprd r_2}{(\Gamma_1, \Gamma_2)}{r'}{\Gamma'} &=& \ctyp{r_1' \csprd r_2'}{(\Gamma_1', \Gamma_2')}\\
&\multicolumn{2}{l} {
  \textnormal{where}~~\ctyp{r_i'}{\Gamma_i'} = \chole{r_i}{\Gamma_i}{r'}{\Gamma'}
}
\end{array}
\end{equation*}
\caption{The definition of hole filling operation for $\Delta[-]$}
\label{fig:structural-hole-fill}
\vspace{-2em}
\end{figure}

\begin{lemma}[Substitution Lemma]
\label{thm:structural-subst}
If $\chole{r}{\Gamma}{R}{v:\tau'} \vdash e : \tau$ and $\ctyp{S}{\Gamma'} \vdash e' : \tau'$
then $\chole{r}{\Gamma}{R \csvop S}{\Gamma'} \vdash \subst{e}{v}{e'} : \tau$.
\end{lemma} 
\begin{proof}
Proceeds by rule induction over $\vdash$ using the properties of structural coeffect tag structure
$(S, \csvop, 0, \csprd, 1)$ (see Appendix~\ref{app:structural-substitution}).
\end{proof}

\begin{theorem}[Subject reduction]
\label{thm:structural-reduction}
If $\ctyp{r}{\Gamma} \vdash e_1 : \tau$ and $e_1 \twoheadrightarrow_\beta e_2$ then 
$\ctyp{r}{\Gamma} \vdash e_2 : \tau$.
\end{theorem}
\begin{proof}
Direct consequence of Lemma~\ref{thm:structural-subst} (see Appendix~\ref{app:structural-reduction}).
\end{proof}

\paragraph{Local soundness and completeness.}
As with the previous calculus, we want to guarantee that the introduction and
elimination rules (\rulest{fun} and \rulest{app}) are appropriately strong. 
This can be done by showing \emph{local soundness} and \emph{local completeness},
which correspond to $\beta$-reduction and $\eta$-expansion. Former is a special
case of subject reduction and the latter is proved by a simple derivation:
%
\begin{theorem}[Local soundness]
If $\ctyp{r}{\Gamma} \vdash (\lambda x.e_2)~e_1 : \tau$ then
$\ctyp{r}{\Gamma} \vdash \subst{e_2}{x}{e_1} : \tau$.
\end{theorem}
\begin{proof}
Special case of subject reduction (Theorem~\ref{thm:structural-reduction}).
\end{proof}
%
\begin{theorem}[Local completeness]
If $\ctyp{r}{\Gamma} \vdash f : \ctyp{s}{\tau_1} \rightarrow \tau_2$ then
$\ctyp{r}{\Gamma} \vdash \lambda x.f x : \ctyp{s}{\tau_1} \rightarrow \tau_2$.
\end{theorem}
\begin{proof} The property is proved by the following typing derivation:
%
\begin{equation*}
\inference
  {\inference
     {\ctyp{r}{\Gamma} \vdash f : \ctyp{s}{\tau_1} \rightarrow \tau_2 &
      \ctyp{0}{(x:\tau_1)} \vdash x : \tau_1 }
     {\ctyp{r \csprd (s \csvop 0)}{(\Gamma, x:\tau_1)} \vdash f~x : \tau_2}}
  {\ctyp{r}{\Gamma} \vdash \lambda x.f x : \ctyp{s}{\tau_1} \rightarrow \tau_2 }
\qedhere
\end{equation*}
\end{proof}
%
In the last step, we use the \emph{lower bound} property of structural coeffect tag, which
guarantees that $s\csvop0 = s$. Recall that in \clflt, the typing derivation for
$\lambda x.f x$ required for local completeness was not the only possible derivation.
In the last step, it was possible to split the coeffect tag arbitrarily between the 
context and the function type. 

In the \clstr~calculus, this is not, in general, the case. The $\csprd$ operator is not required 
to be associative and to have units and so a unique splitting may exist.  For example, if we
define $\csprd$ as the operator of a \emph{free magma}, then it is invertible and for a given
$t$, there are unique $r$ and $s$ such that $t = r \csprd s$. However, if the $\csprd$ operation 
has additional properties, then there may be other possible derivation.

% ==================================================================================================

\section{Examples of structural coeffects}

\subsection{Example: Liveness analysis}
\label{sec:structural-neededness}

\subsection{Example: Data-flow (revisited) }
\label{sec:structural-tainting}

\todo{Also, consider additional language features that we consider for flat coeffects
  (mainly recursion and possibly conditionals)}
  
\section{Conclusions}

\todo{ (...) }

\chapter{The structural coeffect calculus}
\label{ch:structural}

In Chapter~\ref{ch:applications}, we discussed two notions of context. Context-aware programming
languages that capture whole-context properties were generalized by the \emph{flat coeffect
calculus} in Chapters~\ref{ch:flat} and \ref{ch:semantics}. Here, we consider per-variable
contextual properties and we introduce the \emph{structural coeffect calculus}.

The flat coeffect system captures a number of interesting use-cases. For some of those (liveness
and dataflow), flat coeffects provide only imprecise approximation (for example, marking the whole
context as live rather than marking individual variables). Dataflow and liveness (but not implicit
parameters) can be also seen as per-variable properties. For those, structural coeffect systems
capture more precise information about the context. However, we also look at other applications
that arise from the work on substructural logics discussed in Section~\ref{sec:path-logic}.

We mirror the development for flat coeffect calculus and develop a small calculus with a type system
that captures per-variable contextual properties. We outline its categorical semantics and use it as
a basis for a translation that turns well-typed programs in context-aware languages into well-typed
programs in a simple target functional language. We prove syntactic safety for a sample target
language, showing that ``well-typed context-aware programs do not go wrong''.

\paragraph{Chapter structure and contributions}
\begin{itemize}
\item We present a \emph{structural coeffect calculus} as a type system that is parameterized
  by a \emph{structural coeffect algebra} (Section~\ref{sec:struct-calculus}). We show how the
  system captures pre-variable liveness and dataflow information, as well as a calculus for bounded
  reuse (checking how many times is a variable accessed).

\item We present a syntax-directed version of the calculus that is used to obtain unique typing
  derivation for programs in structural coeffect calculus (Section~\ref{sec:struct-unique}).
  Unlike in flat systems, the procedure for choosing a unique typing derivation is common to all
  structural systems.

\item We discuss the equational theory of the calculus. We show that type-preservation
  holds for all examples of the structural calculus we consider, for both call-by-name and call-by-value
  reductions (Section~\ref{sec:struct-syntax}) and we
  explore a number of extensions to the minimal calculus based on $\lambda$-calculus,
  including subcoeffecting and let binding (Section~\ref{sec:structural-exts}).

\item We extend the indexed comonads introduced in the previous chapter to \emph{structural indexed
  comonads} and use them to provide the semantics of structural coeffect calculus
  (Section~\ref{sec:struct-semantics}). As with the flat version, the theory serves as a motivation
  for syntactic translational semantics.

\item We give a \emph{translational semantics} (Section~\ref{sec:struct-transl}) that translates
  programs from the structural coeffect calculus into a simple functional language with
  uninterpreted comonadically-inspired primitives. We give concrete operational semantics for the
  target language for one of our sample languages and show that well-typed programs, produced by
  translation from the coeffect calculus do not go wrong.
\end{itemize}


% ==================================================================================================
%
%    ###
%     #  #    # ##### #####   ####  #####  #    #  ####  ##### #  ####  #    #
%     #  ##   #   #   #    # #    # #    # #    # #    #   #   # #    # ##   #
%     #  # #  #   #   #    # #    # #    # #    # #        #   # #    # # #  #
%     #  #  # #   #   #####  #    # #    # #    # #        #   # #    # #  # #
%     #  #   ##   #   #   #  #    # #    # #    # #    #   #   # #    # #   ##
%    ### #    #   #   #    #  ####  #####   ####   ####    #   #  ####  #    #
%
% ==================================================================================================

\section{Introduction}
\label{sec:structural-intro}

Compared to Chapter~\ref{ch:flat}, the structural coeffect calculi we consider are more homogeneous
and so finding the common pattern is easier. However, the systems are more complicated as they need
to keep annotations attached to individual variables and thus require explicit structural rules.
Before looking at the system, we briefly consider the most important related work.

%---------------------------------------------------------------------------------------------------

\subsection{Related work}

In the previous chapter, we discussed the correspondence between coeffects and effects (and
between comonads and monads). As noted in Section~\ref{sec:applications-strucutre-vec}, the
$\lambda$-calculus is asymmetric in that an expression has multiple inputs (variables in the
context), but just a single result (the resulting value). So, while there is only one notion of
monadic effect system, there are two separate notions of coeffect system - one that keeps coeffect
annotations per-environment and one that keeps coeffect annotations per-variable.

The work in this chapter is related to substructural type systems \cite{substruct-attpl-intro}.
Substructural systems remove some or all of \emph{weakening}, \emph{contraction} and
\emph{exchange} rules. In contrast, our systems keep all three structural rules, but use them to
manipulate the coeffect annotations in a way that matches the variable manipulations.

Our work follows the ``language semantics'' style in that we provide semantics to the terms of
ordinary $\lambda$-calculus. By contrast the closely related work on Contextual Modal
Type Theory (CMTT) \cite{logic-cmtt} follows the meta-language style. CMTT extends the terms and
types of a language with constructs for explicitly manipulating the context. Variables
of type $A[\Psi]$ denote a value of type $A$ that requires context $\Psi$. In CMTT,
$A[\Psi]$ is a first-class type, while structural coeffect systems do not expose coeffect
annotations as stand-alone types (indexed comonads only appear in the semantics).

Our structural coeffect systems annotate the whole variable context with a \emph{vector} of annotations.
For example, a context with variables $x$ and $y$ annotated with $\cclrd{s}$ and $\cclrd{t}$,
respectively is written as $\coctx{x\!:\!\tau_1,y\!:\!\tau_2}{\alift{\cclrd{s},\cclrd{t}}}$.
A benefit of this approach is that the typing judgements have the same structure as those of the
flat coeffect calculus. As discussed in Section~\ref{sec:further-unified}, this makes it possible to unify
the two systems.


% =================================================================================================
%
%     #####
%    #     #   ##   #       ####  #    # #      #    #  ####
%    #        #  #  #      #    # #    # #      #    # #
%    #       #    # #      #      #    # #      #    #  ####
%    #       ###### #      #      #    # #      #    #      #
%    #     # #    # #      #    # #    # #      #    # #    #
%     #####  #    # ######  ####   ####  ######  ####   ####
%
% =================================================================================================

\section{Structural coeffect calculus}
\label{sec:struct-calculus}

In the structural coeffect calculus, functions are annotated with a primitive (scalar) coeffect
annotations. A vector of variables forming the free-variable context is annotated with a vector of
coeffect annotations. These annotations differ for various coeffect calculi; their properties are
captured by the definition of \emph{structural coeffect scalar} below. The scalar annotations can
be \eg~integers (how many past values we need) or values of a two-point lattice specifying whether
a variable is live or not. The expressions and types of the structural coeffect calculus are defined
as follows:
%
\begin{equation*}
\begin{array}{rcl}
e &::=& x \sep n \sep \lambda x:\tau.e \sep e_1~e_2 \sep \kvd{let}~x = e_1~\kvd{in}~e_2\\
\tau &::=& \ident{num} \sep \tau_1 \xrightarrow{\cclrd{r}} \tau_2
\end{array}
\end{equation*}
%
The expressions and types of structural coeffect calculus are similar to those of the flat coeffect
calculus with two differences. First, we omit the \kvd{let} construct in the core language. In
structural coeffects, let binding can be defined as a derived rule using abstraction and application
(Section~\ref{sec:structural-exts-let}). Second, the coeffect annotations $\cclrd{r}, \cclrd{s}, \cclrd{t}$
on function type now range over values of a \emph{structural coeffect scalar}.

% -------------------------------------------------------------------------------------------------

\subsection{Structural coeffect algebra}

The \emph{structural coeffect scalar} structure is similar to that of \emph{flat coeffect algebra}
with the exception that it drops the $\czip$ operation. It only provides a monoid $(\C, \cseq, \cunit)$
modelling sequential composition of computations and a monoid $(\C, \cpar, \czero)$ representing
pointwise composition, as well as the $\cleq$ relation.

\begin{definition}
\label{def:structural-scalar}
A \emph{\cclrd{structural coeffect scalar}} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ is a set
$\C$ together with elements $\cunit, \czero \in \C$, binary operations $\cseq, \cpar$ such that
$(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids and a binary relation $\cleq$ such
that $(\C, \cleq)$ is a pre-order. That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}
\\
\end{array}
\end{equation*}
%
In addition, the following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
\end{definition}


\noindent
The structural coeffect scalar structure resembles flat coeffect algebra, but it differs in two important ways:
%
\begin{itemize}
\item The $\cpar$ operation of structural coeffect scalar is not required to be idempotent. In structural
  systems, we can track individual variable accesses and not requiring idempotence allows interesting
  systems such as that for bounded reuse (Section~\ref{sec:struct-semantics-examples}).

\item In the flat coeffect calculus, we used the $\czip$ operation to merge the annotations of contexts
  available from the declaration site and the call site or, in the syntactic reading, to split the
  context demands. Structural systems \emph{append vectors} of annotations instead of
  \emph{merging annotations} and so $\czip$ is no longer needed.
\end{itemize}

\noindent
In the structural coeffect calculus, the scalar coeffect structure is supplemented by a vector
structure. The vector structure is used to manipulate vectors of coeffect scalars attached to a
variable context. The required structure is captured by the following definition.

\begin{definition}
A \emph{\aclrd{structural coeffect algebra}} is formed by a structural coeffect scalar
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ equipped with the following additional structures:

\begin{itemize}
\vspace{-0.3em}
\item Coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$, ranging over
  structural coeffect scalars indexed by vector lengths $\sclrd{m}, \sclrd{n} \in \sclrd{\mathbb{N}}$.

\vspace{-0.3em}
\item A family of operations (indexed by the vector length) that construct a vector from scalars
  $\alift{-}_{\sclrd{n}} : \C \times \ldots \times \C \rightarrow \C^{\sclrd{n}}$
  and an operation that returns the vector length such that
  $\alen{\aclrd{\textbf{r}}} = \sclrd{n}$ for $\aclrd{\textbf{r}} : \C^{\sclrd{n}}$

\vspace{-0.3em}
\item A pointwise extension of the $\cseq$ operator written as $\cclrd{t} \,\aseq\, \aclrd{\textbf{s}}$
  such that\\ $\cclrd{t} \,\aseq\, \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} =
    \alift{\cclrd{t} \,\cseq\,\cclrd{r_1}, \ldots, \cclrd{t} \,\cseq\,\cclrd{r_n}}$.

\vspace{-0.3em}
\item An indexed tensor product $\atimes_{\sclrd{n},\sclrd{m}} : \C^{\sclrd{n}} \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{n}+\sclrd{m}}$
  that is bijective and is used in both directions -- for vector concatenation and for splitting --
  which is defined as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}
     \atimes_{\sclrd{n}, \sclrd{m}} \alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}
   = \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}, \cclrd{s_1}, \ldots, \cclrd{s_m}}$
\end{itemize}
\end{definition}

\noindent
The fact that the tensor product $\atimes_{\sclrd{n},\sclrd{m}}$ is indexed by the lengths
of the two vectors means that we can use it unambiguously for concatenating two vectors and
splitting of a vector, provided that the lengths of the resulting vectors are known.
In the following text, we usually omit the indices and write just
$\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s}}$, because the lengths of the coeffect vectors
can be determined from the lengths of the matching free variable context vectors.
More generally, we could see the coeffect annotations as \emph{containers}
\cite{types-containers}. This approach is used in Section~\ref{sec:further-unified} to unify flat
and structural systems.

%---------------------------------------------------------------------------------------------------

\subsection{Structural coeffect types}
\label{sec:struct-calculus-types}

The type system for the structural coeffect calculus is shown in Figure~\ref{fig:struct-types}.
It is similar to substructural type systems
\cite{substruct-attpl-intro} in how it handles free variable contexts. In the type system for
flat coeffects (Section~\ref{sec:flat-calculus-types}), the (\emph{var}) rule implicitly allows
\emph{weakening} and \emph{exchange} by ignoring other variables in the context and
(\emph{app}) implicitly allows \emph{contraction} by passing the same context to both sub-expressions.

In the structural system, this is made explicit by adding \emph{structural rules}.
While substructural type systems usually remove some of the rules, we keep all three and
use them to track how variables are used. This is done by manipulating the coeffect annotations
in parallel with manipulating the variable contexts. As in substructural type systems, (\emph{app})
checks the types of sub-expressions in disjoint parts of the free variable contexts and
(\emph{var}) requires the context to contain exactly one variable. The typing rule for let binding in
structural coeffects is a derived rule and we discuss it later in Section~\ref{sec:structural-exts-let}.

~

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
{\small a.) Syntax-driven typing rules:}
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  { }
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\atimes\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x:\tau_1.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Structural rules for context manipulation:}
\begin{equation*}
\tyrule{weak}
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}
\end{equation*}
\begin{equation*}
\tyrule{exch}
  {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
\begin{array}{l}
 \xlen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}
\begin{equation*}
\hspace{2.5em}
\tyrule{contr}
  {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}
~
\begin{array}{l}
 \xlen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}

\figcaption{Type system for the structural coeffect calculus}
\label{fig:struct-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\paragraph{Variable contexts.}
In Chapter~\ref{ch:flat}, the free variable context $\Gamma$ was treated as a set. In the type
system for the structural coeffect calculus, the variable context is treated as a vector, with
an additional condition that a cannot appear multiple times. We also write $\xlen{-}$ for the
length of the vector:
%
\begin{equation*}
\begin{array}{l}
 \Gamma = \langle x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n \rangle \qquad \textnormal{such that}~~\forall i, j ~.~ i \neq j \implies x_i \neq x_j\\
 \xlen{\langle x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n \rangle} = n
\end{array}
\end{equation*}
%
We use the usual notation $x_1\!:\!\tau_1, \ldots, x_1\!:\!\tau_1 \vdash e : \tau$ for
typing judgements, but the free variable context should be understood as a vector.
The notation $\Gamma_1, \Gamma_2$ is used for concatenation of vectors of variables. That is,
given a context $\Gamma_1 = \langle x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n \rangle $ and a context
$\Gamma_2 = \langle x_{n+1}\!:\!\tau_{n+1}, \ldots, x_m\!:\!\tau_m \rangle $ then
$\Gamma_1, \Gamma_2 = \langle x_1\!:\!\tau_1, \ldots, x_m\!:\!\tau_m \rangle$.

In the typing rules, free variable contexts are annotated with vectors of structural coeffect scalars,
written as $\coctx{x_1\!:\tau_1,\ldtos,x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}$.
Meta-variables ranging over coeffect vectors are written as $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$
(using bold face and colour to distinguish them from scalar meta-variables) and the length of a
coeffect vector is written as $\alen{\aclrd{\textbf{r}}}$.

\paragraph{Syntax-driven rules.}
The syntax-driven rules of the type system are shown in Figure~\ref{fig:struct-types} (a).
The variable access rule (\emph{var}) annotates the corresponding variable as being accessed
using $\cunit$. As in substructural systems, the free variable context contains
\emph{only} the accessed variable. Other variables can be introduced using explicit weakening.
Constants (\emph{const}) are type checked in an empty variable context, which is annotated with
an empty vector of coeffect annotations.

The (\emph{abs}) rule assumes that the free variable context of the body can be split into
a potentially empty \emph{declaration site} and a singleton context containing the bound
variable. The corresponding splitting is performed on the coeffect vector, uniquely associating
the annotation $\cclrd{s}$ with the bound variable $x$. This form of typing rule obviates the
ambiguity in splitting of context demands present in the flat coeffect systems.

In (\emph{app}), the sub-expressions $e_1$ and $e_2$ use free variable contexts $\Gamma_1, \Gamma_2$
with coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}$, respectively. The function
value is annotated with a coeffect scalar $\cclrd{t}$.
The coeffect annotation of the composed expression is obtained by combining the annotations
associated with variables in $\Gamma_1$ and $\Gamma_2$. Variables in $\Gamma_1$ are only
used to obtain the function value, resulting in coeffects $\aclrd{\textbf{r}}$. The
variables in $\Gamma_2$ are used to obtain the argument value, which is then sequentially
composed with the function, resulting in $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$.

\paragraph{Structural rules.}
These are shown in Figure~\ref{fig:struct-types} (b). The three structural rules are not
syntax-directed and allow different transformation of the free variable context. They correspond
to the transformations known as \emph{weakening}, \emph{exchange} and \emph{contraction}
from substructural systems.

Rule (\emph{weak}) allows adding a variable to the context, extending the coeffect
vector with $\czero$ to mark it as unused, (\emph{exch}) provides a way to rearrange variables
in the context, performing the same reordering on the coeffect vector. Finally recall that
variables in the free variable context are required to be \emph{unique}. The (\emph{contr}) rule
allows re-using a variable. We can type check sub-expressions using two separate variables and
then unify them using substitution. The resulting variable is annotated with $\cpar$ and it
is the only place in the structural coeffect system where context demands are combined
(semantically, this is where the available context is shared).

%---------------------------------------------------------------------------------------------------

\subsection{Understanding structural coeffects}

The type system for structural coeffects appears more complicated when compared to the flat
version, but it is in many ways simpler -- it removes the ambiguity arising from the use
of $\czip$ in lambda abstraction and, as discussed in Section~\ref{sec:struct-syntax}, has
a more desirable equational theory. By contrast, the flat system allows certain interesting
use cases that \emph{rely} on the flexibility of $\czip$ in lambda abstraction (such as implicit
parameters), that cannot be expressed in the structural system.

In flat systems, lambda abstraction splits context demands using $\czip$ and application
combines them using $\cpar$. In the structural version, both of these are replaced with $\atimes$.
The $\czip$ operation is not needed, but note the use of $\cpar$ in the (\emph{contr}) rule.

This suggests that $\czip$ and $\cpar$ serve two roles in flat coeffects. First, they are used
as over-approximations and under-approximations of $\atimes$. This is demonstrated by the
(\emph{approximation}) requirement introduced in Section~\ref{sec:flat-syntax-cbv}, which requires that
$\cclrd{r}\,\czip\,\cclrd{t}\;\cleq\;\cclrd{r}\,\cpar\,\cclrd{t}$. Semantically, flat abstraction
combines two values representing the available context, potentially discarding parts of it
(under-approximation), while flat application splits the available context (a single value),
potentially duplicating parts of it (over-approxi\-mation)\footnote{Because of this duality, earlier
version of coeffect systems \cite{coeffects-icalp13} used $\wedge$ and $\vee$.}.

Secondly, the operator $\cpar$ is used when the semantics passes a given context to multiple
sub-expressions. In flat systems, the context is shared in (\emph{app}) and the additional
(\emph{pair}) rule for constructing tuple values, because the sub-expressions may share variables.
In structural systems, the sharing is isolated into an explicit contraction rule.

%---------------------------------------------------------------------------------------------------

\subsection{Examples of structural coeffects}

The structural coeffect calculus above can be instantiated to obtain the 3 structural coeffect calculi
presented in Section~\ref{sec:applications-structural}. Two of them -- structural dataflow and
structural liveness provide a more precise tracking of properties that can be tracked using
flat systems. Formally, any flat coeffect algebra can be turned into a structural coeffect scalar
(by dropping the $\czip$ operator). This is useful for liveness and dataflow, but it does not yield
a practically useful system for the flat algebra coeffect for implicit parameters.

On the other hand, some of the structural systems do not have a flat equivalent, typically
because there is no appropriate $\czip$ operator that could be added to form the flat coeffect
scalar. This is the case, for example, for the system tracking bounded variable use
(Example~\ref{ex:structural-ex-bll}).

\begin{example}[Structural liveness]
The structural coeffect scalar for liveness is formed by
$(\mathcal{L}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$, where $\mathcal{L}=\{ \ident{L}, \ident{D} \}$ is
the same two-point lattice as in the flat version, that is $\ident{D} \sqsubseteq \ident{L}$
with a join $\sqcup$ and a meet $\sqcap$.
\end{example}

\begin{example}[Structural dataflow]
In dataflow, context is annotated with natural numbers and the structural coeffect scalar is formed
by $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$.
\end{example}

\noindent
These two examples have both flat and structural versions. For them, obtaining the structural
coeffect algebra is easy. As shown by the examples above, we simply omit the $\czip$ operation. The
laws required by a structural coeffect algebra are the same as those required by the flat version
and so the above definitions are both valid. Similar construction can be used for the
\emph{optimized dataflow} example from Section~\ref{sec:flat-calculus-examples}.

It is important to note that this gives us a systems with \emph{different} properties.
Information is now tracked per-variable rather than for entire contexts. For dataflow,
we also need to adapt the typing rule for the \kvd{prev} construct. Here, we write $\aclrd{+}$
for a pointwise extension of the $+$ operator, such that
$\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} \aclrd{+} k = \alift{\cclrd{r_1} + k, \ldots, \cclrd{r_n} + k}$.
%
\begin{equation*}
\tyrule{prev}
  { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau }
  { \coctx{\Gamma}{\aclrd{\textbf{r}} \,\aclrd{+}\, 1} \vdash \kvd{prev}~e : \tau }
\end{equation*}
%
The rule appears similar to the flat one, but there is an important difference. Because of the
structural nature of the type system, it only increments the required number of values for
variables that are actually used in the expression $e$, whereas in the flat coeffect system the rule
incremented the annotation for the whole context. Thanks to the structural nature of the system,
annotations of variables that do not appear in the expression $e$ can be left unchanged.

Before looking at properties of structural coeffect systems,
we consider a system for tracking bounded variable use, which is an example of structural system
that does not have a flat counterpart.

\begin{example}[Bounded variable reuse]
\label{ex:structural-ex-bll}
The structural coeffect algebra for tracking bounded variable use is given by
$(\mathbb{N}, \ast, +, 1, 0, \leq)$
\end{example}

\noindent
Similarly to the structural calculus for dataflow, the calculus for bounded variable reuse
annotates each variable with an integer. However, the integer now denotes how many times is the variable
\emph{accessed} rather than how many \emph{past values} are needed. The resulting type system is
the one shown in Figure~\ref{fig:applications-struct-live} in Chapter~\ref{ch:applications}.



% ==================================================================================================
%
%       #
%      # #   #    # #####   ####  # #    # # ##### #   #
%     #   #  ##  ## #    # #    # # #    # #   #    # #
%    #     # # ## # #####  #      # #    # #   #     #
%    ####### #    # #    # #  ### # #    # #   #     #
%    #     # #    # #    # #    # # #    # #   #     #
%    #     # #    # #####   ####  #  ####  #   #     #
%
% ==================================================================================================


\begin{figure}[t]
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  { }
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 \\
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e_1~e_2 : \tau_2}
\quad \coctx{\Gamma}{\aclrd{\textbf{c}}} = \ident{mergevars}(\cclrd{t}, \coctx{\Gamma_1}{\aclrd{\textbf{r}}}, \coctx{\Gamma_2}{\aclrd{\textbf{s}}})
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma_1}{\aclrd{\textbf{t}}} \vdash e : \tau_2}
  {\coctx{\Gamma_2}{\aclrd{\textbf{r}}} \vdash \lambda x:\tau_1.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\quad (\coctx{\Gamma_2}{\aclrd{\textbf{r}}}), \cclrd{s} = \ident{findvar}_{x,\tau_1}(\coctx{\Gamma_1}{\aclrd{\textbf{t}}})
\end{equation*}

\vspace{1em}
\begin{equation*}
\begin{array}{l}
\ident{findvar}_{x,\tau}(\coctx{\Gamma}{\aclrd{\textbf{t}}})~=~(\coctx{\Gamma_1,\Gamma_2}{\aclrd{\textbf{t}_1} \atimes \aclrd{\textbf{t}_2}}), \cclrd{s} \quad \textnormal{where} \\
\qquad \xlen{\Gamma_1} = \alen{\aclrd{\textbf{t}_1}}~\textnormal{and}~\xlen{\Gamma_2} = \alen{\aclrd{\textbf{t}_2}} \\[-0.25em]
\qquad x\!:\!\tau \in \Gamma~\textnormal{and}~
  \coctx{\Gamma}{\aclrd{\textbf{t}}} = \coctx{\Gamma_1, x\!:\!\tau, \Gamma_2}{\aclrd{\textbf{t}_1} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{t}_2}}
\\[0.5em]
\ident{findvar}_{x,\tau}(\coctx{\Gamma}{\aclrd{\textbf{t}}})~=~ (\coctx{\Gamma}{\aclrd{\textbf{t}}}), \czero \qquad (\textnormal{otherwise})
\\[1em]
\ident{mergevars}(\cclrd{t}, \coctx{\Gamma_1}{\aclrd{\textbf{r}}}, \coctx{\Gamma_2}{\aclrd{\textbf{s}}})~=~
  \coctx{\Gamma'_1, \Gamma'_2, \Gamma}{\aclrd{\textbf{r}'}\atimes(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}'}) \atimes \aclrd{\textbf{c}} } \quad \textnormal{where}\\
\qquad \coctx{\Gamma_1}{\aclrd{\textbf{r}}} =
    \coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}} \\
\qquad \coctx{\Gamma_2}{\aclrd{\textbf{s}}} =
    \coctx{y_1\!:\!\tau'_1, \ldots, y_m\!:\!\tau'_n}{\alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}} \\
\qquad \coctx{\Gamma}{\aclrd{\textbf{c}}} =
    \coctx{z_1\!:\!\tau''_1, \ldots, z_k\!:\!\tau''_k}{\alift{\cclrd{c_1}, \ldots, \cclrd{c_k}}} \\[-0.25em]
\qquad\quad \textnormal{such that}~\forall l\in \{1 \ldots k\}~\exists i,j.~(z_l\!:\!\tau''_l = x_i\!:\!\tau_i = y_j\!:\!\tau'_j) \\[-0.25em]
\qquad\qquad \textnormal{and}~\cclrd{c_l} = \cclrd{r_i} \;\cpar\; (\cclrd{t} \,\cseq\, \cclrd{s_j}) \\
\qquad \coctx{\Gamma_1}{\aclrd{\textbf{r}}} =
    \coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}
    ~\textnormal{such that}~x_i\!:\!\tau_i \notin \Gamma \\
\qquad \coctx{\Gamma_2}{\aclrd{\textbf{s}}} =
    \coctx{y_1\!:\!\tau'_1, \ldots, y_m\!:\!\tau'_n}{\alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}}
    ~\textnormal{such that}~y_i\!:\!\tau'_i \notin \Gamma \\
\end{array}
\end{equation*}

\figcaption{Syntax-directed type system for the structural coeffect calculus}
\label{fig:struct-syntax-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\section{Choosing a unique typing}
\label{sec:struct-unique}

In the structural coeffect calculus, the lambda abstraction rule does not introduce ambiguity
in the typing. This is in contrast with flat coeffect systems (most importantly, the one for
implicit parameters), where lambda abstraction allowed arbitrary splitting of context demands.
In structural coeffect systems, the context demands placed on the call site (attached to
the function type) are those of the bound variable.

However, the type system for structural coeffect calculus in Figure~\ref{fig:struct-types}
introduces another kind of ambiguity due to the fact that non-syntax-directed structural rules
can be applied repeatedly and in arbitrary order. As with the semantics for flat coeffect calculus
in Chapter~\ref{ch:semantics}, we define the semantics of the structural coeffect calculus relative to
a \emph{typing derivation} and so the meaning of a program depends on the typing derivation chosen.
In this section, we specify how to choose the desired \emph{unique} typing derivation, following
the example of flat coeffect calculi as discussed in Section~\ref{sec:flat-unique}.

%---------------------------------------------------------------------------------------------------

\subsection{Syntax-directed type system}

In order to choose a unique typing derivation, we follow the example of substructural type systems
\cite{substruct-attpl-intro} and introduce a syntax-directed version of the type system.
This replaces the non-syntax-directed rules for weakening, exchange and contraction with
more complexity in the rules where contexts are combined  (\emph{app}) and variables removed (\emph{abs}).

Given a typing derivation in the deterministic syntax-directed type system, we then choose a
typing derivation in the original type system that uniquely specifies how to apply weakening,
contraction and exchange. The algorithm given in Proposition~\ref{thm:struct-unique-transl}
inserts only the necessary structural rules to rearrange variable context into the shape
required by the assumptions.

The syntax-directed version of the type system is shown in Figure~\ref{fig:struct-syntax-types}.
The typing rules for variables (\emph{var}) and constants (\emph{const}) are the same as before.
The two interesting rules are lambda abstraction and application.

\paragraph{Lambda abstraction.}
In the lambda abstraction (\emph{abs}) rule in Figure~\ref{fig:struct-types}, we assume that the bound
variable is the last variable of the context. In the syntax-directed system, we do not make the
same assumption. Instead, we use an auxiliary function $\ident{findvar}_{x,\tau}$ that takes a typing
context $\coctx{\Gamma}{\aclrd{\textbf{t}}}$ and returns a context with the variable $x$ removed
together with the coeffect originally attached to the variable. The $\ident{findvar}_x$ function is
defined by two disjoint cases. The case when the variable $x$ is not present in the context
corresponds to the (\emph{weak}) structural rule.

\paragraph{Function application.} The (\emph{app}) rule in Figure~\ref{fig:struct-types}
assumes that the variable contexts of the two sub-expressions can be merged. This requires that they
contain disjoint variables, which can be always obtained by exchange and contraction. In the
syntax-driven system, we merge coeffects of shared variables explicitly. This is done in the
\ident{mergevars} function.

As with $\ident{findvar}_{x,\tau}$, the \ident{mergevars} function is fully deterministic.
It returns context consisting of three parts. Parts $\Gamma_1$
and $\Gamma_2$ represent variables that appear only in the first or the second context; part
$\Gamma$ contains common variables. The coeffect annotations corresponding to $\Gamma_1$ are
the original annotations from $\aclrd{\textbf{r}}$; the coeffects corresponding to $\Gamma_2$
are composed with the coeffect of the function value $\cclrd{t} \,\aseq\, \aclrd{\textbf{s}'}$
as in the original (\emph{app}) rule. Finally, for shared variables, the coeffect is
obtained by point-wise composition (as in contraction) of the coeffect for the two contexts
$\cclrd{r_i} \;\cpar\; (\cclrd{t} \,\cseq\, \cclrd{s_j})$. The first coeffect corresponds to the
context demands in the sub-expression $e_1$ and the second coeffect corresponds to the
function argument $e_2$ sequentially composed with the coeffect $\cclrd{t}$ of the function
(as in ordinary application rule).


%---------------------------------------------------------------------------------------------------

\subsection{Properties}

The syntax-directed type checking presented in the previous section gives a unique typing derivation
that can be automatically turned into one of the valid typing derivations of the original type system
presented in Figure~\ref{fig:struct-types}. This gives us a unique typing derivation for the
structural coeffect calculus. As with the unique typing derivation for the flat coeffect system,
the chosen typing derivation is used to give semantics of terms of the structural coeffect calculus.
We also note that a well-typed program in the original type system has a typing derivation in the
syntax-driven version.

As when discussing uniqueness of typing for flat coeffect systems (Section~\ref{sec:flat-unique}),
we first give an inversion lemma (Lemma~\ref{thm:struct-invert}) and then prove
uniqueness of typing (Theorem~\ref{thm:struct-unique}).

\begin{lemma}[Inversion lemma for syntax-directed structural coeffects]
\label{thm:struct-invert}
For the type system defined in Figure~\ref{fig:struct-syntax-types}:
%
\begin{enumerate}
\raggedright
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash x : \tau$ then $\Gamma = x\!:\!\tau$ and $\aclrd{\textbf{c}} = \alift{\cunit}$.
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash n : \tau$ then $\Gamma = ()$ and $\tau = \ident{num}$ and $\aclrd{\textbf{c}} = \alift{}$.
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e_1~e_2 : \tau_2$
  then there is some $\Gamma_1, \Gamma_2, \tau_1$ and some $\cclrd{t}, \aclrd{\textbf{r}}, \aclrd{\textbf{s}}$ \\ such that
  $\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2$ and
  $\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1$ and also
  $\coctx{\Gamma}{\aclrd{\textbf{c}}} = \ident{mergevars}(\cclrd{t}, \coctx{\Gamma_1}{\aclrd{\textbf{r}}}, \coctx{\Gamma_2}{\aclrd{\textbf{s}}})$.
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash \lambda x\!:\!\tau_1.e : \tau$
  then there is some $\Gamma', \tau_2$ and some $\cclrd{s}, \aclrd{\textbf{t}}$ such that
  $\coctx{\Gamma'}{\aclrd{\textbf{t}}} \vdash e : \tau_2$ and
  $\tau = \tau_1 \xrightarrow{\cclrd{s}} \tau_2$ and also
  $(\coctx{\Gamma}{\aclrd{\textbf{c}}}), \tau_1, \cclrd{s} = \ident{findvar}_x(\coctx{\Gamma_1}{\aclrd{\textbf{t}}})$.
\end{enumerate}
\end{lemma}
\begin{proof}
Follows from the individual rules given in Figure~\ref{fig:struct-syntax-types}.
\end{proof}

\begin{theorem}[Uniqueness of syntax-directed structural coeffects]
\label{thm:struct-unique}
In the syntax-directed type system for structural coeffects defined in Figure~\ref{fig:struct-syntax-types},
when $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ and
$\coctx{\Gamma}{\aclrd{\textbf{r}'}} \vdash e : \tau'$ then $\tau = \tau'$ and $\aclrd{\textbf{r}} = \aclrd{\textbf{r}'}$.
\end{theorem}
\begin{proof}
Suppose that (A) $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e : \tau$ and
(B) $\coctx{\Gamma}{\aclrd{\textbf{c}'}} \vdash e : \tau'$. We show by induction over the typing
derivation of $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e : \tau$ that $\tau = \tau'$ and $\aclrd{\textbf{c}}=\aclrd{\textbf{c}'}$.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{abs}): $e = \lambda x\!:\!\tau_1.e_1$. Then $\tau = \tau_1 \xrightarrow{\cclrd{c}} \tau_2$
  for some $\tau_2$ and $\coctx{\Gamma'}{\aclrd{\textbf{t}}} \vdash e : \tau_2$ for some $\Gamma', \aclrd{\textbf{t}}$
  and also $(\coctx{\Gamma}{\aclrd{\textbf{c}}}), \tau_1, \cclrd{s} = \ident{findvar}_x(\coctx{\Gamma'}{\aclrd{\textbf{t}}})$.
  By case (4) of Lemma~\ref{thm:struct-invert}, the final rule of the derivation (B) must
  have also been (\emph{abs}) and this derivation has a sub-derivation with a conclusion
  ${\coctx{\Gamma}{\aclrd{\textbf{c}'}} \vdash e : \tau_2'}$.
  By the induction hypothesis $\tau_2 = \tau_2'$ and $\aclrd{\textbf{c}}=\aclrd{\textbf{c}'}$ and therefore
  also so $\tau = \tau'$. Although $\ident{findvar}_x$ is a relation, it allows only one possible result
  (because the type of the bound variable matches the type annotation).

\vspace{0.5em}\noindent\hangindent=0.7cm
Cases (\emph{var}), (\emph{const}) are direct consequence of Lemma~\ref{thm:struct-invert}.

\vspace{0.5em}\noindent\hangindent=0.7cm
Case (\emph{app}) similarly to (\emph{abs}).
\end{proof}

\noindent
As noted earlier, unique typing derivations obtained using the syntax-directed type system
given in Figure~\ref{fig:struct-syntax-types} can be automatically turned into typing derivations
of the original (non-syntax-directed) structural coeffect type system in Figure~\ref{fig:struct-types}.
Unlike in the flat coeffect system, this does not determine how context demands are split
(as this is done deterministically to match the variable bindings), but it specifies how are
the structural rules (weakening, exchange and contraction) applied.
The following proposition provides the details.

\begin{proposition}[Choosing a unique typing derivation]
\label{thm:struct-unique-transl}
  If $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ (using the rules in
  Figure~\ref{fig:struct-syntax-types}) then there is a unique typing derivation
  using the typing rules from Figure~\ref{fig:struct-types} with a conclusion
  $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ obtained by induction over
  the original typing derivation as follows:

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{var}), (\emph{const}): The resulting typing derivation uses the corresponding
  rule of the non-syntax-directed type system.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{abs}): Take the typing derivation for the sub-expression $e$. If the variable $x$
  does not appear in $\Gamma_1$, apply (\emph{weak}) followed by (\emph{abs}). Otherwise
  assume $\Gamma_1 = x_1\!:\!\tau_1,\ldots,x_n\!:\!\tau_n$ and $x=x_i$. Apply (\emph{exch})
  repeatedly on variables $x_i, x_{i+1}$ then $x_i, x_{i+2}$ and so on until it is applied
  on $x_i, x_n$. At this point, $x_i$ is the last variable of the vector and we can apply
  (\emph{abs}). This produces the same consequent as the one in the original typing derivation.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{app}): Take the typing derivations for the sub-expressions $e_1$ and $e_2$ in
  free-variable contexts $\Gamma_1$ and $\Gamma_2$. For each variable $x$ that appears in both
  $\Gamma_1$ and $\Gamma_2$, rename the variable to a fresh name $x'$ in $e_1$ and to another
  fresh name $x''$ in $e_2$ and their typing derivations. Now we have disjoint contexts and
  we can apply (\emph{app}) on the target derivations.

\vspace{0.5em}\noindent\hspace{0.6cm}\hangindent=0.6cm
  Next, apply (\emph{exch}) until $x'$ and $x''$ are last two variables in the vector and apply
  (\emph{contr}), renaming both $x'$ and $x''$ to the original name $x$. Repeat this step for
  all variables that were renamed. The resulting variable context is $\Gamma$ and the resulting
  coeffect annotation is the same as in the original typing derivation.
\end{proposition}



% ==================================================================================================
%
%    #######
%    #       #    # ##### ###### #    #  ####  #  ####  #    #  ####
%    #        #  #    #   #      ##   # #      # #    # ##   # #
%    #####     ##     #   #####  # #  #  ####  # #    # # #  #  ####
%    #         ##     #   #      #  # #      # # #    # #  # #      #
%    #        #  #    #   #      #   ## #    # # #    # #   ## #    #
%    ####### #    #   #   ###### #    #  ####  #  ####  #    #  ####
%
% ==================================================================================================

\section{Syntactic properties and extensions}
\label{sec:structural-exts}

When discussing the structural coeffect calculus in Section~\ref{sec:struct-calculus}, we
considered a language with variables, constants, application and abstraction. This lets us focus
on the key properties of the coeffects, but it neglects a number of practical concerns.
In this section, we extend the language with let binding and subcoeffecting. This is useful
in practice, but it also shows other interesting aspects of the theory. Additional extensions that
make the coeffect language practically useful are given by the implementation in Chapter~\ref{ch:impl}.

\subsection{Let binding}
\label{sec:structural-exts-let}

In the flat coeffect calculus, we included a special typing rule for let binding. As discussed in
Section~\ref{sec:flat-exts-let}, this provides a more precise typing than the rule derived from
abstraction and application, because it removes the ambiguity introduced by abstraction. For the
structural coeffect system, the typing rule for let binding can be treated as a derived rule.
The following shows the structural typing for \kvd{let}:

\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\; \aclrd{\textbf{s}}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
%
Thanks to the structural nature of the calculus, the coeffect $\cclrd{t}$ that is associated with
the variable $x$ is uniquely determined (as in function abstraction). It is then sequentially
composed with the coeffects attached to the variables that actually appear in the sub-expression
$e_1$.

\begin{proposition}[Let binding]
\label{thm:structural-letbinding}
In a structural coeffect calculus, the typing of $\kvd{let}~x=e_1~\kvd{in}~e_2$ can be
seen as a derived rule, \ie~its typing is equivalent to the typing of the expression
$(\lambda x.e_2)~e_1$.
\end{proposition}
\begin{proof}
Consider the following typing derivation for $(\lambda x.e_2)~e_1$. Note that
in the last step, we apply (\emph{exch}) repeatedly to swap $\Gamma_1$ and $\Gamma_2$.
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1\vspace{-1.6em}\end{array} &
    \inference
      { \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2 }
      { \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash \lambda x.e_2 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2} \vspace{0.2em} }
  { \inference
      { \coctx{\Gamma_2, \Gamma_1}{\aclrd{\textbf{s}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{r}})} \vdash (\lambda x.e_2)~e_1 : \tau_2 }
      { \coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\;  \aclrd{\textbf{s}} } \vdash (\lambda x.e_2)~e_1 : \tau_2 } }
\end{equation*}

\noindent
The assumptions and conclusions match those of the (\emph{let}) rule.
\end{proof}


\subsection{Subcoeffecting}
\label{sec:structural-exts-sub}

When discussing the flat coeffect calculus in Section~\ref{sec:flat-calculus-algebra}, we noted
that the $\cleq$ operation for \emph{flat coeffect algebra} can be defined in terms of $\cpar$
as follows:
%
\begin{equation*}
\cclrd{r} \;\cleq\; \cclrd{s} \;\Longleftrightarrow\; \cclrd{r} \;\cpar\; \cclrd{s} \;=\; \cclrd{s}
\end{equation*}
%
This is not the case for the \emph{structural coeffect scalar} structure. For example, in the
calculus for tracking bounded reuse, the $\cpar$ operator is defined as $+$ (on integers) and
$\cleq$ is just $\leq$ and so the above equivalence does not hold. For this reason, we included
$\cleq$ as an explicit part of both of the structures.

The subcoeffecting rule is not syntax directed and we did not include it in the core calculus
in order to keep the discussion about choosing unique derivation in Section~\ref{sec:struct-unique}
focused on the key problem -- structural rules. The subcoeffecting rule for structural coeffect
calculus looks as follows:
%
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s'}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
(\cclrd{s'} \cleq \cclrd{s})
\end{equation*}
%
The sub-coeffecting is applied on individual variables rather than on the whole context, but it
could be easily extended to a relation on vectors $\aclrd{\leq}$. Subtyping on functions can be
defined in exactly the same way as for the flat coeffect calculus (Section~\ref{sec:flat-exts-sub}),
because functions are annotated with a (single) coeffect scalar. It is worth noting that
subcoeffecting is needed in Lemma~\ref{thm:structural-substitution} (discussed in the next
section) when performing a substitution for a variable in an expression that does not contain the
substituted variable.



% ==================================================================================================
%
%     #####
%    #     # #   # #    # #####   ##    ####  ##### #  ####
%    #        # #  ##   #   #    #  #  #    #   #   # #    #
%     #####    #   # #  #   #   #    # #        #   # #
%          #   #   #  # #   #   ###### #        #   # #
%    #     #   #   #   ##   #   #    # #    #   #   # #    #
%     #####    #   #    #   #   #    #  ####    #   #  ####
%
% ==================================================================================================

\section{Syntactic equational theory}
\label{sec:struct-syntax}

The properties of the structural coeffect algebra, together with two additional weak conditions,
guarantee that certain equational properties on terms hold in all instances of the structural
coeffect calculus that we consider in this thesis. In this section, we look at these common
properties. In Section~\ref{sec:struct-syntax-intro}, we first briefly compare equational theory
for flat coeffects (Section~\ref{sec:flat-syntax}) and structural coeffects (Section~\ref{sec:struct-syntactic-thms}).

\subsection{From flat coeffects to structural coeffects}
\label{sec:struct-syntax-intro}

When discussing syntactic reductions for the flat calculus,
we noted that call-by-name reduction does not, in general, preserve typing  for all
flat coeffect calculi. In the structural coeffect calculus, $\beta$-reduction and also $\eta$-expansion
preserve typing for all instances of the calculus. Using the terminology of Pfenning and Davies
\cite{logic-modal-reconstruction}, the structural coeffect calculus satisfies both the \emph{local
soundness} and the \emph{local completeness} properties.

\paragraph{Substitution for flat coeffects (recap).}
The less obvious (\emph{top-pointed}) variant of the substitution lemma for flat coeffects
(Lemma~\ref{thm:cbn-substitution-bot}) required all operations of the flat coeffect algebra
to coincide. This enables substitution to preserve the type of expressions, because all
additional demands arising as the result of the substitution can be associated with the
declaration context. For example, consider the following example where Haskell-style implicit parameter
$\ident{?offset}$ is substituted for the variable $y$:
%
\begin{equation*}
\begin{array}{rclcll}
 \coctx{y\!:\!\ident{int}}{\cclrd{\emptyset}} &\narrow{\vdash}& \lambda x.y + \ident{?total} &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ \{ \ident{?total} \} }} \ident{int} & \qquad(\textit{before}) \\
\coctx{()}{\cclrd{ \{ \ident{?offset} \} }} &\narrow{\vdash}& \lambda x.\ident{?offset} + \ident{?total} &\narrow{:}&
  \ident{int} \xrightarrow{\cclrd{ \{ \ident{?total} \} }} \ident{int} & \qquad(\textit{after})
\end{array}
\end{equation*}
%
The typing judgement obtained in (\emph{after}) preserves the type of the expression (function
value) from the original typing (\emph{before}). This is possible thanks to the non-determinism
involved in the typing rule for lambda abstraction -- as all operators of the flat coeffect
algebra used here are $\cup$, we can place the additional requirement on the outer context.
Note that this is not the \emph{only} possible typing, but it is a \emph{permissible} typing.

Here, the flat coeffect calculus gives us typing with limited \emph{precision}, but
enough \emph{flexibility} to prove the substitution lemma.

\paragraph{Substitution for structural coeffects.}
By contrast, the substitution lemma (Lemma~\ref{thm:structural-substitution},
page~\pageref{thm:structural-substitution}) for structural coeffects can be proven because
structural coeffect systems provide enough \emph{precision} to identify exactly with which
variable should a context requirement be associated.

The following example shows a situation similar to the previous one. Here, we use
structural dataflow calculus (writing $\kvd{prev}~e$ to obtain previous value of the
expression $e$) and we substitute $w+z$ for $y$:
%
\begin{equation*}
\begin{array}{rclcll}
 \coctx{y\!:\!\ident{int}}{ \alift{\cclrd{2}} }
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~y) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & (\textit{before}) \\
\coctx{w\!:\!\ident{int}, z\!:\!\ident{int}}{\cclrd{2}\aclrd{\ast}\alift{\cclrd{1},\cclrd{1}}}
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~(w+z))) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & (\textit{after}) \\
\coctx{w\!:\!\ident{int}, z\!:\!\ident{int}}{\alift{\cclrd{2},\cclrd{2}}}
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~(w+z))) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & (\textit{equivalently})
\end{array}
\end{equation*}
%
The type of the function does not change, because the structural type system associates
the annotation $\cclrd{1}$ with the bound variable $x$ and the substitution does not
affect how the variable $x$ is used.

The other aspect demonstrated in the example is how the coeffect of the substituted
variable affects the free-variable context of the substituted expression. Here, the
original variable $y$ is annotated with $\cclrd{2}$ and we substitute it for an
expression $w+z$ with free variables $w,z$ annotated with $\alift{\cclrd{1}, \cclrd{1}}$.
The substitution applies the operation $\aclrd{\ast}$ (which stands for the sequential
composition $\aseq$ from the structural coeffect algebra) to the annotation of the new context --
in the above example the coeffect $\cclrd{2}\cclrd{\ast}\alift{\cclrd{1}, \cclrd{1}}$ (\emph{after}) is
equivalent to the coeffect $\alift{\cclrd{2}, \cclrd{2}}$ (\emph{equivalently}).

\subsection{Holes and substitution lemma}
\label{sec:struct-syntactic-subst}

As demonstrated in the previous section, reduction (and substitution) in the structural coeffect
calculus may need to replace a \emph{single} variable with a \emph{vector} of variables.
More importantly, because the system uses explicit contraction, we may also need to substitute
for multiple variables in the variable context at the same time.

Consider the expression $\lambda x.x+x$. It is type-checked by type-checking $x_1 + x_2$,
contracting $x_1$ and $x_2$ and then applying lambda abstraction. During the reduction of
$(\lambda x.x+x)~(y+z)$ we need to substitute $y_1+z_1$ for $x_1$ and $y_2+z_2$ for $x_2$.
This is similar to substitution lemma in other structural variants of $\lambda$-calculus,
such as the bunched typing system \cite{substruct-bunched}. To express the substitution
lemma later in this section, we follow the example of bunched type system and define the
notion of a \emph{context with holes}. A context with holes is a context such as
$\coctx{x_1\!:\!\tau_1, \ldots, x_k\!:\!\tau_k}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_k}}}$,
where some of the variable typings $x_i\!:\!\tau_i$ and corresponding coeffects $\cclrd{r_i}$
are replaced by \emph{holes} written as $\coctx{-}{-}$.

\begin{definition}[Context with holes]
We write $\Delta[\,\coctx{-}{-}\,]_n$ for a \emph{context with $n$ holes} (in addition to some
number of variables). A context with holes is defined inductively over the number of holes:
%
\begin{equation*}
\begin{array}{lcl}
 \Delta[\,\coctx{-}{-}\,]_n &\narrow{:=}&
   \coctx{-, \Gamma}{\alift{-} \atimes \aclrd{\textbf{s}} }
   \qquad \textnormal{where}~\coctx{\Gamma}{\aclrd{\textbf{s}}} \in \Delta[\,\coctx{-}{-}\,]_{n-1} \\
 \Delta[\,\coctx{-}{-}\,]_n &\narrow{:=}&
   \coctx{x\!:\!\tau, \Gamma}{\alift{\cclrd{r}} \atimes \aclrd{\textbf{s}} }
   \qquad \textnormal{where}~\coctx{\Gamma}{\aclrd{\textbf{s}}} \in \Delta[\,\coctx{-}{-}\,]_n \\
 \Delta[\,\coctx{-}{-}\,]_0 &\narrow{:=}&
   \coctx{()}{\alift{}}
\end{array}
\end{equation*}
\end{definition}

\noindent
A context with $n$ holes may either start with a hole, followed by a context with $n-1$ holes, or it may
start with a variable followed by a context with $n$ holes. Note that the definition ensures that
the locations of variable holes correspond to the locations of coeffect annotation holes. Given a context
with holes, we can fill the holes with other contexts using the \emph{hole filling} operation and
obtain an ordinary coeffect-annotated context.

\begin{definition}[Hole filling] Given a context with $n$ holes $\coctx{\Delta}{\textbf{s}} \in
\Delta[\,\coctx{-}{-}\,]_n$, the hole filling operation written as
$\coctx{\Delta}{\textbf{s}}[\,\coctx{\Gamma_1}{\aclrd{\mathbf{r_1}}} \,|\, \ldots \,|\, \coctx{\Gamma_n}{\aclrd{\mathbf{r_n}}} \,]$,
replaces holes by the specified variables and corresponding coeffect annotations and is defined as:
%
\begin{equation*}
\begin{array}{rcl}
 \coctx{-, \Delta}{\alift{-} \atimes \textbf{s} }
    ~[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] &\narrow{=}&
      \coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}_1} \atimes \aclrd{\textbf{r}_2} } \\
 && \qquad \hspace{-9.3em} \textnormal{where}~\coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} =
     \coctx{\Delta}{\textbf{s}}[\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,]
\\[0.5em]
 \coctx{x_1\!:\!\tau, \Delta}{\alift{\cclrd{r_1}} \atimes \textbf{s} }
    ~[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] &\narrow{=}&
      \coctx{x_1\!:\!\tau, \Gamma_2}{\alift{\cclrd{r_1}} \atimes \aclrd{\textbf{r}_2} } \\
 && \qquad \hspace{-9.3em} \textnormal{where}~\coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} =
     \coctx{\Delta}{\textbf{s}}[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,]
\\[0.5em]
 \coctx{()}{\alift{}}~[~] &\narrow{=}& \coctx{()}{\alift{}}
\end{array}
\end{equation*}
\end{definition}

\noindent
When we substitute an expression with coeffects $\aclrd{\textbf{t}}$ (associated with variables $\Gamma$)
for a variable that has coeffects $\cclrd{s}$, the resulting coeffects of $\Gamma$ need to
combine $\aclrd{\textbf{t}}$ and $\cclrd{s}$. Unlike in the flat coeffect systems, the structural
substitution does not require all coeffect algebra operations to coincide and so the combination
is more interesting than in the bottom-pointed substitution for flat coeffects, where it used
the only available operator (Lemma~\ref{thm:cbn-substitution-bot}).

\begin{lemma}[Multi-nary substitution]
\label{thm:structural-substitution}
In a structural coeffect calculus with a \emph{structural coeffect scalar} such that
$\cclrd{r}\,\cleq\,\cclrd{r'} \, \Rightarrow \, \forall\cclrd{s}.\;(\cclrd{r}\,\cseq\,\cclrd{s})\;\cleq\;(\cclrd{r'}\,\cseq\,\cclrd{s})$
and also $\czero \;\cleq\; (\czero\,\cseq\,\cclrd{r})$,
given an expression with multiple holes that are filled by variables $x_1\!:\!\tau_1,\ldots,x_n\!:\!\tau_n$ with coeffects $\cclrd{s_1},\ldots,\cclrd{s_n}$:
%
\begin{equation*}
\coctx{\Gamma}{\aclrd{\textbf{r}}}~[\,\coctx{x_1\!:\!\tau_1}{\alift{\cclrd{s_1}}} \,|\, \ldots \,|\,
  \coctx{x_k\!:\!\tau_k}{\alift{\cclrd{s_k}}}\,] \vdash e_r : \tau_r
\end{equation*}
%
and a expressions $e_i$ with free-variable contexts $\Gamma_i$ annotated with $\aclrd{\mathbf{t_i}}$:
%
\begin{equation*}
\coctx{\Gamma_1}{\aclrd{\textbf{t}_1}} \vdash e_1 : \tau_1
\quad \ldots \quad
\coctx{\Gamma_k}{\aclrd{\textbf{t}_k}} \vdash e_k : \tau_k
\end{equation*}
%
substituting the expressions $e_i$ for variables $x_i$ results in an expression with a context
where the original holes are filled by contexts $\Gamma_i$ with coeffects $\cclrd{s_i} \aseq \aclrd{\mathbf{t_i}}$:
%
\begin{equation*}
\coctx{\Gamma}{\aclrd{\textbf{r}}}~[\,\coctx{\Gamma_1}{\cclrd{s_1}\aseq\,\aclrd{\textbf{t}_1}} \,|\, \ldots \,|\,
  \coctx{\Gamma_k}{\cclrd{s_k}\aseq\,\aclrd{\textbf{t}_k}}\,] \vdash \subst{\subst{e_r}{x_1}{e_1}\ldots}{x_k}{e_k} : \tau_r
\end{equation*}
\end{lemma}
\begin{proof}
By induction over $\vdash$, using the multi-nary aspect of the substitution
in the proof of the contraction case (see Appendix~\ref{sec:appendix-struct-cbn}).
\end{proof}

The Lemma~\ref{thm:structural-substitution} has two additional requirements on the structural coeffect
scalar that are similar to those of the substitution lemma for bottom-pointed flat coeffect systems
(Lemma~\ref{thm:cbn-substitution-bot}). Those two conditions are satisfied for all our examples
(it would be reasonable to require them for \emph{all} structural coeffect scalars, but we prefer
to keep the original definition more general). The two requirements are needed in the proof
for substitution for subcoeffecting rule (discussed in Section~\ref{sec:structural-exts-sub}) and
for weakening, respectively.

% --------------------------------------------------------------------------------------------------

\subsection{Reduction and expansion}
\label{sec:struct-syntactic-thms}

In the Chapter~\ref{ch:flat}, we discussed call-by-value separately from call-by-name, because the
proof of call-by-value substitution has fewer prerequisites. In this section, we consider full
$\beta$-reduction, which encompasses both call-by-value and call-by-name. We also show that
$\eta$-expansion preserves the types. Both of the properties hold for a system with any
structural coeffect algebra that satisfies the additional weak requirements given in Lemma~\ref{thm:structural-substitution}.

\paragraph{Reduction theorem.} In a full $\beta$-reduction,
written as $\rightarrow_\beta$, we can replace the redex $(\lambda x.e_2)~e_1$ by the
expression $\subst{e_r}{x}{e_s}$ anywhere inside a term. The subject reduction theorem
guarantees that this does not change the type of the term.

\begin{theorem}[Type preservation]
In a structural coeffect system with subcoeffecting (Section~\ref{sec:structural-exts-sub})
and a structural coeffect algebra formed by
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq$ that
satisfies the requirements of Lemma~\ref{thm:structural-substitution},
it holds that if $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$
and $e \rightarrow_{\beta} e'$ using the full $\beta$-reduction then
$\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
Consider the typing derivation for the redex $(\lambda x.e_r)\,e_s$:
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_s}{\aclrd{\textbf{s}}} \vdash e_s : \tau_s\vspace{-2em}\end{array} &
    \inference
      { \coctx{\Gamma_r, x\!:\!\tau_s}{\aclrd{\textbf{r}}\;\atimes\,\alift{\cclrd{t}}} \vdash e_r : \tau_r }
      { \coctx{\Gamma_r}{\aclrd{\textbf{r}}} \vdash \lambda x.e_r : \tau_s \xrightarrow{\cclrd{t}} \tau_r} \vspace{0.2em} }
  { \coctx{\Gamma_r, \Gamma_s}{\aclrd{\textbf{r}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})} \vdash (\lambda x.e_r)~e_s : \tau_r }
\end{equation*}
%
For the substitution lemma, we first rewrite the typing judgement for $e_r$, \ie~
$\coctx{\Gamma_r, x\!:\!\tau_s}{\aclrd{\textbf{r}}\;\atimes\,\alift{\cclrd{t}}} \vdash e_r : \tau_r$
as a context with a single hole filled by the $x$ variable:
$\coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes\,-}~[\,\coctx{x\!:\!\tau_s}{\alift{\cclrd{t}}}\,] \vdash e_r : \tau_r$.
Now we can perform the substitution using Lemma~\ref{thm:structural-substitution}:
%
\begin{equation*}
\inference
  { \coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes-}~[\,\coctx{x\!:\!\tau_s}{\alift{\cclrd{t}}}\,] \vdash e_r : \tau_r &
    \coctx{\Gamma_s}{\aclrd{\textbf{s}}} \vdash e_s : \tau_s }
  { \inference
      { \coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes-}~[\,\coctx{\Gamma_s}{\cclrd{t}\,\aseq\,\aclrd{\textbf{s}} }\,] \vdash \subst{e_r}{x}{e_s} : \tau_r }
      { \coctx{\Gamma_r, \Gamma_s}{\aclrd{\textbf{r}}\,\atimes\,(\cclrd{t}\,\aseq\,\aclrd{\textbf{s}})} \vdash \subst{e_r}{x}{e_s} : \tau_r } }
\end{equation*}
%
The last step applies the hole filling operation, showing that substitution preserves
the type of the term.
\end{proof}

\noindent
Because of the vector structure of coeffect annotations $\aclrd{\textbf{r}}$,
$\aclrd{\textbf{s}}$, and $\alift{\cclrd{t}}$, these are uniquely associated with $\Gamma_r$,
$\Gamma_s$, and $x$ respectively. Therefore, substituting $e_s$ (which has coeffects
$\aclrd{\textbf{s}}$) for $x$ introduces the context demands specified by $\aclrd{\textbf{s}}$
which are composed with the demands $\cclrd{t}$ associated with $x$, \ie~the variable being
substituted.

\paragraph{Expansion theorem.}
Structural coeffect systems also exhibit $\eta$-equality, therefore satisfying both
\emph{local soundness} and \emph{local completeness} as required by Pfenning and Davies
\cite{logic-modal-reconstruction}. Informally, this means that abstraction does not introduce
too much, and application does not eliminate too much.

\begin{theorem}[$\eta$-expansion]
In a structural coeffect system with a structural coeffect algebra formed by
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq$,
if $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$
and $e \rightarrow_{\eta} e'$ using the full $\eta$-reduction then
$\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
The following derivation shows that $\lambda x.f~x$ has the same type and coeffects as
the original expression $f$:
\begin{equation*}
\inference
  { \inference
    { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash f : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 &
      \coctx{x\!:\!\tau_1}{\alift{\cunit}} \vdash x:\tau_1 }
    { \coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}} \;\atimes\;(\cclrd{s}\,\aseq\,\alift{\cunit}) } \vdash f~x : \tau_2 } }
  { \inference
    { \coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}} \;\atimes\,\alift{\cclrd{s}} } \vdash f~x : \tau_2 }
    { \coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash \lambda x.f~x : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 } }
\end{equation*}
%
The second step uses the fact that
$\cclrd{s} \,\aseq\, \alift{\cunit} = \alift{\cclrd{s} \,\cseq\, \cunit} = \alift{\cclrd{s}}$
arising from the monoid $(\C, \cseq, \cunit)$ of the scalar coeffect structure.
\end{proof}

\noindent
The $\eta$-expansion property discussed in this section highlights another difference
between coeffects and effects. The $\eta$-equality property does not hold for many notions
of effect. For example, in a language with output effects, $e = (\textsf{print \texttt{"hi"}}; (\lambda x . x))$
has different effects to its $\eta$-converted form $\lambda x . e\,x$ because the immediate
effects of $e$ are hidden by the purity of $\lambda$-abstraction. In the coeffect calculus,
the (\emph{abs}) rule allows immediate contextual demands of $e$ to ``float outside''
of the enclosing $\lambda$. Furthermore, the free monoid nature of $\atimes$ in structural
coeffect systems allows the exact immediate demands of $\lambda x . e x$ to match
those of $e$.



% ==================================================================================================
%
%    #######
%       #    #    # ######  ####  #####  #   #
%       #    #    # #      #    # #    #  # #
%       #    ###### #####  #    # #    #   #
%       #    #    # #      #    # #####    #
%       #    #    # #      #    # #   #    #
%       #    #    # ######  ####  #    #   #
%
% ==================================================================================================

\section{Categorical motivation}
\label{sec:struct-semantics}

To define the semantics of structural coeffect calculus, we follow the same approach as for flat
coeffect calculus in Chapter~\ref{ch:semantics}. In this section, we define categorical semantics
for the calculus in terms of \emph{structural indexed comonad}, which is an extension of the
\emph{indexed comonad} structure. Similarly to \emph{flat indexed comonad}, the structural variant
adds operations that are needed to embed full $\lambda$-calculus, this time with per-variable contexts.

We use the semantics to guide the \emph{categorically-inspired translation} discussed in
Section~\ref{sec:struct-transl}, which translates context-aware programs from the structural coeffect
calculus to a simple target functional language with uninterpreted comonadically-inspired primitives
(that correspond to operations of the structural indexed comonads). We then give operational
semantics for a concrete context-aware language by giving the domain-specific reduction rules for
the comonadically-inspired primitives. As an example, we use this to prove syntactic type safety
of structural dataflow language in Section~\ref{sec:struct-transl-safety}.

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of vectors}

Recall that in the flat coeffect calculus, the context is interpreted as a product and so a typing
judgement $\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\cclrd{r}} \vdash e : \tau$ is interpreted as a
morphism $\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau$. In this model,
we can freely transform the value contained in the context modelled using an indexed comonad
$\ctyp{\cclrd{r}}$.

Previously, we defined the $\ident{map}$ function (in terms of $\ident{cobind}$ and $\ident{counit}$),
which transforms the value inside the context without affecting the coeffect annotation. Thus,
we can use $\ident{map}_{\cclrd{r}}~\pi_i$ to transform a context containing product of variables
$\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)}$ into a context containing a single value
$\ctyp{\cclrd{r}}{\tau_i}$. This changes the carried value without affecting the coeffect $\cclrd{r}$.

The ability to freely transform the variable structure is not desirable in the model of
structural coeffect systems. Our aim is to guarantee (by construction) that the structure of
the coeffect annotations matches the structure of variables. To achieve this, we model vectors
using a structure distinct from ordinary products which we denote $-\xtimes-$.
For example, the judgement $\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}} \vdash e : \tau$
is modelled as a morphism $\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$.
We assume that the operator is equipped with necessary associativity transformations allowing us
to use it freely on more than two values.

The operator is a bifunctor, but it is \emph{not} a product in the categorical sense. In particular,
there is no way to turn $\tau_1 \xtimes \ldots \xtimes \tau_n$ into $\tau_i$ (the structure does
not have projections) and so there is also no way of turning
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$ into
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{\tau_i}$, which would break the correspondence
between coeffect annotations and variable structure.

The structure created using $-\xtimes-$ can be manipulated only using operations provided by
the \emph{structural indexed comonad}, which operate over variable contexts contained in an
indexed comonad $\ctyp{\aclrd{\textbf{r}}}$ and are designed to preserve the correspondence
between vectors and annotations.

In what follows, we model (finite) vectors of length $n$ as $\tau_1 \xtimes \ldots \xtimes \tau_n$.
As mentioned, we assume that the use of the operator can be freely re-associated. For example, when
calling an operation that requires input of the form
$(\tau_1 \xtimes \ldots \xtimes \tau_i) \xtimes (\tau_{i+1} \xtimes \ldots \xtimes \tau_n)$,
we use an argument $(\tau_1 \xtimes \ldots \xtimes \tau_n)$ and assume that the
appropriate transformation is inserted.

% --------------------------------------------------------------------------------------------------

\subsection{Indexed comonads, revisited}

The semantics of structural coeffect calculus reuses the definition of \emph{indexed comonad} with
a minimal change. The additional structure that is required for context manipulation (merging and
splitting) is different and is here provided by the \emph{structural indexed comonad} structure that
we introduce in this section.

Recall the definition from Section~\ref{sec:semantics-flat-idx}, which defines an indexed como\-nad
over a monoid $(\C, \cseq, \cunit)$ as a triple $(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit},
\ident{cobind}_{\cclrd{r}, \cclrd{s}})$. The triple consists of a family of object mappings $\ctyp{\cclrd{r}{}}$,
and two mappings that involve context-dependent morphisms of the form $\ctyp{\cclrd{r}} \tau_1 \rightarrow \tau_2$.

In the structural coeffect calculus, we work with morphisms of the form $\ctyp{\cclrd{r}} \tau_1 \rightarrow \tau_2$
representing function values (appearing in the language), but also of the form
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$,
modelling expressions in a context. To capture this, we need to revisit the definition and use
\emph{coeffect vectors} in some of the operations.

\begin{definition}
Given a monoid $(\C, \cseq, \cunit)$ with a pointwise extension of the $\cseq$ operator to a vector
(written as $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$) and an operation lifting scalars to vectors
$\alift{-}$, an \emph{indexed comonad} over a category $\catc$ is a triple
$(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, \ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}})$:

\begin{compactitem}
\item $\ctyp{\aclrd{\textbf{r}}}{}$ for all $\aclrd{\textbf{r}} \in \bigcup_{\sclrd{m}\in \sclrd{\mathbb{N}}} \C^{\sclrd{m}}$ is a family of object mappings
\item $\ident{counit}_{\cunit}$ is a mapping $\ctyp{\alift{\cunit}}{\alpha} \rightarrow \alpha$
\item $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$ is a mapping $(\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta)
  \rightarrow (\ctyp{\cclrd{s}\aseq\aclrd{\textbf{r}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{s}}}{\beta})$
\end{compactitem}
\end{definition}

\noindent
The object mapping $\ctyp{\aclrd{\textbf{r}}}$ is now indexed by a vector rather than by a scalar
$\ctyp{\cclrd{r}}$ as in the previous chapter. This new definition supersedes the old one, because a
flat coeffect annotation can be seen as singleton vectors.

The operation $\ident{counit}_{\cunit}$ operates on a vector of length one. This means that it will always
return a single value rather than a vector created using $-\xtimes-$. The $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$
operation is, perhaps surprisingly, indexed by a coeffect vector and a coeffect scalar. This asymmetry
is explained by the fact that the input function ($\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta$)
takes a vector of variables, but always produces just a single value. Thus the resulting function
also takes a vector of variables, but always returns a context with a vector containing just one value.
In other words, $\alpha$ may contain $\xtimes$, but $\beta$ may not, because the coeffect calculus has
no way of constructing values containing $\xtimes$.

% --------------------------------------------------------------------------------------------------

\subsection{Structural indexed comonads}
\label{sec:struct-semantics-idxc}

The flat indexed comonad structure extends indexed comonads with operations
$\ident{merge}_{\cclrd{r},\cclrd{s}}$ and $\ident{split}_{\cclrd{r},\cclrd{s}}$ that combine or
split the additional (flat) context and are annotated with the flat coeffect operations $\czip$
and $\cpar$, respectively.

In the structural version, the corresponding operations operate convert between a (wrapped) vector
of values represented using $\xtimes$ and ordinary pairs of contexts containing parts of the vector.
The vectors of coeffect annotations are split or merged using $\atimes$ of the structural coeffect
algebra, in a way that mirrors the wrapped vectors (variable structure).

The following definition includes $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ which models
duplication of a variable in a context needed for the semantics of contraction:

\begin{definition}
Given a structural coeffect algebra formed by $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$
with operations $\alift{-}$ and $\aseq$, a \emph{structural indexed comonad} is an indexed comonad over
the monoid $(\C, \cseq, \cunit)$ equipped with families of operations $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$,
$\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ and $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ where:
%
\begin{compactitem}
\item $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta} \rightarrow \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)}$
\item $\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)} \rightarrow \ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta}$
\item $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ is a family of mappings
  $\ctyp{\alift{\cclrd{r} \cpar \cclrd{s}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{r}, \cclrd{s}}}{(\alpha \xtimes \alpha)}$
\end{compactitem}
%
Here, the following equalities must hold:
\begin{equation*}
\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} ~\equiv~ \ident{id} \qquad\qquad
\ident{id} ~\equiv~ \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}
\end{equation*}

\end{definition}

\noindent
These operations differ from those of the flat indexed comonad in that the \ident{merge} and
\ident{split} operations are required to be inverse functions and to preserve the additional
information about the context. This was not required for the flat system where the operations
could under-approximate or over-approximate. Note that the operations use $\xtimes$ to combine
or split the contained values. This means that they operate on free-variable vectors rather than
on ordinary products.

The \ident{dup} mapping is a new operation that was not required for a flat calculus. It
takes a variable context with a single variable annotated with $\cclrd{r}\,\cpar\,\cclrd{s}$,
duplicates the value of the variable $\alpha$ and splits the additional context between the two
new variables. In a flat calculus, this operation was expressed using ordinary tuple
construction, which is not possible here -- the returned context needs to contain a
two-element vector $\alpha \xtimes \alpha$.

% --------------------------------------------------------------------------------------------------

\begin{figure*}[!t]
The semantics is defined over a typing derivation:
%
\begin{equation*}
\hspace{-3em}
\begin{array}{ll}
\hspace{4em}\semdef
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau}
  {\ident{counit}_{\cunit}}
& (\emph{var})
\\[1em]
\hspace{4.6em}\semdef
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
  {\ident{const}~n}
& (\emph{num})
\\[1.5em]
\hspace{1.40em}\semdeff
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2}
  {f}
  {f \circ \ident{curry}~\ident{merge}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}} }
& (\emph{abs})
\\[2em]
\hspace{-1.85em}\emdefff
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1}
  {\begin{array}{l}\sem{\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\,\atimes\,(\cclrd{t} \aseq \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}\\[-0.25em]~\end{array}}
  {f}
  {g}
  {\hspace{-0.5em}\begin{array}{l}
  \ident{app}~\circ~f\hspace{-0.15em}\times\hspace{-0.15em}(\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}~g)\\[-0.25em]
  ~~\circ~~\ident{split}_{\aclrd{\textbf{r}}, \cclrd{t} \,\aseq\, \aclrd{\textbf{s}}}\\[-0.25em]
  \end{array}\hspace{-0.5em}}
& (\emph{app})
\\[1.5em]
\hspace{1.55em}\semdeff
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}
  {f}
  {f\circ\ident{snd}\circ \ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}}
& (\emph{weak})
\\[1.5em]
\hspace{0.5em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2\\[-0.25em]\qquad}
     {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {f}
  {\begin{array}{l}\hspace{-0.5em}f\,\circ\,\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{t},\cclrd{s}},
     \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}\\[-0.25em]
     ~~(\ident{merge}_{\alift{\cclrd{s}}, \alift{\cclrd{t}}}\circ\ident{swap}\circ\ident{split}_{\alift{\cclrd{t}}, \alift{\cclrd{s}}})\hspace{-5em}~ \end{array} }
& (\emph{exch})
\\[1.5em]
\hspace{0em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}
      {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \\[-0.25em] \qquad\vdash \subst{e}{z,y}{x} : \tau}\end{array}}
  {f}
  {\begin{array}{l}\hspace{-0.5em}f\,\circ\,\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}\,\cpar\,\cclrd{t}},
      \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~\ident{dup}_{\cclrd{s}, \cclrd{t}}\hspace{-0.5em} \\[-0.25em]~\end{array}}
& (\emph{contr})
\end{array}
\end{equation*}

\vspace{2em}
Assuming the following auxiliary operations:
%
\begin{equation*}
\begin{array}{rcl}
  \ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~f &=&
    \ident{merge}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s'}}\atimes\aclrd{\textbf{t}}} \;\circ\;
      \ident{id} \times(\ident{merge}_{\aclrd{\textbf{s'}}, \aclrd{\textbf{t}}} \,\circ\, f \times \ident{id} \,\circ\, \ident{split}_{\aclrd{\textbf{s}}, \aclrd{\textbf{t}}}) \;\circ\;
      \ident{split}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}\atimes\aclrd{\textbf{t}}}
\end{array}
\end{equation*}
\begin{equation*}
\begin{array}{rcl}
  \ident{id}~x &=& x \\[-0.25em]
  \ident{const}~v &=& \lambda x.v \\[-0.25em]
  \ident{curry}~f~x~y &=& \lambda f.\lambda x.\lambda y.f~(x, y)\\[-0.25em]
  \ident{fst}~(x,y) &=& x\\[-0.25em]
  \ident{swap}~(x,y) &=& (y,x)\\[-0.25em]
  f \times g &=& \lambda (x, y).(f~x, g~y)\\[-0.25em]
  \ident{app}~(f, x) &=& f~x
\end{array}
\end{equation*}

\figcaption{Categorical semantics of the structural coeffect calculus}
\label{fig:struct-semantics}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of structural calculus}

The concrete semantics for liveness and bounded variable use shown in
Sections~\ref{sec:applications-struct-live} and \ref{sec:applications-struct-bll}
suggests that semantics of structural coeffect calculi tend to be more complex
than semantics of flat coeffect calculi. The complexity comes from the fact
that we need a more expressive representation of the variable context -- \eg~a vector
of optional values. Additionally, the structural system needs to pass separate variable
contexts to the sub-expressions.

The latter aspect is fully captured by the semantics shown in this section. The
earlier point is left to the concrete notion of structural coeffect. Our model still gives
us the flexibility of defining the concrete representation of variable vectors. We explore
a number of examples in Section~\ref{sec:struct-semantics-examples} and start by looking
at a unified categorical semantics defined in terms of \emph{structural indexed comonads}.

\paragraph{Contexts and functions.}
In the structural coeffect calculus, expressions in context are interpreted as functions taking
a vector (represented using $-\xtimes-$) wrapped in a structure indexed with a vector of annotations
such as $\ctyp{\aclrd{\textbf{r}}}$. Functions take only a single variable as an input and so the
structure is annotated with a scalar, such as $\ctyp{\cclrd{r}}$, which we treat as being equivalent
to a singleton vector annotation $\ctyp{\alift{\cclrd{r}}}$:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} } \vdash e : \tau}
  &:& \ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau\\
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} &=& \ctyp{\alift{\cclrd{r}}}{\tau_1} \rightarrow \tau_2
\end{array}
\end{equation*}
%
Note that the instances of flat indexed comonad ignored the fact that the variable
context wrapped in the data structure is a product. This is not generally the case for the
structural indexed comonads -- the definitions shown in Section~\ref{sec:struct-semantics-examples}
are given specifically for $\ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$
rather than more generally for $\ctyp{\aclrd{\textbf{r}}}{\alpha}$. The need to examine the structure
of the variable context is another reason for using $-\xtimes-$ when interpreting expressions in contexts.

\paragraph{Expressions.}
A semantics of structural coeffect calculi is shown in Figure~\ref{fig:struct-semantics}. The
semantics is written as composition of morphisms using a number of auxiliary definitions. Due to
the equivalence between Cartesian Closed Categories and the $\lambda$-calculus, we will treat it
as specifying translation to a target functional language in Section~\ref{sec:struct-transl}.

The following summarizes how the standard syntax-driven rules work, highlighting the differences
from the flat version:

\begin{itemize}
\item When accessing a variable (\emph{var}), the context now contains \emph{only} the accessed
  variable and so the semantics is just $\ident{counit}_{\cunit}$ without a projection.
  Constants (\emph{const}) are interpreted by a constant function.

\item The semantics of flat function application first duplicated the context so that the same
  variables can be passed to both sub-expressions. This is no longer needed -- the
  (\emph{app}) rule splits the variables \emph{including} the additional context into two parts.
  Passing the first context to the semantics of $e_1$ gives us a function
  $\ctyp{\alift{\cclrd{t}}}{\tau_1} \rightarrow \tau_2$.

  A value $\ctyp{\alift{\cclrd{t}}}{\tau_1}$ required in order to call the function is obtained by
  applying $\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}$ to the semantics of $e_2$. The result
  $\ctyp{\cclrd{t}\aseq\aclrd{\textbf{s}}}{(\ldots \xtimes \ldots \xtimes \ldots)} \rightarrow \ctyp{\alift{\cclrd{t}}}{\tau_1}$
  is then called with the latter part of the split input context.

\item The semantics of function abstraction (\emph{abs}) is syntactically the same as in the
  flat version -- the only difference is that we now merge a free-variable context with a
  singleton vector, both at the level of variable assignments and at the level of coeffect
  annotations.
\end{itemize}

\noindent
The semantics for the non-syntax-driven rules (weakening, exchange, contraction) performs
transformations on the free-variable context. Weakening (\emph{weak}) splits the context and
ignores the part corresponding to the removed variable. If we were modelling the semantics in
a language with a linear type system, this would require an additional operation for ignoring an
unused context annotated with $\aclrd{\czero}$.

The remaining rules perform a transformation anywhere inside the free-variable vector.
To simplify writing the semantics, we define a helper
$\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}$
that splits the variable vector into three parts, transforms the middle part and then
merges them, using the newly transformed middle part.

The transformations on the middle part are quite simple. The (\emph{exch}) rule swaps two
single-variable contexts and the (\emph{contr}) rule uses the $\ident{dup}_{\cclrd{s}, \cclrd{t}}$
operation to duplicate a variable while splitting its additional context.

\paragraph{Properties.}

As in the flat calculus, the main reason for defining the categorical semantics in this chapter
is to provide validation for the design of the calculus. The following correspondence theorem
states that the annotations in the typing rules of the structural coeffect calculus correspond
to the indices of the semantics. Thus, the calculus captures a context-dependent property if
it can be modelled by a \emph{structural indexed comonad}. As we show in the next section,
this is the case for all three discussed examples (liveness, dataflow, bounded variable reuse).

\begin{theorem}[Correspondence]
\label{thm:struct-correspondence}
In all of the typing rules of the structural coeffect system, the context annotations $\aclrd{\textbf{r}}$
and $\cclrd{s}$ of typing judgements $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ and function types
$\tau_1 \xrightarrow{\cclrd{s}} \tau_2$  correspond to the indices of mappings $\ctyp{\aclrd{\textbf{r}}}{}$
and $\ctyp{\alift{\cclrd{s}}}{}$ in the corresponding semantic function defined
by $\sem{\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau}$.
\end{theorem}
\begin{proof}
By analysis of the semantic rules in Figure~\ref{fig:struct-semantics}.
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Examples of structural indexed comonads}
\label{sec:struct-semantics-examples}

The categorical semantics for structural coeffect calculus is easily instantiated to give
semantics for a concrete calculus. In this section, we revisit the three examples discussed
throughout this chapter -- structural liveness, dataflow and bounded variable reuse.
Some aspects of the first two examples will be similar to flat versions discussed in
Section~\ref{sec:semantics-flat-monoidal} -- they are based on the same data structures (option and a
list, respectively), but the data structures are composed differently. Generally speaking,
rather than having a data structure over a product of variables, we now have
a vector of variables over a specific data structure.

The abstract semantics does not specify how vectors of variables should be represented, so this can
vary in concrete instantiations. In all our examples, we represent a vector of variables as a
product written using $\times$. To distinguish between products representing vectors and ordinary
products (\eg~a product of contexts returned by \ident{split}), we write vectors using
$\langle a, \ldots, b \rangle$ rather than the parentheses, used for ordinary tuples.

\paragraph{Dataflow.}
It is interesting to note that the semantics of dataflow and bounded variable reuse (discussed
next) both keep a product of multiple values for each variable, so they are both built around an
\emph{indexed list} data structure. However, their \ident{cobind} and \ident{dup} operations work
differently. We start by looking at the structure modelling dataflow computations. For readability,
variables in bold face (such as $\mathbf{a_1}$) range over vectors while ordinary notation (such
as $a_1$) is used for individual values.

\begin{example}[Indexed list for dataflow]
\label{thm:struct-dfl}
The indexed list model of dataflow computations is defined over a structural coeffect
algebra $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$
is indexed by required number of past variables for each individual variable. It is defined
over a vector of variables $\alpha_1 \xtimes \ldots \xtimes \alpha_k$ and it keeps a product
containing a current value followed by $n_i$ past values:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} =
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{(n_1+1)-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{(n_k+1)-\textnormal{times}}
\end{equation*}
%
The mappings that define the structural indexed comonad include the \ident{split} and \ident{merge}
operations that are shared by the other two examples (discussed below):
%
\begin{equation*}
\begin{array}{l}
\ident{merge}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle}
  (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle) = \\[-0.25em]
\quad \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle
\\[0.45em]
\ident{split}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle}
   \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle = \\[-0.25em]
\quad (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle)
\end{array}
\end{equation*}
%
The remaining mappings that are required by structural indexed comonad and capture the
essence of dataflow computations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~~\; f \langle \langle a_{1,m}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,m}, \ldots a_{k,m+{n_k}} \rangle \rangle~\; \rangle\rangle
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{\mathit{max}(m,n)} \rangle \rangle =
   \langle \langle a_1, \ldots, a_m \rangle, \langle a_1, \ldots, a_n \rangle \rangle
\end{array}
\end{equation*}
\end{example}

\noindent
The definition of the indexed list data structure relies on the fact that the number of annotations
corresponds to the number of variables combined using $-\xtimes-$. It then creates a vector of lists
containing $n_i+1$ values for the $i$-\textit{th} variable (the annotation represents the number of
required \emph{past} values so one more value is required).

The \ident{split} and \ident{merge} operations are defined separately, because they are not specific
to the example. They operate on the top-level vectors of variables (without looking at the
representation of the variable). This means that we can re-use the same definitions for the following
two examples (with the only difference that $\mathbf{a_i}, \mathbf{b_i}$ will there represent options
rather than lists).

The mappings that explain how dataflow computations work are \ident{cobind} (representing sequential
composition) and \ident{dup} (representing context sharing or parallel composition). In \ident{cobind},
we get $k$ vectors corresponding to $k$ variables, each with $m+n_i$ values. The operation calls
$f$ $m$-times to obtain $m$ past values required as the result of type $\ctyp{\langle m \rangle} \beta$.

The $\ident{dup}_{m,n}$ operation needs to produce a two-variable context containing $m$ and $n$ values,
respectively, of the input variable. The input provides $\mathit{max}(m, n)$ values, so the definition
is simply a matter of restriction. Finally, \ident{counit} extracts the value of its single variable.

\paragraph{Bounded reuse.}
As mentioned earlier, the semantics of calculus for bounded reuse is also based on the indexed list
structure. Rather than representing possibly different past values that can be shared (see the
definition of \ident{dup}), the list now represents multiple copies of the same value as each value
can only be accessed once. This semantics follows that of Girard \cite{logic-bounded}.

\begin{example}[Indexed list for bounded reuse]
\label{thm:struct-bll}
The indexed list model of bounded variable reuse is defined over a structural coeffect
algebra $(\mathbb{N}, \ast, +, 1, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$
is a vector containing $n_i$ values of $i$-\textit{th} variable:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} =
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{n_1-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{n_k-\textnormal{times}}
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as in Example~\ref{ex:struct-dfl}.
The operations that capture the behaviour of bounded reuse are:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{1}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{m+n} \rangle \rangle =
\quad \langle \langle a_1, \ldots, a_m \rangle, \langle a_{m+1}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m\ast{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m\ast{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1 - 1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k - 1}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~ f \langle \langle a_{1,(m-1)\ast n_1}, \ldots a_{1,(m-1) \ast n_1} \rangle, \ldots,
                   \langle a_{k,m\ast n_k - 1}, \ldots a_{k,m\ast n_k - 1} \rangle \rangle~\; \rangle
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{counit} operation is defined as previously -- it extracts the only value of the only
variable In the bounded variable reuse system, variable sharing is annotated with the $+$ operator
(in contrast with \textit{max} used in dataflow). The $\ident{dup}_{m,n}$ operation thus splits the $m+n$
available values between two vectors of length $m$ and $n$, without \emph{sharing} a value. The
\ident{cobind} operation works similarly -- it splits $m\ast n_i$ available values of each
variable into $m$ vectors containing $n_i$ copies and then calls the $f$ function $m$-times to
obtain $m$ resulting values without sharing any input value.

\paragraph{Liveness.}
In both dataflow and bounded reuse, the data type is defined as a vector of values obtained
by applying the indexed list type constructor to types of individual variables. We can
generalize this pattern. Given a parameterized (indexed) type constructor $D^l \alpha$, we define
$\ctyp{\langle l_1, \ldots, l_n \rangle}$ in terms of a vector of $D^{l_i}$ types.
For liveness, the definition lets us reuse some of the mappings used when defining the semantics of
flat liveness. However, we cannot fully define the semantics of the structural version in terms of
the flat version -- the \ident{cobind} operation is different and we need an appropriate
\ident{dup} operation.

\begin{example}[Structural indexed option]
\label{thm:struct-live}
Given a structural coeffect algebra formed by $(\{ \ident{L}, \ident{D} \}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$
and the indexed option data type $D^l$, such that $D^{\ident{D}}\alpha = 1$ and $D^{\ident{L}}\alpha=\alpha$,
the data type for structural indexed option comonad is:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} =
  D^{n_1} \alpha_1 \times \ldots \times D^{n_k} \alpha_k
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as earlier. The remaining operations
model variable liveness as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{cobind}_{\ident{L}, \langle l_1, \ldots, l_n \rangle}~f~\langle a_1, \ldots, a_n \rangle = \langle f~\langle a_1, \ldots, a_n \rangle \rangle \\[-0.25em]
\ident{cobind}_{\ident{D}, \langle \ident{D}, \ldots, \ident{D} \rangle}~f~\langle (), \ldots, () \rangle = \langle \ident{D} \rangle
\\[0.5em]
\hspace{-0.5em}
\begin{array}{lll}
~\\[-0.85em]
\ident{dup}_{\ident{D}, \ident{D}} \langle () \rangle &\narrow{=}& \langle (), () \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{D}} \langle a \rangle &\narrow{=}& \langle a, () \rangle \\[-0.25em]
\ident{dup}_{\ident{D}, \ident{L}} \langle a \rangle &\narrow{=}& \langle (), a \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{L}} \langle a \rangle &\narrow{=}& \langle a, a \rangle
\end{array}
\qquad\quad
\begin{array}{lll}
\ident{counit}_{\ident{L}}~\langle a \rangle &\narrow{=}& a
\end{array}
\end{array}
\end{equation*}
\end{example}

\noindent
When the expected result of the \ident{cobind} operation is dead (second case), the operation can
ignore all inputs and directly return the unit value $()$. Otherwise, it passes the vector of
input variables to $f$ as-is -- no matter whether the individual values are live or dead. The
\ident{L} annotation is a unit with respect to $\cap$ and so the annotations expected by $f$ are
the same as those required by the result of \ident{cobind}.

The \ident{dup} operation resembles with the flat version of \ident{split} -- this is expected as
duplication in the flat calculus is performed by first duplicating the variable context (using
\ident{map}) and then applying \ident{split}. Here, the duplication returns a pair. Depending on the
required coeffect annotations, this may copy (duplicate) the value, or it may produce an empty context.

Finally, \ident{counit} extracts a value which is always present as guaranteed by the type
$\ctyp{\langle \ident{L} \rangle}{\alpha} \rightarrow \alpha$. The lifting operation models
subcoeffecting which can turn a context with a value into a dead context (second case); otherwise
it behaves as identity.

\paragraph{Properties.}
The concrete categorical semantics presented in this section is a generalization of the concrete
semantics given when introducing context-aware programming languages in Chapter~\ref{ch:applications}.

\begin{theorem}[Generalization]
\label{thm:struct-generalization}

Consider a typing derivation obtained according to the rules for finding unique typing derivations
as specified in Section~\ref{sec:struct-unique} for a coeffect language with liveness, dataflow or
bounded variable use.

The semantics obtained by instantiating the rules in Figure~\ref{fig:struct-semantics} with the
concrete operations defined in Example~\ref{thm:struct-live},
Example~\ref{thm:struct-dfl} or Example~\ref{thm:struct-bll} is the
same as the one defined in Figure~\ref{fig:applications-struct-livesem},
Section~\ref{sec:applications-structural-dataflow} and Section~\ref{sec:applications-struct-bll},
respectively.
\end{theorem}
\begin{proof}
Expansion of the definitions for the unique typing derivation.
\end{proof}


% ==================================================================================================
%
%    #######
%       #    #####    ##   #    #  ####  #        ##   ##### #  ####  #    #
%       #    #    #  #  #  ##   # #      #       #  #    #   # #    # ##   #
%       #    #    # #    # # #  #  ####  #      #    #   #   # #    # # #  #
%       #    #####  ###### #  # #      # #      ######   #   # #    # #  # #
%       #    #   #  #    # #   ## #    # #      #    #   #   # #    # #   ##
%       #    #    # #    # #    #  ####  ###### #    #   #   #  ####  #    #
%
% ==================================================================================================

\section{Translational semantics}
\label{sec:struct-transl}

In the previous section, we used category theory to give a unified model capable of capturing
the semantics of our three context-aware language based on the structural coeffect calculus.
Although the categorical model is interesting on its own, we use it in the same way as in
Chapter~\ref{ch:semantics} -- to define a translation from source context-aware languages to a
simple target functional language. As for flat coeffect calculus, we show that the translation
produces well-typed programs in the target language. For a sample context-aware programming
language, we then show that well-typed programs (produced by the translation) do not get stuck.

This section mirrors the development presented in Chapter~\ref{ch:semantics} for flat coeffect
calculus. We extend the simple target language with additional constructs inspired by structural
indexed comonads (Section~\ref{sec:struct-transl-ext}), define the translation to the target
language (Section~\ref{sec:struct-transl-transl}) and prove safety of one sample language
(Section~\ref{sec:struct-transl-safety}) -- we choose structural dataflow to allow easy
comparison with the flat system.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax.}
Given a structural coeffect algebra, extend the programming language syntax with the following
constructs:

\begin{equation*}
\begin{array}{rcl}
  e &  =  &\ldots \sep\ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e
         \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~e \\
  \tau &  = &\ldots \sep \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} \\
  K  & = &\ldots \sep \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~\_~e \sep \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~v~\_ \sep \ident{counit}_{\cunit}~\_ \\
    && \hspace{1.4em} \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~\_
           \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~\_ \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~\_ \\
\end{array}
\end{equation*}

~

~

\paragraph{Typing rules.}
Given a structural coeffect algebra, add the typing rules:

\begin{equation*}
\begin{array}{l}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\alift{\cunit}}{\tau}}
  {\Gamma \vdash \ident{counit}_{\cunit}~e : \tau} \\
\\
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} \rightarrow \tau & \Gamma \vdash e_2 : \ctyp{\cclrd{s}\aseq\aclrd{\textbf{r}}}{\tau_1(\tau_1 \xtimes \ldots \xtimes \tau_k)} }
  {\Gamma \vdash \ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}~e_1~e_2 : \ctyp{\alift{\cclrd{s}}}{\tau}} \\
  \\
\tyrule{merge}
  {\Gamma \vdash  e : \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_l)} \times \ctyp{\aclrd{\textbf{s}}}{(\tau_{l+1} \xtimes \ldots \xtimes \tau_k)} }
  {\Gamma \vdash  \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e : \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} }\\
\\
\tyrule{split}
  {\Gamma \vdash  e : \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} }
  {\Gamma \vdash  \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e : \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_l)} \times \ctyp{\aclrd{\textbf{s}}}{(\tau_{l+1} \xtimes \ldots \xtimes \tau_k)}} \\
\\
\tyrule{dup}
  {\Gamma \vdash  e : \ctyp{\alift{\cclrd{r}\cpar\cclrd{s}}}{\tau} }
  {\Gamma \vdash  \ident{dup}_{\cclrd{r},\cclrd{s}}~e : \ctyp{\alift{\cclrd{r},\cclrd{s}}}{(\tau \xtimes \tau)} } \\
\end{array}
\end{equation*}

\figcaption{Comonadically-inspired extensions for structural coeffects}
\label{fig:struct-semantics-ext}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Comonadically-inspired language extensions}
\label{sec:struct-transl-ext}

In Section~\ref{sec:semantics-translation-target}, we defined the syntax, typing rules and
operational semantics for a simple functional programming language. We then extended it with
uninterpreted constructs inspired by the \emph{flat indexed comonad} structure and used it as the
translation target for the flat coeffect calculus. In this section, we take the same core language
and extend it with constructs inspired by the \emph{structural indexed comonad}.

Given a coeffect language with a structural coeffect algebra formed by
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq, \atimes$, we
extend the core functional language with operations shown in Figure~\ref{fig:struct-semantics-ext}.
The syntax extensions add comonadically-inspired operations that mirror those defined in
Section~\ref{sec:struct-semantics-idxc}. The typing for the operations corresponds to their
categorical counterparts.

We also include an uninterpreted type $\ctyp{\aclrd{\textbf{r}}}{\tau_1\xtimes\ldots\xtimes\tau_k}$,
which models a contextual (comonadic) value indexed by a vector of annotations. As in the
categorical model for structural coeffects, context consisting of multiple variables is not modelled
as ordinary tuple -- it can only be manipulated by the comonadically-inspired operations.
In the target language, this is done by defining the $\ctyp{\aclrd{\textbf{r}}}{}$ type over
zero or more underlying types. Here, our syntactic treatment differs slightly from the categorical
model where objects created by $\xtimes$ were first-class values. In Figure~\ref{fig:struct-semantics-ext},
we need to explicitly specify the types of individual components in typing rules for
(\emph{merge}), (\emph{split}) and (\emph{cobind}).

As with flat coeffects, the extensions described here are common for all concrete instances of
structural context-aware languages. For each concrete language, we need to provide values of type
$\ctyp{\aclrd{\textbf{r}}}{\tau}$ and reduction rules for comonadically-inspired operations.

% --------------------------------------------------------------------------------------------------

\begin{figure*}[!t]
The translation is defined over a typing derivation:
%
\begin{equation*}
\begin{array}{ll}
\hspace{3.25em}\semdef
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau}
  {\lambda\ctx.\ident{counit}_{\cunit}~\ctx}
& (\emph{var})
\\[1em]
\hspace{4em}\semdef
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
  {\lambda\ctx.n}
& (\emph{num})
\\[1.5em]
\hspace{0.8em}\semdeff
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2}
  {f}
  {\lambda\ctx.\lambda v.f~(\ident{merge}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}}~(\ctx, v)) }
& (\emph{abs})
\\[2em]
\hspace{-2.5em}\emdefff
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1}
  {\begin{array}{l}\sem{\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\,\atimes\,(\cclrd{t} \aseq \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}\\[-0.25em]~\\[-0.25em]~\end{array}}
  {f}
  {g}
  {\hspace{-0.5em}\begin{array}{l}
  \lambda\ctx.~~\\[-0.25em]
    \quad \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\aclrd{\textbf{r}}, \cclrd{t} \,\aseq\, \aclrd{\textbf{s}}}~\ctx\\[-0.25em]
    \quad f~\ctx_1~(\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}~g~\ctx_2)
  \end{array} }
& (\emph{app})
\\[1.5em]
\hspace{0em}\emdeff
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\begin{array}{l}\sem{\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}\\[-0.25em]~\\[-0.25em]~\\\end{array}}
  {f}
  {\hspace{-0.5em}\begin{array}{l}
  \lambda\ctx.~~\\[-0.25em]
    \quad \kvd{let}~(\ctx_1, \_) = \ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}~\ctx\\[-0.25em]
    \quad f~\ctx_1
  \end{array} }
& (\emph{weak})
\\[1.5em]
\hspace{0em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2\\[-0.25em]\qquad}
     {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\\[-0.25em]~\end{array}}
  {\begin{array}{l}~\\[-0.25em]\hspace{-0.5em}f\end{array}}
  {\begin{array}{l}\hspace{-0.5em}
    \lambda\ctx.~f (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{t},\cclrd{s}},\alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~(\lambda\ctx'.\\[-0.25em]
     \quad \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\alift{\cclrd{t}}, \alift{\cclrd{s}}} \\[-0.25em]
     \quad \ident{merge}_{\alift{\cclrd{s}}, \alift{\cclrd{t}}}~(\ctx_2, \ctx_1)~))\end{array} }
& (\emph{exch})
\\[1.5em]
\hspace{-0.5em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}
      {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \\[-0.25em] \qquad\vdash \subst{e}{z,y}{x} : \tau}\end{array}}
  {\begin{array}{l}~\\[-0.25em]\hspace{-0.5em}f\end{array}}
  {\begin{array}{l}\hspace{-0.5em}\lambda\ctx.f~(\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}\,\cpar\,\cclrd{t}},
      \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}\\[-0.25em]
      \qquad \ident{dup}_{\cclrd{s}, \cclrd{t}}~\ctx)\hspace{-0.5em}\end{array}}
& (\emph{contr})
\end{array}
\end{equation*}

\vspace{2em}
Assuming the following auxiliary definition:
%
\begin{equation*}
\begin{array}{l}
  \ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}} = \lambda f.\lambda \ctx.\\[-0.25em]
  \qquad \kvd{let}~(\ctx_1, \ctx') = \ident{split}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}\atimes\aclrd{\textbf{t}}}~\ctx\\[-0.25em]
  \qquad \kvd{let}~(\ctx_2, \ctx_3) = \ident{split}_{\aclrd{\textbf{s}},\aclrd{\textbf{t}}}~\ctx'\\[-0.25em]
  \qquad \ident{merge}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s'}}\atimes\aclrd{\textbf{t}}}~(\ctx_1, \ident{merge}_{\aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~(f~\ctx_2, \ctx_3))
\end{array}
\end{equation*}

\figcaption{Translation from a structural coeffect calculus}
\label{fig:struct-translation}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Comonadically-inspired translation}
\label{sec:struct-transl-transl}

When translating context-aware programs to the functional language, variable contexts become
values of comonadically-inspired data types containing a value for each variable in the context.
Function inputs become comonadically-inspired values containing exactly one variable. More formally:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}} &=&
  \ctyp{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}{(\sem{\tau_1} \xtimes \ldots \xtimes \sem{\tau_n})} \\[0.5em]
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} & = & \ctyp{\alift{\cclrd{r}}}{\sem{\tau_1}} \rightarrow \sem{\tau_2} \\[-0.2em]
\sem{\ident{num}} & = & \ident{num} \\
\end{array}
\end{equation*}

\noindent
The definition differs from the one for flat coeffects (Section~\ref{sec:semantics-translation-transl})
in that the comonadically-inspired data type takes multiple type parameters (separated using $\xtimes$),
rather than wrapping a regular tuple in the target language.

The translation rules are defined in Figure~\ref{fig:struct-translation}. As in the case of the flat
coeffect calculus, the definition directly follows the categorical semantics shown in
Figure~\ref{fig:struct-translation}. We expand the definitions so that the result is a valid
program in the target language rather than a composition of morphisms.

As with flat coeffects, the correspondence property of the semantics (Theorem~\ref{thm:struct-correspondence})
can now be adapted into well-typedness of the translation. Given a well-typed program in the
structural coeffect calculus, the translation produces a well-typed program in the target
language. This is true for all context-aware languages based on the structural coeffect calculus
and it provides us with the first part of type safety theorem. The second part is type safety
of the target language with concrete domain-specific extensions as discussed in
Section~\ref{sec:struct-transl-safety}.

\begin{theorem}[Well-typedness of the translation]
\label{thm:struct-welltyped}
Given a typing derivation for a well-typed closed expression $\coctx{}{\alift{}} \vdash e : \tau$
written in a structural context-aware programming language that is translated to the target language as
(we write $\ldots$ for the omitted part of the translation tree):
%
\begin{equation*}
  \semdeff
    {~~(\ldots)~~}
    {\coctx{}{\alift{}} \vdash e : \tau }
    {(\ldots)}
    { ~~f }
\end{equation*}
%
Then $f$ is well-typed, \ie~in the target language: $\vdash f : \sem{\coctx{()}{\alift{}}} \rightarrow \sem{\tau}$.
\end{theorem}
\begin{proof}
By rule induction over the derivation of the translation. Given a judgement
$\coctx{x_1\!:\!\tau_1 \ldots x_n\!:\!\tau_n}{\aclrd{\textbf{c}}} \vdash e : \tau$ where
$\aclrd{\textbf{c}} = \alift{\cclrd{c_1},\ldots,\cclrd{c_n}}$, the translation
constructs a function of type $\ctyp{\aclrd{\textbf{c}}}(\sem{\tau_1}\xtimes\ldots\xtimes\sem{\tau_n}}) \rightarrow \sem{\tau}$.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{var}): $\aclrd{\textbf{c}}=\alift{\cunit}$ and so ${\ident{counit}_\cunit}~\ctx$ is well-typed.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{num}): $\tau = \ident{num}$ and so the body $n$ is well-typed.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{abs}): The type of $\ctx$ is $\ctyp{\aclrd{\textbf{r}}}(\ldots)$ and the type of $v$ is $\ctyp{\alift{\cclrd{s}}}\tau_1$,
  calling $\ident{merge}_{\aclrd{\textbf{r}},\alift{\cclrd{s}}}$ produces a context of type
  $\ctyp{\aclrd{\textbf{r}}\atimes\alift{\cclrd{s}}}(\ldots\xtimes\tau_1)$ as expected by $f$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{app}): After applying $\ident{split}_{\aclrd{\textbf{r}}, \cclrd{t}\aseq\aclrd{\textbf{s}}}$ the types of
  $\ctx_1, \ctx_2$ are $\ctyp{\aclrd{\textbf{r}}}(\ldots)$ and $\ctyp{\cclrd{t}\aseq\aclrd{\textbf{s}}}(\ldots)$, respectively.
  $g$ requires $\ctyp{\aclrd{\textbf{s}}}(\ldots)$ and so the result of $\ident{cobind}_{\cclrd{t},\aclrd{\textbf{s}}}$ is
  $\ctyp{\alift{\cclrd{t}}}\tau_1$ as required by $f$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{weak}): After applying $\ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}$ the type of
  $\ctx_1$ is $\ctyp{\aclrd{\textbf{r}}}(\ldots)$ as required.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{exch}), (\emph{contr}): The auxiliary definition $\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}$
  keeps parts of the context corresponding to coeffect annotations $\aclrd{\textbf{r}}, \aclrd{\textbf{q}}$ unchanged and transforms
  the nested part. In (\emph{exch}), the provided lambda function is of type $\ctyp{\alift{\cclrd{s},\cclrd{t}}}{(\tau_1\xtimes\tau_2)}
  \rightarrow \ctyp{\alift{\cclrd{t},\cclrd{s}}}{(\tau_2\xtimes\tau_1)}$. In (\emph{contr}), the type of
  $\ident{dup}_{\cclrd{s},\cclrd{t}}$ is $\ctyp{\alift{\cclrd{s}\cpar\cclrd{t}}}{\tau} \rightarrow \ctyp{\alift{\cclrd{s},\cclrd{t}}}{(\tau\xtimes\tau)}$
  (assuming \ident{nest} is expanded, rather than treated as a value within the language).
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffect language for dataflow}
\label{sec:struct-transl-safety}

The target language with comonadically-inspired primitives provides a framework that can be used
to model a variety of structural context-aware languages and prove their safety. As outlined in
Section~\ref{sec:semantics-generalising}, the key principle that guarantees the safety of the
target language is a correspondence between coeffect annotations and the values they represent.
In a more expressive target language (such as Haskell or Agda), it would be sufficient to
provide an implementation of the comonadically-inspired primitives for the concrete domain-specific
language.

Our simple target language is not expressive enough to capture the correspondence in the type
system and so we instead follow the same methodology as when discussing safety for flat coeffect
languages in section Section~\ref{sec:semantics-proofs} and show safety for a sample concrete
context-aware language. We consider the structural coeffect language for dataflow. The definitions
can be compared with the flat version discussed in Section~\ref{sec:semantics-proofs-df}, which
highlights the similarities and differences between the flat and structural notion of context.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\vspace{-0.5em}
\paragraph{Language syntax}
\begin{equation*}
\begin{array}{rcl}
v &=& \ldots \sep \ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle
    \hspace{9.5em} \textbf{v} ~=~ \langle v_0, \ldots, v_k \rangle \\
e &=& \ldots \sep \ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_k \rangle \sep \ident{prev}_{\cclrd{n_0}, \ldots, \cclrd{n_k}}~e
    \quad\qquad \textbf{e} ~=~ \langle e_0, \ldots, e_k \rangle \\
K &=& \ldots \sep \ident{Df}\langle \textbf{v}_0, \ldots, \langle v_{j,0}, \ldots, v_{j, i-1}, \_, e_{j, i+1} \ldots, e_{j, n}\rangle, \ldots, \textbf{e}_k\rangle \\
   && \ldots \sep \ident{prev}_{\cclrd{n_0}, \ldots, \cclrd{n_k}}~\_
\end{array}
\end{equation*}

\vspace{0.75em}
\paragraph{Typing rules}

\begin{equation*}
\tyrule{vec}
  { \forall i\in\{0\ldots n\}. ~ \Gamma \vdash e_i : \tau}
  { \Gamma \vdash_{\ident{vec}} \langle e_0, \ldots, e_n \rangle : \tau, \cclrd{n} }
\end{equation*}
\begin{equation*}
\tyrule{df}
  { \forall i\in\{0\ldots k\}. ~ \Gamma \vdash_{\ident{vec}} \textbf{e}_i : \tau_i, \cclrd{n_i}}
  { \Gamma \vdash \ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_k \rangle : \ctyp{\alift{\cclrd{n_0}, \ldots, \cclrd{n_k}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)} }
\end{equation*}
\begin{equation*}
\tyrule{prev}
  { \Gamma \vdash e : \ctyp{\alift{\cclrd{n_0+1},\ldots,\cclrd{n_k+1}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)} }
  { \Gamma \vdash \ident{prev}_{\cclrd{n_0},\ldots,\cclrd{n_k}}~e : \ctyp{\alift{\cclrd{n_0},\ldots,\cclrd{n_k}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)} }
\end{equation*}

\vspace{1em}
\paragraph{Translation}

\begin{equation*}
\semdeff
  { \coctx{\Gamma}{\alift{\cclrd{n_0+1},\ldots,\cclrd{n_k+1}}} \vdash e : \tau }
  { \coctx{\Gamma}{\alift{\cclrd{n_0},\ldots,\cclrd{n_k}}} \vdash \kvd{prev}~e : \tau }
  {f}
  {\lambda ctx.\ident{prev}_{\cclrd{n_0},\ldots,\cclrd{n_k}}~\ctx }
\end{equation*}

\vspace{1em}
\paragraph{Reduction rules}

\begin{equation*}
\begin{array}{rl}
{\footnotesize(\emph{counit})} & \begin{array}{l}
\ident{counit}_{\cclrd{0}}(\ident{Df} \langle\langle v_0 \rangle\rangle)   \rightsquigarrow v_0
\end{array}
\\[0.25em]
{\footnotesize(\emph{cobind})} & \begin{array}{l}
\ident{cobind}_{\cclrd{m}, \alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}~f~\ident{Df}\langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle \rightsquigarrow \\[-0.25em]
\quad \ident{Df}\langle\langle\; f (\ident{Df}\langle \langle a_{1,0}, \ldots a_{1,{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k}} \rangle \rangle), ~\ldots~, \\[-0.25em]
\qquad ~~~\, f (\ident{Df}\langle \langle a_{1,m}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,m}, \ldots a_{k,m+{n_k}} \rangle \rangle)~\; \rangle\rangle
\end{array}
\\[0.25em]
{\footnotesize(\emph{merge})} & \begin{array}{l}
\ident{merge}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}} ((\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle), (\ident{Df}\langle \textbf{v}'_0, \ldots, \textbf{v}'_l\rangle)) \rightsquigarrow
\\[-0.25em]
\quad \ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k, \textbf{v}'_0, \ldots, \textbf{v}'_l \rangle
\end{array}
\\[0.25em]
{\footnotesize(\emph{split})} & \begin{array}{l}
\ident{split}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}} (\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k, \textbf{v}'_0, \ldots, \textbf{v}'_l \rangle)  \rightsquigarrow
\\[-0.25em]
\quad (\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle, ~\ident{Df}\langle \textbf{v}'_0, \ldots, \textbf{v}'_l\rangle)
\end{array}
\\[0.25em]
{\footnotesize(\emph{prev})} & \begin{array}{l}
\ident{prev}_{\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}} (\ident{Df}\langle\langle v_{1,0}, \ldots, v_{1, n_1}, v_{1,{n_1}+1} \rangle,\ldots,\langle v_{k,0}, \ldots, v_{k, n_k}, v_{k,{n_k}+1} \rangle\rangle) \rightsquigarrow
\\[-0.25em]
\quad \ident{Df}\langle\langle v_{1,0}, \ldots, v_{1, n_1} \rangle,\ldots,\langle v_{k,0}, \ldots, v_{k, n_k} \rangle\rangle
\end{array}
\\[0.25em]
{\footnotesize(\emph{dup})} & \begin{array}{l}
\ident{dup}_{\cclrd{m},\cclrd{n}} (\ident{Df}\langle\langle v_0, \ldots, v_{\mathit{max}(m,n)} \rangle\rangle) \rightsquigarrow
  \ident{Df}\langle\langle v_0, \ldots, v_m \rangle, \langle v_0, \ldots, v_n \rangle\rangle
\end{array}
\end{array}
\end{equation*}

\figcaption{Additional constructs for modelling structural dataflow}
\label{fig:structural-ext-df}
\end{figure}

% --------------------------------------------------------------------------------------------------

\paragraph{Domain-specific extensions.}

The Figure~\ref{fig:structural-ext-df} extends the target functional language with constructs,
typing rules, translation rules and reduction rules needed for modelling structural dataflow.
In the structural model, the type $\ctyp{\alift{\cclrd{r_0}, \ldots, \cclrd{r_n}}}{(\tau_0\xtimes\ldots\xtimes\tau_n)}$
represents a structure that provides values and additional contexts for variables of types
$\tau_0,\ldots,\tau_n$ with contextual capabilities as specified by corresponding coeffect annotations
$\cclrd{r_0}, \ldots, \cclrd{r_n}$.

In case of dataflow, the comonadically-inspired structure keeps vectors of past values for each of
the variables in the context. In the syntax, we write $\textbf{v}$ and $\textbf{e}$ for vectors of
values and expressions, respectively. The expression $\ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_k \rangle$
is then formed by a vector of variable assignments where each variable assignment is a vector
of current and past values. When reducing expressions to values, we reduce values from left to
right and from current-most value to the last past value. This is specified by the context $K$.

When type-checking expressions that create the \ident{Df} values, we use an auxiliary judgement
$\Gamma \vdash_{\ident{vec}} e : \tau, \cclrd{n}$. The judgement checks that a vector of expressions
$\textbf{e}$ contains exactly $\cclrd{n}$ expressions of type $\tau$. This is captured by the
(\emph{vec}) rule, which is then used to check individual elements of the context in the
(\emph{df}) rule.

\paragraph{Properties.}

Now consider a target language consisting of the core (ML-subset) defined by the syntax,
reduction rules and typing rules given in Figure~\ref{fig:semantics-target} (Chapter~\ref{ch:semantics})
with primitives inspired by structural indexed comonads defined in Figure~\ref{fig:struct-semantics-ext}
and also concrete notion of comonadically-inspired value and reduction rules for dataflow as
defined in Figure~\ref{fig:structural-ext-df}.

As with the examples discussed in Chapter~\ref{ch:semantics}, the resulting language is type safe.
Together with the well-typedness of the translation (Theorem~\ref{thm:struct-welltyped}), this
guarantees type safety of the structural coeffect calculus for dataflow.
In order to prove type safety, we first extend the \emph{canonical forms lemma}
(Lemma~\ref{thm:semantics-fp-canon}) and the \emph{preservation under substitution lemma}
(Lemma~\ref{thm:semantics-fp-pres-subst}). Those need to consider the new (\emph{df})
and (\emph{prev}) typing rules and substitution under the newly introduced expression forms
$\ident{Df}\langle\ldots\rangle$ and $\ident{prev}_{\cclrd{n}}$. We show that the translation
rule for \kvd{prev} produces well-typed expressions. Finally, we extend the type preservation
(Theorem~\ref{thm:semantics-fp-pres}) and progress (Theorem~\ref{thm:semantics-fp-prog}) theorems.

\begin{theorem}[Well-typedness of the \kvd{prev} translation]
\label{thm:structural-df-welltyped}
Given a typing derivation for a well-typed closed expression $\coctx{}{\alift{}} \vdash e : \tau$,
the translated program $f$ obtained using the rules in Figure~\ref{fig:struct-translation}
and Figure~\ref{fig:structural-ext-df} is well-typed, \ie~in the target language: $\vdash f : \sem{\coctx{()}{\alift{}}} \rightarrow \sem{\tau}$.
\end{theorem}
\begin{proof}
By rule induction over the derivation of the translation.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{var, num, abs, app}): As before.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{prev}): Type of $\ctx$ is $\ctyp{\alift{\cclrd{n_0+1},\ldots,\cclrd{n_k+1}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)}$
  and so we can apply the (\emph{prev}) rule to obtain $\ctyp{\alift{\cclrd{n_0},\ldots,\cclrd{n_k}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)}$
  as required by $f$.
\end{proof}

\begin{lemma}[Canonical forms]
\label{thm:structural-df-canon}
For all $e, \tau$, if $\vdash e : \tau$ and $e$ is a value then:
\begin{enumerate}
  \item If $\tau=\ident{num}$ then $e = n$ for some $n \in \mathbb{Z}$
  \item If $\tau=\tau_1 \rightarrow \tau_2$ then $e = \lambda x.e'$ for some $x, e'$
  \item If $\tau=\tau_1\times\ldots\times\tau_n$ then $e = (v_1, \ldots, v_n)$ for some $v_i$
  \item If $\tau=\ctyp{\alift{\cclrd{n_1}, \ldots, \cclrd{n_k}}}{(\tau_1\xtimes\ldots\xtimes\tau_k)}$
    then $e = \ident{Df}\langle \textbf{v}_0, \ldots \textbf{v}_n\rangle$ for some $\textbf{v}_i$
    such that $\textbf{v}_i = \langle v_0, \ldots, v_{n_i}\rangle$.
\end{enumerate}
\end{lemma}
\begin{proof}
  (1,2,3) as before; for (4) the last typing rule must have been (\emph{df}).
\end{proof}

\begin{lemma}[Preservation under substitution]
\label{thm:structural-df-pres-subst}
For all $\Gamma, e, e', \tau, \tau'$, if $\Gamma, x:\tau \vdash e : \tau'$ and $\Gamma \vdash e' : \tau$
then $\Gamma \vdash e[x \leftarrow e'] : \tau$.
\end{lemma}
\begin{proof}
  By induction over the derivation of $\Gamma, x:\tau \vdash e : \tau'$ as before, with new
  cases for $\ident{Df}\langle\ldots\rangle$ and $\ident{prev}_{\aclrd{\textbf{n}}}$.
\end{proof}

\begin{theorem}[Type preservation]
\label{thm:structural-df-pres}
  If $\Gamma \vdash e : \tau$ and $e \rightsquigarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightsquigarrow$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{fn}, \emph{prj}, \emph{ctx}): As before, using Lemma~\ref{thm:structural-df-pres-subst} for (\emph{fn}).

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{counit}): $e = \ident{counit}_{\cclrd{0}}(\ident{Df} \langle\langle v_0 \rangle\rangle)$. The last rule in the type
  derivation of $e$ must have been (\emph{counit}) with $\Gamma \vdash \ident{Df} \langle\lange v_0 \rangle\rangle : \ctyp{\alift{\cclrd{0}}}\tau$
  and therefore $\Gamma \vdash v_0 : \tau$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{cobind}): $e = \ident{cobind}_{\cclrd{m}, \alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}~f~(\ident{Df}\langle \textbf{v}_0, \ldots \textbf{v}_{k} \rangle)$
  such that $\forall i\in\{1\ldots k\}$ $\textbf{v}_i = \langle v_0, \ldots, v_{n_i}\rangle$. The last rule in the type derivation of $e$ must have been
  (\emph{cobind}) with a type $\tau = \ctyp{\alift{\cclrd{m}}}\tau'$ and assumptions:
\begin{itemize}[noitemsep,leftmargin=1.5cm,topsep=0pt]
  \item[--] $\Gamma \vdash f : \ctyp{\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}{(\tau_1\xtimes\ldots\xtimes\tau_k)} \rightarrow \tau_2$ and
  \item[--] $\Gamma \vdash \ident{Df}\langle \textbf{v}_0, \ldots \textbf{v}_{k} \rangle : \ctyp{\alift{\cclrd{m}+\cclrd{n_1},\ldots,\cclrd{m}+\cclrd{n_k}}}{(\tau_1\xtimes\ldots\xtimes\tau_k)}$
\end{itemize}
%
\hspace{0.5cm} Using the (\emph{df}) rule, the reduced expression has a type $\ctyp{\alift{\cclrd{m}}}\tau'$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{merge}, \emph{split}, \emph{next}): Similar. In all three cases, the last typing rule in the derivation of $e$
  guarantees that the context contains correct number of vectors and each vector contains a
  sufficient number of values of a correct type.
\end{proof}

\begin{theorem}[Progress]
\label{thm:structural-df-prog}
  If $\vdash e : \tau$ then either $e$ is a value or there exists $e'$ such that $e \rightsquigarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{num,abs,var,app,proj,tup}): As before, using the adapted canonical forms lemma
  (Lemma~\ref{thm:structural-df-canon}) for (\emph{app}) and (\emph{proj}).

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{counit}): $e = {\ident{counit}_\cunit}~e_1$. If $e_1$ is not a value, it can be reduced
  using (\emph{ctx}) with context ${\ident{counit}_\cunit}~\_$, otherwise it is a value. From Lemma~\ref{thm:structural-df-canon},
  $e_1 = \ident{Df}\langle\langle v \rangle\rangle$ and so we can apply (\emph{counit}) reduction rule.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{cobind}): $e = \ident{cobind}_{\cclrd{m}, \alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}~e_1~e_2$. If $e_1$ is not a value,
  reduce using (\emph{ctx}) with context ${\ident{cobind}_{\cclrd{m},\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}}~\_~e$. If $e_2$ is
  not a value reduce using (\emph{ctx}) with context ${\ident{cobind}_{\cclrd{m},\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}}~v~\_$.
  If both are values then we have
  $e_2 = \ident{Df}\langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle$
  from Lemma~\ref{thm:structural-df-canon} and so we can apply the (\emph{cobind}) reduction.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{merge}): $e = \ident{merge}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}} e_1$. If $e_1$ is not a value,
  reduce using (\emph{ctx}) with context $e = \ident{merge}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}}~\_$. If $e_1$ is
  a value, it must be a pair of vectors $(\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle, \ident{Df}\langle \textbf{v}'_0, \ldots, \textbf{v}'_l\rangle)$
  using Lemma~\ref{thm:structural-df-canon} and it can reduce using (\emph{merge}) reduction.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{df}): $e = \ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_n\rangle$. If $\textbf{e}_i$ is not a value
  then reduce using (\emph{ctx}) with the context $\ident{Df}\langle \ldots \rangle$.
  Otherwise, $\textbf{e}_0, \ldots, \textbf{e}_n$ are values and so $\ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_n\rangle$
  is also a value.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{split}, \emph{prev}): Similar. Either sub-expression is not a value, or the type
  guarantees that it is a stream with correct number of elements to enable the (\emph{split})
  or (\emph{prev}) reduction, respectively.
\end{proof}

\begin{theorem}[Safety of context-aware dataflow language]
  If $\Gamma \vdash e : \tau$ and $e \rightsquigarrow^{*} e'$ then either $e'$ is a value of type $\tau$ or
  there exists $e''$ such that $e' \rightsquigarrow e''$ and $\Gamma \vdash e'' : \tau$.
\end{theorem}
\begin{proof}
  Rule induction over $\rightsquigarrow^*$ using Theorem~\ref{thm:structural-df-pres} and Theorem~\ref{thm:structural-df-prog}.
\end{proof}


% ==================================================================================================
%
%     #####
%    #     #  ####  #    #  ####  #      #    #  ####  #  ####  #    #
%    #       #    # ##   # #    # #      #    # #      # #    # ##   #
%    #       #    # # #  # #      #      #    #  ####  # #    # # #  #
%    #       #    # #  # # #      #      #    #      # # #    # #  # #
%    #     # #    # #   ## #    # #      #    # #    # # #    # #   ##
%     #####   ####  #    #  ####  ######  ####   ####  #  ####  #    #
%
% ==================================================================================================

~

\section{Summary}

This chapter completes the key development of this thesis -- the presentation of the coeffect
framework, consisting of two calculi capturing properties of context-aware computations introduced
in Chapter~\ref{ch:applications}. In Chapters~\ref{ch:flat} and \ref{ch:semantics}, we focused on
whole-context properties of computations and we developed \emph{flat coeffect calculus} to capture them.
This chapter develops \emph{structural coeffect calculus}, which captures \emph{per-variable}
contextual properties. The system provides a precise analysis of liveness and dataflow and allows
other interesting uses such as tracking of variable accesses based on bounded linear logic.

Following the structure of the previous two chapters, the structural coeffect calculus is parameterized
by a \emph{structural coeffect algebra}. The two definitions are similar -- both require operations
$\cseq$ and $\cpar$ that model sequential and pointwise composition, respectively. For flat
coeffects, we required $\czip$ to model context merging. For structural coeffects, we
instead use a vector (free monoid) with the $\atimes$ operation -- which serves a similar purpose
as $\czip$. In order to keep track of separate annotations for each variable, we use a system with
explicit structural rules (contraction, weakening and exchange) that manipulate the structure
of variables and the structure of annotations at the same time.

The structural coeffect calculus has desirable equational properties that are satisfied only by
certain flat coeffect calculi. In particular, we show that $\beta$-reduction and $\eta$-expansion
have the typing preservation property for any instance of the structural coeffect calculus. These
two strong properties are desirable for programming languages, but are often not satisfied
(\eg~by languages with effects).

Finally, we discuss the semantics of the structural coeffect calculus in in terms of \emph{structural
indexed comonads}. As in Chapter~\ref{ch:semantics}, we first use the categorical semantics
to unify the different notions of context (bounded reuse, dataflow and liveness) and then use
it as a basis for translation that turns well-typed programs written in the structural coeffect
calculus into well-typed programs of a simple functional language. We give concrete reduction
rules for the target language, modelling \emph{structural dataflow} and prove type safety
of the language.

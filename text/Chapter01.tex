\chapter{Why context-aware programming matters}
\label{ch:intro}

Many advances in programming language design are driven by practical motivations. Sometimes,
these practical motivations are easy to see -- for example, when they come from an external change
such as the rise of multi-core processors. Sometimes, discovering the practical motivations is a
difficult task -- perhaps because we are so used to a certain way of doing things that we do not
even \emph{see} the flaws of our approach.

Before exploring the motivations for to this thesis, we briefly consider two recent practical
concerns that have led to the development of new programming languages. This helps to explain why
context-aware programming is important. The examples are by no means exhaustive, but they
are representative of the various kinds of motivations.

\paragraph{Parallel programming.}

The rise of multi-core CPUs is a clear example of an external development influencing
programming language research. As multi-core and multi-processor systems became ubiquitous,
languages had to provide better abstractions for parallel programming. This led to the industrial
popularity of \emph{immutable} data structures (and functional programming in general), software
transactional memory \cite{app-haskell-stm}, data-parallelism and also asynchronous
computing \cite{app-fsharp-async}.

In this case, the motivation is easy to see -- writing multi-core programs using earlier
abstractions, such as threads and locks, is difficult and error-prone. At the same time,
multi-core CPUs became a standard very quickly and so the lack of good language abstractions
was apparent.

\paragraph{Data access.}

Accessing ``big data'' is an example of a more subtle challenge. Initiatives like open
government data make more data available, but to access the data, one has to parse CSV and 
Excel files, issue SQL or SPARQL queries (to query database and the semantic web, respectively).

Technologies like LINQ \cite{app-linq} make querying data significantly easier. But perhaps
because accessing data became important more gradually, it was not easy to see that SQL queries,
embedded as parameterized strings\footnote{The dominant approach is demonstrated, for example,
by a review of SQL injection prevention techniques by Clarke \cite{app-sql-injection}}, are a
poor solution \emph{before} better approaches were developed.

This is even more the case for \emph{type providers} -- a recent feature in F\# that integrates
external data sources directly into the type system of the language and thus makes data explorable
directly from the source code editor (through features such as auto-completion on object members).
It is not easy to see the limitations of standard techniques (using HTTP requests to query REST
services or parsing CSV files and using string-based lookup) until one sees just how much type
providers change the data-scientist's workflow\footnote{This is difficult to explain in writing
and so the reader is encouraged to watch a video showing type providers for the WorldBank and CSV
data sources \cite{app-fsharp-world}.}.

\paragraph{Context-aware programming.}

In this thesis, we argue that the next important practical challenge for programming language
designers is designing languages that are better at working with (and understanding) the
\emph{context in which programs are executed}.

This challenge is of the kind that is not easy to see, perhaps because we are so used to
doing things in certain ways that we cannot see their flaws. In this chapter, we aim to
expose such flaws. We look at a number of basic programs that rely on contextual
information, we explain why the currently dominant solutions are inappropriate.

\paragraph{The thesis.}
Our key claim is that the theory of \emph{coeffects} that we develop in this thesis provides
a uniform and less error-prone way of writing programs that rely on the context, or
execution environment, in which they run. Perhaps most importantly, coeffects provide a single 
conceptual framework that can capture a wide range of previously disconnected notions of 
context-awareness and thus make understanding of context easier. 

Thanks to coeffects, programming languages for rich and diverse execution environments will
be able to offer a simple, safe and unified programming model for interacting with the 
environment. In this thesis, we develop the theoretical foundations for such languages and
we develop a prototype implementation that illustrates the benefits of coeffects, but also 
serves as a rich guide for future langauge implementers.



% ==================================================================================================
%
%     ###                  #                    #
%    #   #                 #                    #
%    #       ###   # ##   ####    ###   #   #  ####           ###   #   #   ###   # ##    ###
%    #      #   #  ##  #   #     #   #   # #    #     #####      #  #   #      #  ##  #  #   #
%    #      #   #  #   #   #     #####    #     #             ####  # # #   ####  #      #####
%    #   #  #   #  #   #   #  #  #       # #    #  #         #   #  # # #  #   #  #      #
%     ###    ###   #   #    ##    ###   #   #    ##           ####   # #    ####  #       ###
%                                                                                                                                                                       
% ==================================================================================================


\section{Why context-aware programming matters}
\label{sec:intro-whymatters}

The phrase \emph{context in which programs are executed} sounds rather abstract and generic.
What notions of \emph{context} can be identified in modern software systems?
Different environments provide different resources (\eg~a database or GPS sensors), environments
are increasingly diverse (\eg~different mobile platforms with multiple partially incompatible versions).
Web applications are split between client, server and mobile components; mobile
applications must be aware of the physical environment while the ``internet of things'' makes
the environment even more heterogeneous. At the same time, applications access
rich data sources and need to be aware of provenance information and respect the security policies
from the environment.

Writing such context-aware (or environment-aware) applications is a fundamental problem of modern
software engineering. The state of the art relies on ad-hoc approaches -- using hand-written conditions
or pre-processors for conditional compilation. Common problems that developers face include:

\begin{itemize}
\item \textsc{System capabilities.} Libraries such as LINQ \cite{app-linq} let developers write code
  in a host language like C\# and then cross-compile it to multiple targets (including SQL, OpenCL
  or JavaScript \cite{app-hop-lang}). Part of the compilation (\eg~generating the SQL query) occurs
  at runtime and developers have no guarantee that it will succeed until the program is executed,
  because only subset of the host language is supported.

\item \textsc{Platform versions.} When developing cross-platform applications, different platforms
  (and different versions of the same platform) provide different API functions. Writing a
  cross-platform code usually relies on (fragile) conditional compilation or (equally fragile)
  dynamic loading.

\item \textsc{Security and provenance.} When working with data (be it sensitive database or social
   network data), we may have permission to access only some of the data and we may want to track
   \emph{provenance} information. However, this is not checked statically -- if a program attempts
   to access unavailable data, the access will be refused at run-time.

\item \textsc{Resources \& data availability.} When creating a mobile application, the program may
  (or may not) be granted access to device capabilities such as GPS sensor, social updates or battery
  status. We would like to know which of the capabilities are required and which are optional
  (\ie~enhance the user experience, but there is a fallback strategy). Equally, on the server-side,
  we might have access to different database tables, depending on the role of the user.
\end{itemize}

\noindent
Most developers do not perceive the above as programming language flaws. They are simply common
programming problems (at most somewhat annoying and tedious) that have to be solved. However, this
is because it is not apparent that a suitable language extension could make the above problems
significantly easier to solve. As the number of distinct contexts and their diversity increases,
these problems will become even more commonplace.

The following sub-sections explore 4 examples in more detail. The examples are chosen to
demonstrate two distinct forms of contexts that are studied in this thesis -- the first two are
related to the program environment and the latter two are associated with individual variables of
the program.

% --------------------------------------------------------------------------------------------------

\begin{figure}
\begin{equation*}
\begin{array}{l}
\kvd{for}~\ident{header},\ident{value}~\kvd{in}~\ident{header}~\kvd{do}\\[-0.25em]
\hspace{2em}\kvd{match}~\ident{header}~\kvd{with}\\[-0.25em]
\hspace{2em}|~\str{accept} \rightarrow~ \ident{req.Accept} \leftarrow \ident{value}\\[-0.25em]
%
\prepk{\#if}~\prepi{FX\_NO\_WEBREQUEST\_USERAGENT}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~ \ident{req.UserAgent} \leftarrow \ident{value}\\[-0.25em]
\prepk{\#else}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~
  \ident{req.Headers}.[\,\ident{HttpHeader.UserAgent}\,] \leftarrow \ident{value}\\[-0.25em]
\prepk{\#endif}\\[-0.25em]
%
\prepk{\#if}~\prepi{FX\_NO\_WEBREQUEST\_REFERER}\\[-0.25em]
\hspace{2em}|~\str{referer} \rightarrow~ \ident{req.Referer} \leftarrow \ident{value}\\[-0.25em]
\prepk{\#else}\\[-0.25em]
\hspace{2em}|~\str{referer} \rightarrow~
  \ident{req.Headers}.[\,\ident{HttpHeader.Referer}\,] \leftarrow \ident{value}\\[-0.25em]
\prepk{\#endif}\\[-0.25em]
%
\hspace{2em}|~\ident{other} \rightarrow~ \ident{req.Headers}.[\,\ident{other}\,] \leftarrow \ident{value}\\[-0.25em]
\end{array}
\end{equation*}

\figcaption{Conditional compilation in the HTTP module of the F\# Data library}
\label{fig:introduction-context-http}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#1: Platform versioning}

The diversity across devices means that developers need to target an increasing number of platforms
and possibly also multiple versions of each platform. For Android, there is a number called
API level \cite{app-android-apilevel} which ``uniquely identifies the framework API revision offered
by a version of the Android platform''. Most changes in the libraries (but not all) are additive.

Equally, in the .NET ecosystem, there are multiple versions of the .NET runtime, mobile and
portable versions of the framework etc. The differences may be subtle -- for example, some instance
methods and properties are omitted to make the mobile version of the library smaller, some functionality
is not available at all, but naming can also vary between versions.

For example, the Figure~\ref{fig:introduction-context-http} shows an excerpt from the \ident{Http} module
in the F\# Data library\footnote{The file version shown here is available at:
\url{https://github.com/fsharp/FSharp.Data/blob/b4c58f4015a63bb9f8bb4449ab93853b90f93790/src/Net/Http.fs}}.
The example uses conditional compilation to target multiple versions of the .NET framework. Such code
is difficult to write -- to see whether a change is correct, it had to be recompiled for all combinations
of pre-processor flags -- and maintaining the code is equally hard. The above example could be refactored
and the .NET API could be cleaner, but the fundamental issue remains. If the language does not understand
the context (here, the different platforms and platform versions), it cannot provide any static
guarantees about the code.

As an alternative to conditional compilation, developers can use dynamic loading. For example,
on Android, programs can access API from higher level platform dynamically using techniques like
reflection and writing wrappers. This is even more error prone. As noted in an article\footnote{Retrieved
from: \url{http://android-developers.blogspot.com/2009/04/backward-}\\\url{compatibility-for-android.html}}
introducing the technique ``Remember the mantra: if you haven't tried it, it doesn't work.''
Again, it would be reasonable to expect that statically-typed languages can provide a better solution.

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#2: System capabilities}

Another example related to the previous one is when libraries use meta-programming techniques,
such as LINQ \cite{app-linq,app-linq-essence} or F\# quotations \cite{app-fsharp-metaprog}, to
translate code written in a subset of a host language to some other target language, such as SQL,
OpenCL or JavaScript. For database access, this is a recently developed technique replacing embedded
SQL discussed in the introduction, but it is a more broadly applicable technique for programming
in heterogeneous environments. It lets developers target multiple runtimes that have limited
execution capabilities.

For example, the following LINQ query written in C\# queries a database and
selects those product names where the first upper case letter is ``C'':
%
\begin{equation*}
\begin{array}{l}
\kvd{var}~\ident{db} = \kvd{new}~\ident{NorthwindDataContext}();\\[0.25em]
\kvd{from}~\ident{p}~\kvd{in}~\ident{db.Products}\\[-0.25em]
\kvd{where}~\ident{p.ProductName.First}(\lambda \ident{c} \rightarrow \ident{Char.IsUpper}(\ident{c})) == \str{C}\\[-0.25em]
\kvd{select}~\ident{p.ProductName};
\end{array}
\end{equation*}
%
This appears as a perfectly valid code and the C\# compiler accepts it. However, when the program
is executed, it fails with the following error:
%
\begin{quote}
\emph{Unhandled Exception: \texttt{System.NotSupportedException}: Sequence operators
not supported for type \texttt{System.String}.}
\end{quote}
%
The problem is that LINQ can only translate a \emph{subset} of normal C\# code. The above snippet
uses the \ident{First} method to iterate over characters of a string, which is not supported. This is
not a technical limitation of LINQ, but a fundamental problem of an approach where code written 
using libraries for one execution environment is translated and run in another, more limited, 
execution environment.

When cross-compiling to a limited environment, we cannot always support the full source language.
The example with LINQ and SQL demonstrates the importance of this problem. As of March 2014,
Google search returns 11,800 results for the message above and even more results (44,100) for a
LINQ error message \emph{``Method X has no supported translation to SQL''} caused by a similar
limitation.

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#3: Confidentiality and provenance}

The previous two examples were related to the non-existence of some library functions in a different
execution environment. Another common factor was that they were related to the execution context of
the whole program or a function scope. However, contextual properties can also be associated with
specific variables.

For example, consider the following code sample that accesses a database by building a SQL query
using string concatenation. For the purpose of the demonstration, this example does not use LINQ,
but an older approach with a parameterized SQL query written as a string:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{query} = \ident{sprintf}~\str{SELECT * FROM Products WHERE Name='\%s'}~\ident{name}\\[-0.25em]
\kvd{let}~\ident{cmd} = \kvd{new}~\ident{SqlCommand}(\ident{query})\\[-0.25em]
\kvd{let}~\ident{reader} = \ident{cmd.ExecuteReader}()
\end{array}
\end{equation*}
%
The code compiles without error, but it contains a major security flaw called \emph{SQL injection}
\cite{app-sql-injection}. An attacker could enter \str{'; DROP TABLE Products -{}-} as the
\ident{name} and delete the database table ``Products''. For this reason, most libraries discourage
building SQL commands by string concatenation, but there are still many systems that do so.

Again, this example demonstrates a more general property. Sometimes, it is desirable to track additional
metadata about values that are in some ways special. Such metadata can determine how the values
can be used. Here, the value stored in \ident{name} comes from the user input. This information about 
the value should be propagated to \ident{query}. The \ident{SqlCommand} object should then require 
arguments that can not directly contain user input.

Similarly, if we had \ident{password} or \ident{creditCard} variables in a client/server web application,
these should be annotated as sensitive and it should not be possible to send their values over an
unsecured network connection.

In the security context, such marking of values (but at run-time) is called \emph{tainting}
\cite{app-tainting-sql}, but the technique is a special case of more general \emph{provenance
tracking} \cite{app-provenance-future}. This can be useful when working with data in other contexts.
For example, data journalists might want to propagate metadata about the quality and the
information source -- is the source trustworthy? Is the data up-to-date? Such metadata could
propagate to the result and tell us important information about the calculated results.

% --------------------------------------------------------------------------------------------------

\subsection{Context-awareness \#4: Checking array access patterns}
\label{sec:intro-why-array}

The final example leaves the topic of cross-platform and distributed computing. We focus on
checking how arrays are accessed. This is a simpler version of the dataflow programming
examples used later in the thesis.

Consider a simple programming language with arrays where the $n^{\textit{th}}$ element of an
array \ident{arr} is accessed using $\ident{arr}[n]$. We focus on writing stencil computations
(such as image blurring, Conway's game of life or convolution) where all arrays are of
the same size and the system provides a \emph{cursor} pointing to a current location in the
stencil. We assume that the keyword \kvd{cursor} returns the current location in the stencil.

The following example implements a simple one-dimensional cellular automaton, reading from the
\ident{input} array and writing to \ident{output}:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{sum}=\ident{input}[\kvd{cursor} - 1] ~+~ \ident{input}[\kvd{cursor}] ~+~ \ident{input}[\kvd{cursor} + 1]\\[-0.25em]
\kvd{if}~\ident{sum}=2 ~||~ (\ident{sum}=1 ~\&\&~ \ident{input}[\kvd{cursor} - 1] = 0)\\[-0.25em]
\kvd{then}~\ident{output}[\kvd{cursor}] \leftarrow 1 ~\kvd{else}~\ident{output}[\kvd{cursor}] \leftarrow 0
\end{array}
\end{equation*}
%
In this example, we use the term \emph{context} to refer to the values in the array around the
current location provided by \kvd{cursor}. The interesting question is, how much of the context
(\ie~how far in the array) does the program access.

This is contextual information attached to individual (array) variables.
In the above example, we want to track that \ident{input} is accessed in the range $\langle-1, 1 \rangle$
while \ident{output} is accessed in the range $\langle 0, 0 \rangle$. When calculating the ranges,
we need to be able to compose ranges $\langle-1,-1 \rangle$, $\langle 0,0 \rangle$ and $\langle 1,1 \rangle$
(based on the three accesses on the first line).

Access patterns can be used to efficiently compile the computation
by preallocating the necessary space (as we know which sub-range of the array might be accessed).
It also allows better handling of boundaries \cite{app-stencil-dsl}. For example, to simplify
wrap-around behaviour we could pad the \ident{input} with a known number of elements from the
other side of the array.


% ==================================================================================================
%
%    #
%    #
%    #       ###   # ##    ## #  #   #   ###    ## #   ###    ###
%    #          #  ##  #  #  #   #   #      #  #  #   #   #  #
%    #       ####  #   #   ##    #   #   ####   ##    #####   ###
%    #      #   #  #   #  #      #  ##  #   #  #      #          #
%    #####   ####  #   #   ###    ## #   ####   ###    ###   ####
%                         #   #                #   #
%                          ###                  ###
%
% ==================================================================================================


\section{Towards context-aware languages}

The four examples presented in the previous section cover different kinds of \emph{context}.
The context includes notions such as execution environment, capabilities provided by the
environment or input and metadata about the input and variables through which it is accessed.

The different applications can be broadly classified into two categories -- those that
speak about the environment and those that speak about individual inputs (variables). In this
thesis, we refer to them as \emph{flat coeffects} and \emph{structural coeffects}, respectively:

\begin{itemize}
\item \textsc{Flat coeffects} represent additional data, resources and metadata that are
   available in the execution environment (regardless of how they are accessed in a program).
   Examples include resources such as GPS sensors and battery status (on a phone), databases
   (on the server), or software framework (or library) version.

\item \textsc{Structural coeffects} capture additional metadata related to inputs. This can include
   provenance (source of the input value), usage information (how often is the value
   accessed and in what ways) or security information (whether it contain sensitive data or not).
\end{itemize}
%
This thesis follows the tradition of statically typed programming languages. As such, we
attempt to capture such contextual information in the type system of context-aware programming
languages. The type system should provide both safety guarantees (as in the first three examples)
and also static analysis useful for optimization (as in the last example).

Although the main focus of this thesis is on the underlying theory of \emph{coeffects} and on
their structure, the following section briefly demonstrates the features that a practical
context-aware language, based on the theory of coeffects, can provide.

% --------------------------------------------------------------------------------------------------

\subsection{Context-aware languages in action}
\label{sec:intro-context-example}

As an example, consider a news reader app consisting of a server-side component (which stores the
news in an SQL database) and a number of clients applications for popular platforms (iPhone, Windows
Phone, etc.). A simplified code excerpt that might appear somewhere in the implementation is shown in
Figure~\ref{fig:introduction-sample}.

We assume that the language supports cross-compilation and splits the single program into three
components: one for the server-side and two for the client-side, for iPhone and Windows Phone,
respectively. The cross-compilation could be done in a way similar to Links \cite{app-distributed-links},
but we do not require explicit annotations specifying the target platform.

If we were writing the code using current mainstream technologies, we would have to create three
completely separate components. The server-side would include the \ident{fetchNews} function, which
queries the database. The iPhone version would include \ident{fetchLocalNews}, which gets the current
GPS location and performs a call to the remote server and \ident{iPhoneMain}, which constructs the
user-interface. For Windows, we would also need \ident{fetchLocalNews}, but this time with
\ident{windowsMain}. When using a language that can be compiled for all of the platforms, we would need
a number of \prepk{\#if} blocks to delimit the platform-specific parts.

To support cross-compilation, the language needs to be context-aware. Each of the function has a
number of context demands. The \ident{fetchNews} function needs to have access to a database;
\ident{fetchLocalNews} needs access to a GPS sensor and to a network (to perform the remote call).
However, it does not need a specific platform -- it can work on both iPhone and Windows. The last
two platform-specific functions inherit the requirements of \ident{fetchLocalNews} and additionally
also require a specific platform.


% --------------------------------------------------------------------------------------------------

\begin{figure}
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{fetchNews}(\ident{loc}) =\\[-0.25em]
\hspace{1em} \kvd{let}~\ident{cmd} = \ident{sprintf}~\str{SELECT * FROM News WHERE Location='\%s'}~\ident{loc}\\[-0.25em]
\hspace{1em} \ident{query}(\ident{cmd}, \ident{password})\\[-0.25em]
\\[-1.0em]
\kvd{let}~\ident{fetchLocalNews}() =\\[-0.25em]
\hspace{1em} \kvd{let}~\ident{loc} = \ident{gpsLocation}()\\[-0.25em]
\hspace{1em} \kvd{remote}~\ident{fetchNews}(\ident{loc})\\[-0.25em]
\\[-1.0em]
\kvd{let}~\ident{iPhoneMain}() = \\[-0.25em]
\hspace{1em} \ident{createiPhoneListing}(\ident{fetchLocalNews})\\[-0.25em]
\\[-1.0em]
\kvd{let}~\ident{windowsMain}() = \\[-0.25em]
\hspace{1em} \ident{createWindowsListing}(\ident{fetchLocalNews})
\end{array}
\end{equation*}

\figcaption{Client/server news reader app implemented in a context-aware language}
\label{fig:introduction-sample}
\end{figure}

% --------------------------------------------------------------------------------------------------

\newcommand{\introfuncblack}[3]{ \ident{#1 \hspace{-1em}\footnotesize{@} \{ #2 \}} $\rightarrow$ \ident{#3}  }
\newcommand{\introfunc}[3]{ \ident{#1 \hspace{-1em}\footnotesize{@} \aclrd{\{ #2 \}}} $\rightarrow$ \ident{#3}  }
\newcommand{\introvar}[2]{ \ident{#1 \hspace{-1em}\footnotesize{@} \cclrd{#2} } }

% --------------------------------------------------------------------------------------------------

\subsection{Understanding context with types}

The approach advocated in this thesis is to track information about context demands using
the type system. To make this practical, the system should also provide at least a partial support for
automatic type inference, as the information about context demands makes the types more complex.
An inspiring example might be the F\# support for units of measure \cite{app-units} -- the user has
to explicitly annotate constants, but the rest of the information is inferred automatically.

Furthermore, integrating contextual information into the type system can provide information for
modern developer tools. For example, many editors for F\# display inferred types when placing the 
mouse pointer over an identifier. For \ident{fetchLocalNews}, the tip could appear as follows:
%
\definecolor{tooltipy}{rgb}{0.98,0.97,0.76}
\definecolor{tooltipb}{rgb}{0.7,0.7,0.7}
\vspace{0.5em}
\begin{equation*}
\hspace{5em}
\begin{array}{l}
\ident{fetchLocalNews}\\
\hspace{1em} \fcolorbox{tooltipb}{tooltipy}{
	\introfuncblack{unit}{gps, rpc}{(news~list)~async}
}
\end{array}
\end{equation*}
\vspace{0.5em}

\noindent
Here, we use the notation $\tau_1 \,\ident{\hspace{-1em}\footnotesize{@}}\, c \rightarrow \tau_2$ to denote
a function that takes an input of type $\tau_1$, produces a result of type $\tau_2$ and has additional
context demands specified by $c$. In the above example, the annotation $c$ is simply a set of
required resources or capabilities. However, a more complex structure could be used as well, for example,
including the Android API level as an integer.

The following summary shows the types of the functions from the code sample in
Figure~\ref{fig:introduction-sample}. These guide code generation by specifying which
function should be compiled for which of the platforms, but they also provide documentation
for the developers. In addition to function annotations, we also show the annotation attached
to the \ident{password} variable:
%
\begin{equation*}
\begin{array}{lcl}
 \ident{password} &:& $\introvar{string}{sensitive}$\\[-0.25em]
 \ident{fetchNews} &:& $\introfunc{location}{database}{news~list}$\\[0.5em]
 \ident{gpsLocation} &:& $\introfunc{unit}{gps}{location}$\\[-0.25em]
 \ident{fetchLocalNews} &:& $\introfunc{location}{gps, rpc}{news~list}$\\[0.5em]
 \ident{iPhoneMain} &:& $\introfunc{unit}{ ios, gps, rpc}{unit}$\\[-0.25em]
 \ident{windowsMain} &:& $\introfunc{unit}{ windows, gps, rpc}{unit}$
\end{array}
\end{equation*}
%
The example combines two separate notions of context. The variable \ident{password} is annotated
with a single (per-variable) annotation specifying tainting while
functions are annotated with a set of resource requirements.

The concrete syntax is just for illustration and
some information could even be mapped to other visual representations -- for example, differently
coloured backgrounds for platform-specific functions. The key point is that the type provides a
number of pieces of useful information:

\begin{itemize}
\item The \ident{password} variable is available in the context (we assume it has been declared
  earlier), but is marked as sensitive, which restricts how it can be used. In particular, we
  cannot return it as a result of a function that is called via a remote call (\eg~\ident{fetchNews})
  as that would leak sensitive data over an unsecured connection.

\item The \ident{fetchNews} function requires database access and so it can only run on the server-side
  (or on a thick client with a local copy of the database, such as a desktop computer with an offline mode).

\item The \ident{gpsLocation} function accesses the GPS sensor and since we call it 
  from \texttt{fetchLocalNews}, this function also requires GPS (the requirement is propagated
  automatically).

\item We can compile the program for two client-side platforms -- the entry points are \ident{iPhoneMain}
  and \ident{windowsMain} and require iOS and Windows user-interface libraries, together with
  GPS and the ability to perform remote calls over the network.
\end{itemize}

\noindent
The details of how the cross-compilation would work are out of the scope of this thesis. However,
one can imagine that the compiler would take multiple sets of references (representing the different
platforms), expose the \emph{union} of the functions, but annotate each with the required platform.
Then, it would produce multiple different binaries -- here, one for the server-side (containing
\ident{fetchNews}), one for iPhone and one for Windows.

In this scenario, the main benefit of using an integrated context-aware language would be the
ability to design appropriate abstractions using standard mechanisms of the language. For
cross-compilation, we can structure code using functions, rather than relying on \prepk{\#if}
directives. Similarly, the splitting between client-side, server-side and shared code can be
done using ordinary functions and modules (with shared functions reused) -- rather than having
to split the application into separate independent libraries or projects.

The purpose of this section was to show that many modern programs rely on the context in which
they execute in non-trivial ways. Thus designing context-aware languages is an important
practical problem for language designers. The sample serves more as a motivation than as a
technical background for this thesis. We explore more concrete examples of properties that
can be tracked using the systems developed in this thesis in Chapter~\ref{ch:applications}.

% --------------------------------------------------------------------------------------------------

\section{Theory of context dependence}
\label{sec:intro-theory}

The previous section introduced the idea of context-aware languages from the practical perspective.
As already discussed, we approach the problem from the perspective of statically typed programming
languages. This section outlines how can contextual information be integrated into the
standard framework of static typing. This section is intended only as an informal overview and
complete review of related work is available in Chapter~\ref{ch:pathways}.

\paragraph{Type systems.}
A type system is a form of static analysis that is usually specified by \emph{typing judgements}
such as $\Gamma \vdash e : \tau$. The judgement specifies that, given some variables described by
the context $\Gamma$, the expression $e$ has a type $\tau$.
The variable context $\Gamma$ is necessary to determine the type of expressions. Consider an
expression $x + y$. In many languages, including Java, C\# and F\#, the type could be \ident{int},
\ident{float} or \ident{string}, depending on the types of the variables. For example,
the following is a valid typing judgement in F\# \cite{app-fsharp}:
%
\begin{equation*}
x\!:\!\ident{int},~y\!:\!\ident{int} \vdash x+y : \ident{int}
\end{equation*}
%
This judgement assumes that the type of $x$ and $y$ is \ident{int} and so the result must also
be \ident{int}. The expression might also be typeable in a context $x\!:\!\ident{string},~y\!:\!\ident{string}$,
but not in a context where types of $x$ and $y$ do not match.

\paragraph{Tracking evaluation effects.}
Type systems can be extended in numerous ways. The types can be more precise, for example, by specifying
the range of an integer. However, it is also possible to track what program \emph{does} when executed.
In ML-like languages, the following is a valid judgement:
%
\begin{equation*}
x\!:\!\ident{int} \vdash \ident{print}~x : \ident{unit}
\end{equation*}
%
The judgement states that the expression $\ident{print}~x$ has a type \ident{unit}. This is correct,
but it ignores the important fact that the expression has a \emph{side-effect} and prints a number
to the console. In purely functional languages, this would not be possible. For example, in Haskell,
the type would be $\ident{IO unit}$ meaning that the result is a \emph{computation} that performs I/O
effects and then returns \ident{unit} value. Here, we look at another option for tracking effects,
which is to extend the judgement with additional information about the effects. The judgement in a
language with effect system would look as follows:
%
\begin{equation*}
x\!:\!\ident{int} \vdash \ident{print}~x : \ident{unit}~\&~\aclrd{\{ \ident{console} \}}
\end{equation*}
%
Effect systems add \emph{effect annotation} as another component of the typing judgement. In the above
example, the return type is \ident{unit}, but the effect annotation informs us that the expression
also accesses \ident{console} as part of the evaluation. To track such information, the compiler needs
to understand the effects of primitive built-in functions -- such as \ident{print}.

The crucial part of type systems is dealing with different forms of composition. Assume
we have a function \ident{read} that reads from the console and a function \ident{send} that sends
data over the network. The type system should correctly infer that the effects of an
expression $\ident{send}(\ident{read}())$ are $\{ \ident{console}, \ident{network} \}$.

Effect systems are an established idea, but they are suitable only for tracking properties of a
certain kind. They can be used for properties that describe how programs \emph{affect} the environment.
For context-aware languages, we instead need to track what programs \emph{require} from the 
environment. This intuitive distinction is made more precise in Section~\ref{sec:semantics-related}. 

\paragraph{Tracking context demands.}

The systems for tracking of context demands developed in this thesis are inspired by the idea
of effect systems. To demonstrate our approach, consider the following call from the sample program
shown earlier -- first using standard ML-like type system:
%
\begin{equation*}
\ident{password}\!:\!\ident{string},~\ident{cmd}\!:\!\ident{string}
  \vdash \ident{query}(\ident{cmd}, \ident{password}, \kvd{time}) : \ident{news list}
\end{equation*}
%
The expression queries a database and gets back a list of news based on the spefieid \kvd{time}. 
There are three pieces of contextual information that are desirable to track for this expression. 
First, the call to the \ident{query} primitive requires \emph{database access}. Second, 
the \ident{password} argument needs to be marked as \emph{sensitive value} to avoid sending it over
an unsecure network connection. Third, the expression uses a special construct \kvd{time}, which
requires access to \emph{system clock}. The \emph{coeffect systems} developed in this thesis 
capture this information in the following way (we slightly refine the notation later):
%
\begin{equation*}
\begin{array}{l}
 \coctx{( \ident{password}\!:\!\coctx{\ident{string}}{\hspace{-0.75em}\ident{\cclrd{\footnotesize sensitive}}},
   \ident{cmd}\!:\!\ident{string})}{ \aclrd{\{ \ident{database}, \ident{clock} \}}}  \\[-0.1em]
 \hspace{3em} \vdash\ident{query}(\ident{cmd}, \ident{password}, \kvd{time}) : \ident{news list}
\end{array}
\end{equation*}
%
The typing judgement includes an additional annotation that now captures 
contextual requirements of the expression. The annotation is attched to the variable context 
$\Gamma$. As discussed later (Section~\ref{sec:flat-calculus-understanding}), this better reflects
how contextual information are used in the type system, but it also matches the semantics 
(Section~\ref{sec:semantics-theory}). Rather than attaching additional information to the
\emph{resulting type}, we attach them to the variable context $\Gamma$. 

In other words, the context in coeffect systems consists of the available variables, but also
tracks detailed information about the execution environment.
In the above example, the system tracks metadata about the variables and annotates \ident{password}
as sensitive and it tracks requirements about the execution environment, for example,
that the execution requires clock.

The example demonstrates the two kinds of coeffect systems outlined earlier. The tracking of
\emph{whole-context} information (such as environment requirements) is captured by the \emph{flat
coeffect calculus} developed in Chapter~\ref{ch:flat}, while the tracking of \emph{per-variable}
information is captured by the \emph{structural coeffect calculus} developed in Chapter~\ref{ch:structural}.

\paragraph{Context demands and lambda abstraction.}
The difference between effects and coeffects becomes apparent when we consider lambda abstraction.
Given an effectful expression such as $\ident{print}~\str{hi}$, the function $\lambda x.\ident{print}~\str{hi}$
is an effect free value that delays all effects. The message is printed when we run the function,
but not when the function is declared.

Contextual properties do not follow this pattern. As discussed in 
Section~\ref{sec:applications-structure-lam}, context demands cannot always be delayed. For 
example, consider a context-aware expression $\kvd{time}$ that requires access to system clock.
If we create this function on a server in a distributed system, send it to a client and then
run it, the function body can access the clock in two ways. It can use the clock of the server (when the
function was created), or it can use the clock of the client (when the function was executed).
We return to this example in Section~\ref{sec:applications-flat-distr}.

Another important difference between effects and coeffects becomes apparent when we consider their
semantics. It is well-known fact that \emph{effects} correspond to \emph{monads} and languages such as Haskell
use monads to provide a limited form of effect system. An interesting observation made in this thesis
is that \emph{coeffects}, or systems for tracking contextual information, correspond to the category
theoretical dual of monads called \emph{comonads}. The details are explained throughout the thesis.


% ==================================================================================================
%
%     ###           #      ##      #
%    #   #          #       #
%    #   #  #   #  ####     #     ##    # ##    ###
%    #   #  #   #   #       #      #    ##  #  #   #
%    #   #  #   #   #       #      #    #   #  #####
%    #   #  #  ##   #  #    #      #    #   #  #
%     ###    ## #    ##    ###    ###   #   #   ###
%
% ==================================================================================================

\section{Thesis outline}

This chapter shows why capturing how programs rely on the context, or execution environment, in 
which they execute is an important problem. We looked at a number of properties related to context 
that are currently handled in ad-hoc and error-prone ways. Next, we considered the properties in a
simplified, but realistic example of a client/server application for displaying local news.

Tracking of contextual properties may not be initially perceived as a major problem -- perhaps
because we are so used to write code in certain ways that prevent us from seeing the flaws. The
purpose of this chapter was to expose the flaws and convince the reader that there should be a
better solution. Finding the foundations of such better solution is the goal of this thesis:

\begin{itemize}
\item In Chapter~\ref{ch:pathways}, we give an overview of related work. Most importantly, we show
  that the idea of context-aware computations can be naturally approached from a number of
  directions developed recently in the theory of programming languages (including type and effect
  systems, categorical semantics and substructural logics).

\item In Chapter~\ref{ch:applications}, we present the first contribution of the thesis -- the discovery
  of the connection between a number of existing programming language features that are related
  to context. The chapter presents type systems and semantics for a number of systems and analyses
  (including dataflow, liveness analysis, distributed programming and Haskell's type classes).
  Our novel presentation reveals their similarity.

\item In Chapter~\ref{ch:flat} and Chapter~\ref{ch:structural}, we capture important contextual
  properties using a simple theoretical models. We develop the \emph{flat coeffect calculus} that
  captures per-context properties and \emph{structural coeffect calculus} that captures
  per-variable properties. We give a type system for the calculi and study their equational
  properties.

\item In Chapter~\ref{ch:semantics} we give categorical semantics of the flat coeffect calculus.
  This provides a unified way of defining the semantics of context-aware languages. We use the
  categorical semantics as a basis for \emph{categorically-inspired translation} that turns
  context-aware programs into programs in a simple functional language. We prove that well-typed
  context-aware programs are translated to programs that ``do not get stuck''. The development
  is repeated for structural coeffects in Chapter~\ref{ch:structural}.

\item In Chapter~\ref{ch:impl}, we use the translation as a basis for a prototype
  implementation of three simple context-aware programming languages. We use a format of web-based
  \emph{interactive essay} (available at \url{http://tomasp.net/coeffects}), which shows how 
  coeffects simplify programming with context by allowing the reader to write and run simple 
  context-aware programs, but also explore the theory behind the implementation including the 
  typing derivation and the translation.

\item Related work is presented in Chapter~\ref{ch:pathways} and, together with further work,
  throughout the thesis. Two important directions deserve further exploration. In Chapter~\ref{ch:further},
  we outline a unified coeffect system that is capable of capturing both flat and structural
  properties. We also include a brief discussion of a different approach to tracking contextual
  information that arises from modal logics.
\end{itemize}

\noindent
If there is a one thing that the reader should remember from this thesis, it is the fact that
there is a unified notion of \emph{context}, capturing many common scenarios in programming,
and that programming language designers need to provide ways for working with this context.
This greatly reduces the number of distinct concepts that software
developers need to keep in mind of when building applications for the rich and diverse
execution environments of the future.

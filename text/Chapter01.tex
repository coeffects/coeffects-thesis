%!TEX root = ../main.tex

% ==================================================================================================

\chapter{Why context-aware programming matters}
\label{ch:intro}

Many advances in programming language design are driven by practical motivations. Sometimes,
these practical motivations are easy to see -- for example, when they come from an external change
such as the rise of multi-core processors. Sometimes, discovering the practical motivations is a
difficult task -- perhaps because we are so used to a certain way of doing things that we do not
even \emph{see} the flaws of our approach.

Before exploring the motivations for to this thesis, we briefly consider two recent practical
concerns that have led to the development of new programming languages. This helps to explain why
context-aware programming is important. The examples are by no means representative, but they
illustrate various kinds of motivations well.

\paragraph{Parallel programming.}

The rise of multi-core CPUs is a clear example of an external development influencing
programming language research. As multi-core and multi-processor systems became ubiquitous,
languages had to provide better abstractions for parallel programming. This led to the industrial
popularity of \emph{immutable} data structures (and functional programming in general), software
transactional memory \cite{app-haskell-stm}, data-parallelism and also asynchronous
computing \cite{app-fsharp-async}.

In this case, the motivation is easy to see -- writing multi-core programs using earlier
abstractions, such as threads and locks, is difficult and error-prone. At the same time,
multi-core CPUs became a standard very quickly and so the lack of good language abstractions
was apparent.

\paragraph{Data access.}

Accessing ``big data'' sources is an example of a more subtle challenge. Initiatives like open 
government data\footnote{In the UK, the open government data portal is available at: \url{http://data.gov.uk/}}
certainly make more data available. However, to access the data, one has to parse CSV and Excel files,
issue SQL or SPARQL queries (to query database and the semantic web, respectively).

Technologies like LINQ \cite{app-linq} make querying data significantly easier. But perhaps
because accessing data became important more gradually, it was not easy to see that SQL queries,
embedded as parameterized strings\footnote{The dominant approach is demonstrated, for example, 
by a review of SQL injection prevention techniques by Clarke \cite{app-sql-injection}}, are a 
poor solution \emph{before} better approaches were developed.

This is even more the case for \emph{type providers} -- a recent feature in F\# that integrates
external data sources directly into the type system of the language and thus makes data explorable
directly from the source code editor (through features such as auto-completion on object members).
It is not easy to see the limitations of standard techniques (using HTTP requests to query REST
services or parsing CSV files and using string-based lookup) until one sees just how much type 
providers change the data-scientist's workflow\footnote{This is difficult to explain in writing 
and so the reader is encouraged to watch a video showing type providers for the WorldBank and CSV 
data sources \cite{app-fsharp-world}.}.

~\\

\paragraph{Context-aware programming.}

In this thesis, we argue that the next important practical challenge for programming language
designers is designing languages that are better at working with (and understanding) the
\emph{context in which programs are executed}.

This challenge is of the kind that is not easy to see, perhaps because we are so used to
doing things in certain ways that we cannot see their flaws. In this chapter, we aim to
expose such flaws. We look at a number of basic programs that rely on contextual
information, we explain why the currently dominant solutions are inappropriate and then 
briefly outline how this thesis solves the problems.

Putting deeper philosophical questions about the nature of scientific prog\-ress aside,
the goal of programming language research is generally to design languages that provide
more \emph{appropriate abstractions} for capturing common problems, are \emph{simple} and
more \emph{unified}. These are exactly the aims that we follow in this thesis. In this chapter, 
we explain what the common problems in context-dependent programming are. In 
Chapter~\ref{ch:flat} and Chapter~\ref{ch:structural}, we develop two simple calculi to 
understand and capture the structure of those problems and, finally, Chapter~\ref{ch:unified} 
unifies the two abstractions.



% ==================================================================================================
%                                                                                             
%     ###                  #                    #                                              
%    #   #                 #                    #                                              
%    #       ###   # ##   ####    ###   #   #  ####           ###   #   #   ###   # ##    ###  
%    #      #   #  ##  #   #     #   #   # #    #     #####      #  #   #      #  ##  #  #   # 
%    #      #   #  #   #   #     #####    #     #             ####  # # #   ####  #      ##### 
%    #   #  #   #  #   #   #  #  #       # #    #  #         #   #  # # #  #   #  #      #     
%     ###    ###   #   #    ##    ###   #   #    ##           ####   # #    ####  #       ###  
%                                                                                                                                                                       % ==================================================================================================


\section{Why context-aware programming matters}

The phrase \emph{context in which programs are executed} sounds rather abstract and generic.
What notions of \emph{context} can be identified in modern software systems?
Different environments provide different resources (\eg~a database or GPS sensors), environments 
are increasingly diverse (\eg~different mobile platforms with multiple partially incompatible versions). 
Web applications are split between client, server and mobile components; mobile
applications must be aware of the physical environment while the ``internet of things'' makes
the environment even more heterogeneous. At the same time, applications access
rich data sources and need to be aware of provenance information and respect the security policies 
from the environment.

Writing such context-aware (or environment-aware) applications is a fundamental problem of modern
software engineering. The state of the art relies on ad-hoc approaches -- using hand-written conditions
or pre-processors for conditional compilation. Common problems that developers face include:

\begin{itemize}
\item \textsc{System capabilities.} Libraries such as LINQ \cite{app-linq} let developers write code
  in a host language like C\# and then cross-compile it to multiple targets (including SQL, OpenCL 
  or JavaScript \cite{app-hop-lang}). Part of the compilation (\eg~generating the SQL query) occurs 
  at runtime and developers have no guarantee that it will succeed until the program is executed,
  because only subset of the host language is supported.

\item \textsc{Platform versions.} When developing cross-platform applications, different platforms
  (and different versions of the same platform) provide different API functions. Writing a
  cross-platform code usually relies on (fragile) conditional compilation or (equally fragile)
  dynamic loading.

\item \textsc{Security and provenance.} When working with data (be it sensitive database or social
   network data), we may have permission to access only some of the data and we may want to track
   \emph{provenance} information. However, this is not checked -- if a program attempts to access
   unavailable data, the access will be refused at run-time.

\item \textsc{Resources \& data availability.} When creating a mobile application, the program may
  (or may not) be granted access to device capabilities such as GPS sensor, social updates or battery
  status. We would like to know which of the capabilities are required and which are optional
  (\ie~enhance the user experience, but there is a fallback strategy). Equally, on the server-side,
  we might have access to different database tables, depending on the role of the user.
\end{itemize}

\noindent
Most developers do not perceive the above as programming language flaws. They are simply common
programming problems (at most somewhat annoying and tedious) that have to be solved. However, this
is because it is not apparent that a suitable language extension could make the above problems
significantly easier to solve. As the number of distinct contexts and their diversity increases,
these problems will become even more commonplace.

The following sub-sections explore 4 examples in more detail. The examples are chosen to
demonstrate two distinct forms of contexts that are studied in this thesis -- first two are
related to the program environment and the latter two are associated with individual variables of 
the program.

% --------------------------------------------------------------------------------------------------

\begin{figure}
\begin{equation*}
\begin{array}{l}
\kvd{for}~\ident{header},\ident{value}~\kvd{in}~\ident{header}~\kvd{do}\\[-0.25em]
\hspace{2em}\kvd{match}~\ident{header}~\kvd{with}\\[-0.25em]
\hspace{2em}|~\str{accept} \rightarrow~ \ident{req.Accept} \leftarrow \ident{value}\\[-0.25em]
%
\prepk{\#if}~\prepi{FX\_NO\_WEBREQUEST\_USERAGENT}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~ \ident{req.UserAgent} \leftarrow \ident{value}\\[-0.25em]
\prepk{\#else}\\[-0.25em]
\hspace{2em}|~\str{user-agent} \rightarrow~
  \ident{req.Headers}.[\,\ident{HttpHeader.UserAgent}\,] \leftarrow \ident{value}\\[-0.25em]
\prepk{\#endif}\\[-0.25em]
%
\prepk{\#if}~\prepi{FX\_NO\_WEBREQUEST\_REFERER}\\[-0.25em]
\hspace{2em}|~\str{referer} \rightarrow~ \ident{req.Referer} \leftarrow \ident{value}\\[-0.25em]
\prepk{\#else}\\[-0.25em]
\hspace{2em}|~\str{referer} \rightarrow~
  \ident{req.Headers}.[\,\ident{HttpHeader.Referer}\,] \leftarrow \ident{value}\\[-0.25em]
\prepk{\#endif}\\[-0.25em]
%
\hspace{2em}|~\ident{other} \rightarrow~ \ident{req.Headers}.[\,\ident{other}\,] \leftarrow \ident{value}\\[-0.25em]
\end{array}
\end{equation*}

\figcaption{Conditional compilation in the HTTP module of the F\# Data library}
\label{fig:introduction-context-http}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#1: Platform versioning}

The diversity across devices means that developers need to target an increasing number of platforms
and possibly also multiple versions of each platform. For Android, there is a number called
API level \cite{app-android-apilevel} which ``uniquely identifies the framework API revision offered
by a version of the Android platform''. Most changes in the libraries (but not all) are additive.

Equally, in the .NET ecosystem, there are multiple versions of the .NET runtime, mobile and
portable versions of the framework etc. The differences may be subtle -- for example, some instance
methods and properties are omitted to make the mobile version of the library smaller, some functionality 
is not available at all, but naming can also vary between versions.

For example, the Figure~\ref{fig:introduction-context-http} shows an excerpt from the \ident{Http} module
in the F\# Data library\footnote{The file version shown here is available at:
\url{https://github.com/fsharp/FSharp.Data/blob/b4c58f4015a63bb9f8bb4449ab93853b90f93790/src/Net/Http.fs}}.
The example uses conditional compilation to target multiple versions of the .NET framework. Such code
is difficult to write -- to see whether a change is correct, it had to be recompiled for all combinations
of pre-processor flags -- and maintaining the code is equally hard. The above example could be refactored
and the .NET API could be cleaner, but the fundamental issue remains. If the language does not understand
the context (here, the different platforms and platform versions), it cannot provide any static
guarantees about the code.

As an alternative to conditional compilation, developers can use dynamic loading. For example,
on Android, programs can access API from higher level platform dynamically using techniques like
reflection and writing wrappers. This is even more error prone. As noted in an article\footnote{Retrieved 
from: \url{http://android-developers.blogspot.com/2009/04/backward-}\\\url{compatibility-for-android.html}}
introducing the technique ``Remember the mantra: if you haven't tried it, it doesn't work.'' 
Again, it would be reasonable to expect that statically-typed languages can provide a better solution.

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#2: System capabilities}

Another example related to the previous one is when libraries use meta-programming techniques,
such as LINQ \cite{app-linq,app-linq-essence} or F\# quotations \cite{app-fsharp-metaprog}, to 
translate code written in a subset of a host language to some other target language, such as SQL, 
OpenCL or JavaScript. For database access, this is a recently developed technique replacing embedded 
SQL discussed in the introduction, but it is a more broadly applicable technique for programming
in heterogeneous environments. It lets developers targets multiple runtimes that have limited 
execution capabilities.

For example, the following LINQ query written in C\# queries a database and
selects those product names where the first upper case letter is ``C'':
%
\begin{equation*}
\begin{array}{l}
\kvd{var}~\ident{db} = \kvd{new}~\ident{NorthwindDataContext}();\\[0.25em]
\kvd{from}~\ident{p}~\kvd{in}~\ident{db.Products}\\[-0.25em]
\kvd{where}~\ident{p.ProductName.First}(\lambda \ident{c} \rightarrow \ident{Char.IsUpper}(\ident{c})) == \str{C}\\[-0.25em]
\kvd{select}~\ident{p.ProductName};
\end{array}
\end{equation*}
%
This appears as a perfectly valid code and the C\# compiler accepts it. However, when the program
is executed, it fails with the following error:
%
\begin{quote}
Unhandled Exception: \texttt{System.NotSupportedException}: Sequence operators
not supported for type \texttt{System.String}.
\end{quote}
%
The problem is that LINQ can only translate a \emph{subset} of normal C\# code. The above snippet
uses the \ident{First} method to iterate over characters of a string, which is not supported. This is
not a technical limitation of LINQ, but a fundamental problem of the approach.

When cross-compiling to a limited environment, we cannot always support the full source language.
The example with LINQ and SQL demonstrates the importance of this problem. As of March 2014,
Google search returns 11,800 results for the message above and even more results (44,100) for a
LINQ error message \emph{``Method X has no supported translation to SQL''} caused by a similar
limitation.

% --------------------------------------------------------------------------------------------------

\subsection{Context awareness \#3: Confidentiality and provenance}

The previous two examples were related to the non-existence of some library functions in a different
execution environment. Another common factor was that they were related to the execution context of 
the whole program or a function scope. However, contextual properties can also be associated with
specific variables.

For example, consider the following code sample that accesses a database by building a SQL query
using string concatenation. For the purpose of the demonstration, this example does not use LINQ, 
but an older approach with a parameterized SQL query written as a string:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{query} = \ident{sprintf}~\str{SELECT * FROM Products WHERE Name='\%s'}~\ident{name}\\[-0.25em]
\kvd{let}~\ident{cmd} = \kvd{new}~\ident{SqlCommand}(\ident{query})\\[-0.25em]
\kvd{let}~\ident{reader} = \ident{cmd.ExecuteReader}()
\end{array}
\end{equation*}
%
The code compiles without error, but it contains a major security flaw called \emph{SQL injection}
\cite{app-sql-injection}. An attacker could enter \str{'; DROP TABLE Products -{}-} as their 
\ident{name} and delete the database table ``Products''! For this reason, most libraries discourage 
building SQL commands by string concatenation, but there are still many systems that do so.

Again, this example demonstrates a more general property. Sometimes, it is desirable to track additional
meta-data about variables that are in some ways special. Such meta-data can determine how the variables
can be used. Here, \ident{name} comes from the user input. This information about the value should
be propagated to \ident{query}. The \ident{SqlCommand} object should then require arguments that can
not directly contain user input (in an unchecked form). 

Similarly, if we had \ident{password} or \ident{creditCard} variables in a client/server web application,
these should be annotated as sensitive and it should not be possible to send their values over an
unsecured network connection.

In the security context, such marking of values (but at run-time) is called \emph{tainting} 
\cite{app-tainting-sql}, but the technique is a special case of more general \emph{provenance}
tracking \cite{app-provenance-future}. This can be useful when working with data in other contexts. 
For example, data jounralsts might want to propagate meta-data about the quality and the 
information source -- is the source trustworthy? Is the data up-to-date? Such meta-data could 
propagate to the result and tell us important information about the calculated results.

% --------------------------------------------------------------------------------------------------

\subsection{Context-awareness \#4: Checking array access patterns}
\label{sec:intro-why-array}

The final example leaves the topic of cross-platform and distributed computing. We focus on
checking how arrays are accessed. This is a simpler version of the data-flow programming
examples used later in the thesis.

Consider a simple programming language with arrays where $n^{\mathit{th}}$ element of an
array \ident{arr} is accessed using $\ident{arr}[n]$. We focus on writing stencil computations
(such as image blurring, Conway's game of life or convolution) where all arrays are of
the same size and the system provides a \emph{cursor} pointing to a current location in the 
stencil. We assume that the keyword \kvd{cursor} returns the current location in the stencil.

The following example implements a simple one-dimensional cellular automaton, reading from the
\ident{input} array and writing to \ident{output}:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{sum}=\ident{input}[\kvd{cursor} - 1] ~+~ \ident{input}[\kvd{cursor}] ~+~ \ident{input}[\kvd{cursor} + 1]\\[-0.25em]
\kvd{if}~\ident{sum}=2 ~||~ (\ident{sum}=1 ~\&\&~ \ident{input}[\kvd{cursor} - 1] = 0)\\[-0.25em]
\kvd{then}~\ident{output}[\kvd{cursor}] \leftarrow 1 ~\kvd{else}~\ident{output}[\kvd{cursor}] \leftarrow 0
\end{array}
\end{equation*}
%
In this example, we use the term \emph{context} to refer to the values in the array around the
current location provided by \kvd{cursor}. The interesting question is, how much of the context
(\ie~how far in the array) does the program access.

This is contextual information attached to individual (array) variables.
In the above example, we want to track that \ident{input} is accessed in the range $\langle-1, 1 \rangle$
while \ident{output} is accessed in the range $\langle 0, 0 \rangle$. When calculating the ranges,
we need to be able to compose ranges $\langle-1,-1 \rangle$, $\langle 0,0 \rangle$ and $\langle 1,1 \rangle$
(based on the three accesses on the first line).

The information about access patterns can be used to efficiently compile the computation
by preallocating the necessary space (as we know which sub-range of the array might be accessed).
It also allows better handling of boundaries \cite{app-stencil-dsl}. For example, to simplify 
wrap-around behaviour we could pad the \ident{input} with a known number of elements from the 
other side of the array.


% ==================================================================================================
%
%    #                                                             
%    #                                                             
%    #       ###   # ##    ## #  #   #   ###    ## #   ###    ###  
%    #          #  ##  #  #  #   #   #      #  #  #   #   #  #     
%    #       ####  #   #   ##    #   #   ####   ##    #####   ###  
%    #      #   #  #   #  #      #  ##  #   #  #      #          # 
%    #####   ####  #   #   ###    ## #   ####   ###    ###   ####  
%                         #   #                #   #               
%                          ###                  ###                
%
% ==================================================================================================


\section{Towards context-aware languages}

The four examples presented in the previous section cover different kinds of \emph{context}.
The context includes notions such as execution environment, capabilities provided by the 
environment or input and meta-data about the input and variables through which it is accessed.

The different applications can be broadly classified into two categories -- those that
speak about the environment and those that speak about individual inputs (variables). In this
thesis, we refer to them as \emph{flat coeffects} and \emph{structural coeffects}, respectively:

\begin{itemize}
\item \textsc{Flat coeffects} -- represent additional data, resources and meta-data that are
   available in the execution environment (regardless of how they are accessed in a program).
   Examples include resources such as GPS sensors and battery status (on a phone), databases
   (on the server), or software framework (or library) version.

\item \textsc{Structural coeffects} -- capture additional meta-data related to inputs. This can include
   provenance (source of the input value), usage information (how often is the value
   accessed and in what ways) or security information (whether it contain sensitive data or not).
\end{itemize}
%
This thesis follows the tradition of statically typed programming languages. As such, we
attempt to capture such contextual information in the type system of context-aware programming
languages. The type system should provide both safety guarantees (as in the first three examples)
and also static analysis useful for optimization (as in the last example).

Although the main focus of this thesis is on the underlying theory of \emph{coeffects} and on
their structure, the following section briefly demonstrates the features that a practical
context-aware language, based on the theory of coeffects, can provide.

% --------------------------------------------------------------------------------------------------

\subsection{Context-aware languages in action}
\label{sec:intro-context-example}

As an example, consider a news reader app consisting of a server-side component (which stores the 
news in an SQL database) and a number of clients applications for popular platforms (Android, Windows 
Phone, etc.). A simplified code excerpt that might appear somewhere in the implementation is shown in
Figure~\ref{fig:introduction-sample}.

We assume that the language supports cross-compilation and splits the single program into three
components: one for the server-side and two for the client-side, for iPhone and Windows platforms,
respectively. The cross-compilation could be done in a way similar to Links \cite{app-distributed-links},
but we do not require explicit annotations specifying the target platform.

If we were writing the code using current mainstream technologies, we would have to create three
completely separate components. The server-side would include the \ident{fetchNews} function, which
queries the database. The iPhone version would include \ident{fetchLocalNews}, which gets the current
GPS location and performs a call to the remote server and \ident{iPhoneMain}, which constructs the
user-interface. For Windows, we would also need \ident{fetchLocalNews}, but this time with
\ident{windowsMain}. When using a language that can be compiled for all of the platforms, we would need
a number of \prepk{\#if} blocks to delimit the platform-specific parts.

To support cross-compilation, the language needs to be context-aware. Each of the function has a
number of context requirements. The \ident{fetchNews} function needs to have access to a database;
\ident{fetchLocalNews} needs access to a GPS sensor and to a network (to perform the remote call).
However, it does not need a specific platform -- it can work on both iPhone and Windows. The last
two platform-specific functions inherit the requirements of \ident{fetchLocalNews} and additionally
also require a specific platform.


% --------------------------------------------------------------------------------------------------

\begin{figure}
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{fetchNews}(\ident{loc}) =\\[-0.25em]
\hspace{1em} \kvd{let}~\ident{cmd} = \ident{sprintf}~\str{SELECT * FROM News WHERE Location='\%s'}~\ident{loc}\\[-0.25em]
\hspace{1em} \ident{query}(\ident{cmd}, \ident{password})\\[-0.25em]
\\[-1.0em]
\kvd{let}~\ident{fetchLocalNews}() =\\[-0.25em]
\hspace{1em} \kvd{let}~\ident{loc} = \ident{gpsLocation}()\\[-0.25em]
\hspace{1em} \kvd{remote}~\ident{fetchNews}(\ident{loc})\\[-0.25em]
\\[-1.0em]
\kvd{let}~\ident{iPhoneMain}() = \\[-0.25em]
\hspace{1em} \ident{createiPhoneListing}(\ident{fetchLocalNews})\\[-0.25em]
\\[-1.0em]
\kvd{let}~\ident{windowsMain}() = \\[-0.25em]
\hspace{1em} \ident{createWindowsListing}(\ident{fetchLocalNews})
\end{array}
\end{equation*}

\figcaption{Client/server news reader app implemented in a context-aware language}
\label{fig:introduction-sample}
\end{figure}

% --------------------------------------------------------------------------------------------------

\newcommand{\introfuncblack}[3]{ \ident{#1 \hspace{-1em}\footnotesize{@} \{ #2 \}} $\rightarrow$ \ident{#3}  }
\newcommand{\introfunc}[3]{ \ident{#1 \hspace{-1em}\footnotesize{@} \aclrd{\{ #2 \}}} $\rightarrow$ \ident{#3}  }
\newcommand{\introvar}[2]{ \ident{#1 \hspace{-1em}\footnotesize{@} \cclrd{#2} } }

% --------------------------------------------------------------------------------------------------

\subsection{Understanding context with types}

The approach advocated in this thesis is to track information about context requirements using
the type system. To make this practical, the system should also provide at least a partial support for
automatic type inference, as the information about context requirements makes the types more complex.
An inspiring example might be the F\# support for units of measure \cite{app-units} -- the user has
to explicitly annotate constants, but the rest of the information is inferred automatically.

Furthermore, integrating contextual information into the type system can provide information for
modern developer tools. For example, many editors for F\# display inferred types when placing mouse
pointer over an identifier. For \ident{fetchLocalNews}, the tip could appear as follows:
%
\definecolor{tooltipy}{rgb}{0.98,0.97,0.76}
\definecolor{tooltipb}{rgb}{0.7,0.7,0.7}
\vspace{0.5em}
\begin{equation*}
\hspace{5em}
\begin{array}{l}
\ident{\textbf{fetchLocalNews}}\\
\hspace{1em} \fcolorbox{tooltipb}{tooltipy}{
	\introfuncblack{unit}{gps, rpc}{(news~list)~async}
}
\end{array}
\end{equation*}
\vspace{0.5em}

\noindent
Here, we use the notation $\tau_1 \,\ident{\hspace{-1em}\footnotesize{@}}\, c \rightarrow \tau_2$ to denote
a function that takes an input of type $\tau_1$, produces a result of type $\tau_2$ and has additional
context requirements specified by $c$. In the above example, the annotation $c$ is simply a set of
required resources or capabilities. However, a more complex structure could be used as well, for example,
including the Android API level as an integer.

The following summary shows the types of the functions from the code sample in
Figure~\ref{fig:introduction-sample}. These guide code generation by specifying which
function should be compiled for which of the platforms, but they also provide documentation
for the developers. In addition to function annotations, we also show the annotation attached
to the \ident{password} variable:
%
\begin{equation*}
\begin{array}{lcl}
 \ident{password} &:& $\introvar{string}{sensitive}$\\[-0.25em]
 \ident{fetchNews} &:& $\introfunc{location}{database}{news~list}$\\[0.5em]
 \ident{gpsLocation} &:& $\introfunc{unit}{gps}{location}$\\[-0.25em]
 \ident{fetchLocalNews} &:& $\introfunc{location}{gps, rpc}{news~list}$\\[0.5em]
 \ident{iPhoneMain} &:& $\introfunc{unit}{ ios, gps, rpc}{unit}$\\[-0.25em]
 \ident{windowsMain} &:& $\introfunc{unit}{ windows, gps, rpc}{unit}$
\end{array}
\end{equation*}
%
The example combines two separate notions of context. The variable \ident{password} is annotated 
with a single (per-variable) annotation specifying tainting while
functions are annotated with a set of resource requirements. 

The concrete syntax used here is just for illustration. Furthermore,
some information could even be mapped to other visual representations -- for example, differently
coloured backgrounds for platform-specific functions. The key point is that the type provides a
number of useful information:

\begin{itemize}
\item The \ident{password} variable is available in the context (we assume it has been declared
  earlier), but is marked as sensitive, which restricts how it can be used. In particular, we
  cannot return it as a result of a function that is called via a remote call (\eg~\ident{fetchNews})
  as that would leak sensitive data over an unsecured connection.

\item The \ident{fetchNews} function requires database access and so it can only run on the server-side
  (or on a thick client with a local copy of the database, such as a desktop computer with an offline mode).

\item The \ident{gpsLocation} function accesses the GPS sensor and since we call it in
  from \texttt{fetchLocalNews}, this function also requires GPS (the requirement is propagated
  automatically).

\item We can compile the program for two client-side platforms - the entry points are \ident{iPhoneMain}
  and \ident{windowsMain} and require iOS and Windows user-interface libraries, together with
  GPS and the ability to perform remote calls over the network.
\end{itemize}

The details of how the cross-compilation would work are out of the scope of this thesis. However,
one can imagine that the compiler would take multiple sets of references (representing the different
platforms), expose the \emph{union} of the functions, but annotate each with the required platform.
Then, it would produce multiple different binaries -- here, one for the server-side (containing
\ident{fetchNews}), one for iPhone and one for Windows.

In this scenario, the main benefit of using an integrated context-aware language would be the
ability to design appropriate abstractions using standard mechanisms of the language. For
cross-compilation, we can structure code using functions, rather than relying on \prepk{\#if}
directives. Similarly, the splitting between client-side, server-side and shared code can be
done using ordinary functions and modules (with shared functions reused) -- rather than having 
to split the application into separate independent libraries or projects.

The purpose of this section was to show that many modern programs rely on the context in which
they execute in non-trivial ways. Thus designing context-aware languages is an important
practical problem for language designers. The sample serves more as a motivation than as a
technical background for this thesis. We explore more concrete examples of properties that
can be tracked using the systems developed in this thesis in Chapter~\ref{ch:applications}.

% --------------------------------------------------------------------------------------------------

\section{Theory of context dependence}
\label{sec:intro-theory}

The previous section introduced the idea of context-aware languages from the practical perspective.
As already discussed, we approach the problem from the perspective of statically typed programming
languages. This section outlines how can contextual information be integrated into the
standard framework of static typing. This section is intended only as an informal overview and 
complete review of related work is available in Chapter~\ref{ch:pathways}.

\paragraph{Type systems.}
A type system is a form of static analysis that is usually specified by \emph{typing judgements}
such as $\Gamma \vdash e : \tau$. The judgement specifies that, given some variables described by
the context $\Gamma$, the expression $e$ has a type $\tau$.
The variable context $\Gamma$ is necessary to determine the type of expressions. Consider an
expression $x + y$. In many languages, including Java, C\# and F\#, the type could be \ident{int},
\ident{float}, or even \ident{string}, depending on the types of the variables. For example, 
the following is a valid typing judgement in F\# \cite{app-fsharp}:
%
\begin{equation*}
x\!:\!\ident{int},~y\!:\!\ident{int} \vdash x+y : \ident{int}
\end{equation*}
%
This judgement assumes that the type of both $x$ and $y$ is \ident{int} and so the result must also
be \ident{int}. In F\#, the expression would also be typeable in a context $x\!:\!\ident{string},~y\!:\!\ident{string}$,
but not, for example, in a context where $x$ has a type \ident{int} and $y$ has a type \ident{string}.

\paragraph{Tracking evaluation effects.}
Type systems can be extended in numerous ways. The types can be more precise, for example, by specifying
the range of an integer. However, it is also possible to track what program \emph{does} when executed.
In ML-like languages, the following is a valid judgement:
%
\begin{equation*}
x\!:\!\ident{int} \vdash \ident{print}~x : \ident{unit}
\end{equation*}
%
The judgement states that the expression $\ident{print}~x$ has a type \ident{unit}. This is correct,
but it ignores the important fact that the expression has a \emph{side-effect} and prints a number
to the console. In purely functional languages, this would not be possible. For example, in Haskell,
the type would be $\ident{IO unit}$ meaning that the result is a \emph{computation} that performs I/O
effects and then returns \ident{unit} value. Here, we look at another option for tracking effects, 
which is to extend the judgement with additional information about the effects. The judgement in a 
language with effect system would look as follows:
%
\begin{equation*}
x\!:\!\ident{int} \vdash \ident{print}~x : \ident{unit}~\&~\aclrd{\{ \ident{console} \}}
\end{equation*}
%
Effect systems add \emph{effect annotation} as another component of the typing judgement. In the above
example, the return type is \ident{unit}, but the effect annotation informs us that the expression
also accesses \ident{console} as part of the evaluation. To track such information, the compiler needs
to understand the effects of primitive built-in functions -- such as \ident{print}.

The crucial part of type systems is dealing with different forms of composition. Assume
we have a function \ident{read} that reads from the console and a function \ident{send} that sends
data over the network. The type system should correctly infer that the effects of an
expression $\ident{send}(\ident{read}())$ are $\{ \ident{console}, \ident{network} \}$.

Effect systems are an established idea, but they are suitable only for tracking properties of a
certain kind. They can be used for properties that describe how programs \emph{affect} the environment.
For context-aware languages, we instead need to track what programs \emph{require} from the environment.

\paragraph{Tracking context requirements.}

The systems for tracking of context requirements developed in this thesis are inspired by the idea
of effect systems. To demonstrate our approach, consider the following call from the sample program
shown earlier -- first using standard ML-like type system:
%
\begin{equation*}
\ident{password}\!:\!\ident{string},~\ident{cmd}\!:\!\ident{string}
  \vdash \ident{query}(\ident{cmd}, \ident{password}) : \ident{news list}
\end{equation*}
%
The expression queries a database and gets back a list of news values as the result. Recall from the
earlier discussion that there are two contextual information that are desirable to track for this
expression. First, the call to the \ident{query} primitive requires \emph{database access}. Second,
the \ident{password} argument needs to be marked as \emph{sensitive value} to avoid sending it over
an unsecure network connection. The \emph{coeffect systems} developed in this thesis capture this 
information in the following way (we slightly refine the notation later):
%
\begin{equation*}
\begin{array}{l}
 \coctx{( \ident{password}\!:\!\coctx{\ident{string}}{\hspace{-0.75em}\ident{\cclrd{\footnotesize sensitive}}},
   \ident{cmd}\!:\!\ident{string})}{ \aclrd{\{ \ident{database} \}}}  \\[-0.1em]
 \hspace{3em} \vdash\ident{query}(\ident{cmd}, \ident{password}) : \ident{news list}
\end{array}
\end{equation*}
%
Rather than attaching the annotation to the \emph{resulting type}, we attach them to the variable
context $\Gamma$. In other words, coeffect systems do not keep track just of the variables available
in the context -- they also capture detailed information about the execution environment.
In the above example, the system tracks meta-data about the variables and annotates \ident{password} 
as sensitive. Furthermore, it tracks requirements about the execution environment, for example,
that the execution requires an access to database.

The example demonstrates the two kinds of coeffect systems outlined earlier. The tracking of
\emph{whole-context} information (such as environment requirements) is captured by the \emph{flat
coeffect calculus} developed in Chapter~\ref{ch:flat}, while the tracking of \emph{per-variable}
information is captured by the \emph{structural coeffect calculus} developed in Chapter~\ref{ch:structural}.

It is well-known fact that \emph{effects} correspond to \emph{monads} and languages such as Haskell 
use monads to provide a limited form of effect system. An interesting observation made in this thesis 
is that \emph{coeffects}, or systems for tracking contextual information, correspond to the category 
theoretical dual of monads called \emph{comonads}. The details are explained throughout the thesis.

% ==================================================================================================
%
%     ###           #      ##      #                 
%    #   #          #       #                        
%    #   #  #   #  ####     #     ##    # ##    ###  
%    #   #  #   #   #       #      #    ##  #  #   # 
%    #   #  #   #   #       #      #    #   #  ##### 
%    #   #  #  ##   #  #    #      #    #   #  #     
%     ###    ## #    ##    ###    ###   #   #   ###  
%
% ==================================================================================================                                                   
                                                 
\section{Thesis outline}

The key claim of this thesis is that programming languages need to provide better ways of capturing
how programs rely on the context, or execution environment, in which they execute. This chapter 
shows why this is an important problem. We looked at a number of properties related to context that 
are currently handled in ad-hoc and error-prone ways. Next, we considered the properties in a 
simplified, but realistic example of a client/server application for displaying local news.

Tracking of contextual properties may not be initially perceived as a major problem -- perhaps
because we are so used to write code in certain ways that prevent us from seeing the flaws. The
purpose of this chapter was to expose the flaws and convince the reader that there should be a
better solution. Finding the foundations of such better solution is the goal of this thesis:

\begin{itemize}
\item In Chapter~\ref{ch:pathways}, we give an overview of related work. Most importantly, we show
  that the idea of context-aware computations can be naturally approached from a number of
  directions developed recently in the theory of programming languages (including type and effect
  systems, categorical semantics and sub-structural logics).

\item In Chapter~\ref{ch:applications}, we present the first contribution of the thesis -- the discovery
  of the connection between a number of existing programming language features that are related
  to context. The chapter presents type systems and semantics for a number of systems and analyses 
  (including data-flow, liveness analysis, distributed programming and Haskell's type classes).
  Our novel presentation reveals their similarity.

\item In Chapter~\ref{ch:flat} and Chapter~\ref{ch:structural}, we present the key
  contributions of this thesis. We develop the \emph{flat} and \emph{structural} calculi, show
  how they capture important contextual properties and develop their categorical semantics using
  a notion based on comonads. Chapter~\ref{ch:unified}  links the two systems using a single 
  formalism that is capable of capturing both flat and structural properties and also discusses
  an alternative presentation that is more suitable for automatic type inference of coeffects.

\item Related work is presented in Chapter~\ref{ch:pathways} and throughout the thesis. 
  One important direction deserves further exploration, and so Chapter~\ref{ch:unified}
  also includes a brief discussion of a different approach to tracking contextual information that 
  arises from modal logics. This is followed by an outline of the future work that is needed
  in order to implement the presented theory in main-stream programming languages.
\end{itemize}

\noindent
If there is a one thing that the reader should remember from this thesis, it is the fact that
there is a unified notion of \emph{context}, capturing many common scenarios in programming, 
and that programming language designers need to provide ways for working with this context (using 
\emph{coeffects} or not). This greatly reduces the number of distinct concepts that software 
developers need to keep in mind of when building applications for the rich and diverse 
execution environments of the future.